#![feature(prelude_import)]
#[macro_use]
extern crate std;
#[prelude_import]
use std::prelude::rust_2021::*;
pub mod types {
    use crate::prelude::*;
    mod avoidnode {
        use crate::prelude::*;
        pub struct AvoidNode {
            pub base: NiNode,
        }
        impl AvoidNode {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"AvoidNode"
            }
        }
        impl Visitor for AvoidNode {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for AvoidNode {
            type Target = NiNode;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for AvoidNode {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for AvoidNode {
            #[inline]
            fn clone(&self) -> AvoidNode {
                AvoidNode {
                    base: ::core::clone::Clone::clone(&self.base),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for AvoidNode {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "AvoidNode",
                    "base",
                    &&self.base,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for AvoidNode {
            #[inline]
            fn default() -> AvoidNode {
                AvoidNode {
                    base: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for AvoidNode {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for AvoidNode {
            #[inline]
            fn eq(&self, other: &AvoidNode) -> bool {
                self.base == other.base
            }
        }
        impl Load for AvoidNode {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                Ok(Self { base })
            }
        }
        impl Save for AvoidNode {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                Ok(())
            }
        }
    }
    mod brickniextradata {
        use crate::prelude::*;
        pub struct BrickNiExtraData {
            pub base: NiExtraData,
        }
        impl BrickNiExtraData {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"BrickNiExtraData"
            }
        }
        impl Visitor for BrickNiExtraData {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for BrickNiExtraData {
            type Target = NiExtraData;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for BrickNiExtraData {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for BrickNiExtraData {
            #[inline]
            fn clone(&self) -> BrickNiExtraData {
                BrickNiExtraData {
                    base: ::core::clone::Clone::clone(&self.base),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for BrickNiExtraData {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "BrickNiExtraData",
                    "base",
                    &&self.base,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for BrickNiExtraData {
            #[inline]
            fn default() -> BrickNiExtraData {
                BrickNiExtraData {
                    base: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for BrickNiExtraData {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for BrickNiExtraData {
            #[inline]
            fn eq(&self, other: &BrickNiExtraData) -> bool {
                self.base == other.base
            }
        }
        impl Load for BrickNiExtraData {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                Ok(Self { base })
            }
        }
        impl Save for BrickNiExtraData {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                Ok(())
            }
        }
    }
    mod bsmirrorednode {
        use crate::prelude::*;
        pub struct BSMirroredNode {
            pub base: NiNode,
        }
        impl BSMirroredNode {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"BSMirroredNode"
            }
        }
        impl Visitor for BSMirroredNode {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for BSMirroredNode {
            type Target = NiNode;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for BSMirroredNode {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for BSMirroredNode {
            #[inline]
            fn clone(&self) -> BSMirroredNode {
                BSMirroredNode {
                    base: ::core::clone::Clone::clone(&self.base),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for BSMirroredNode {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "BSMirroredNode",
                    "base",
                    &&self.base,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for BSMirroredNode {
            #[inline]
            fn default() -> BSMirroredNode {
                BSMirroredNode {
                    base: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for BSMirroredNode {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for BSMirroredNode {
            #[inline]
            fn eq(&self, other: &BSMirroredNode) -> bool {
                self.base == other.base
            }
        }
        impl Load for BSMirroredNode {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                Ok(Self { base })
            }
        }
        impl Save for BSMirroredNode {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                Ok(())
            }
        }
    }
    mod enums {
        use crate::prelude::*;
        #[repr(i32)]
        pub enum BoundType {
            #[default]
            Sphere = 0,
            Box = 1,
            Capsule = 2,
            Lozenge = 3,
            Union = 4,
            Halfspace = 5,
        }
        const _: () = {
            use bytes_io::*;
            impl AsRepr for BoundType {
                type Repr = i32;
            }
            impl TryFrom<i32> for BoundType {
                type Error = ();
                fn try_from(value: i32) -> Result<Self, Self::Error> {
                    match value {
                        0 => Ok(Self::Sphere),
                        1 => Ok(Self::Box),
                        2 => Ok(Self::Capsule),
                        3 => Ok(Self::Lozenge),
                        4 => Ok(Self::Union),
                        5 => Ok(Self::Halfspace),
                        _ => Err(()),
                    }
                }
            }
            impl Load for BoundType {
                fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                    let value: i32 = stream.load()?;
                    Ok(value.try_into().unwrap_or_default())
                }
            }
            impl Save for BoundType {
                fn save(&self, stream: &mut Writer) -> io::Result<()> {
                    stream.save(&(*self as i32))
                }
            }
            impl BoundType {
                pub const fn display(&self) -> &'static str {
                    match self {
                        Self::Sphere => "Sphere",
                        Self::Box => "Box",
                        Self::Capsule => "Capsule",
                        Self::Lozenge => "Lozenge",
                        Self::Union => "Union",
                        Self::Halfspace => "Halfspace",
                    }
                }
            }
        };
        unsafe impl ::bytemuck::NoUninit for BoundType {}
        #[automatically_derived]
        impl ::core::clone::Clone for BoundType {
            #[inline]
            fn clone(&self) -> BoundType {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for BoundType {}
        #[automatically_derived]
        impl ::core::fmt::Debug for BoundType {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        BoundType::Sphere => "Sphere",
                        BoundType::Box => "Box",
                        BoundType::Capsule => "Capsule",
                        BoundType::Lozenge => "Lozenge",
                        BoundType::Union => "Union",
                        BoundType::Halfspace => "Halfspace",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for BoundType {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        impl ::core::hash::Hash for BoundType {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_discr, state)
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for BoundType {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for BoundType {
            #[inline]
            fn eq(&self, other: &BoundType) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for BoundType {
            #[inline]
            fn default() -> BoundType {
                Self::Sphere
            }
        }
        #[repr(i32)]
        pub enum KeyContent {
            #[default]
            FloatKey = 0,
            PosKey = 1,
            RotKey = 2,
            ColorKey = 3,
            TextKey = 4,
            VisKey = 5,
        }
        const _: () = {
            use bytes_io::*;
            impl AsRepr for KeyContent {
                type Repr = i32;
            }
            impl TryFrom<i32> for KeyContent {
                type Error = ();
                fn try_from(value: i32) -> Result<Self, Self::Error> {
                    match value {
                        0 => Ok(Self::FloatKey),
                        1 => Ok(Self::PosKey),
                        2 => Ok(Self::RotKey),
                        3 => Ok(Self::ColorKey),
                        4 => Ok(Self::TextKey),
                        5 => Ok(Self::VisKey),
                        _ => Err(()),
                    }
                }
            }
            impl Load for KeyContent {
                fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                    let value: i32 = stream.load()?;
                    Ok(value.try_into().unwrap_or_default())
                }
            }
            impl Save for KeyContent {
                fn save(&self, stream: &mut Writer) -> io::Result<()> {
                    stream.save(&(*self as i32))
                }
            }
            impl KeyContent {
                pub const fn display(&self) -> &'static str {
                    match self {
                        Self::FloatKey => "FloatKey",
                        Self::PosKey => "PosKey",
                        Self::RotKey => "RotKey",
                        Self::ColorKey => "ColorKey",
                        Self::TextKey => "TextKey",
                        Self::VisKey => "VisKey",
                    }
                }
            }
        };
        unsafe impl ::bytemuck::NoUninit for KeyContent {}
        #[automatically_derived]
        impl ::core::clone::Clone for KeyContent {
            #[inline]
            fn clone(&self) -> KeyContent {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for KeyContent {}
        #[automatically_derived]
        impl ::core::fmt::Debug for KeyContent {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        KeyContent::FloatKey => "FloatKey",
                        KeyContent::PosKey => "PosKey",
                        KeyContent::RotKey => "RotKey",
                        KeyContent::ColorKey => "ColorKey",
                        KeyContent::TextKey => "TextKey",
                        KeyContent::VisKey => "VisKey",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for KeyContent {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        impl ::core::hash::Hash for KeyContent {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_discr, state)
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for KeyContent {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for KeyContent {
            #[inline]
            fn eq(&self, other: &KeyContent) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for KeyContent {
            #[inline]
            fn default() -> KeyContent {
                Self::FloatKey
            }
        }
        #[repr(i32)]
        pub enum KeyType {
            #[default]
            NoInterp = 0,
            LinKey = 1,
            BezKey = 2,
            TCBKey = 3,
            EulerKey = 4,
        }
        const _: () = {
            use bytes_io::*;
            impl AsRepr for KeyType {
                type Repr = i32;
            }
            impl TryFrom<i32> for KeyType {
                type Error = ();
                fn try_from(value: i32) -> Result<Self, Self::Error> {
                    match value {
                        0 => Ok(Self::NoInterp),
                        1 => Ok(Self::LinKey),
                        2 => Ok(Self::BezKey),
                        3 => Ok(Self::TCBKey),
                        4 => Ok(Self::EulerKey),
                        _ => Err(()),
                    }
                }
            }
            impl Load for KeyType {
                fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                    let value: i32 = stream.load()?;
                    Ok(value.try_into().unwrap_or_default())
                }
            }
            impl Save for KeyType {
                fn save(&self, stream: &mut Writer) -> io::Result<()> {
                    stream.save(&(*self as i32))
                }
            }
            impl KeyType {
                pub const fn display(&self) -> &'static str {
                    match self {
                        Self::NoInterp => "NoInterp",
                        Self::LinKey => "LinKey",
                        Self::BezKey => "BezKey",
                        Self::TCBKey => "TCBKey",
                        Self::EulerKey => "EulerKey",
                    }
                }
            }
        };
        unsafe impl ::bytemuck::NoUninit for KeyType {}
        #[automatically_derived]
        impl ::core::clone::Clone for KeyType {
            #[inline]
            fn clone(&self) -> KeyType {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for KeyType {}
        #[automatically_derived]
        impl ::core::fmt::Debug for KeyType {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        KeyType::NoInterp => "NoInterp",
                        KeyType::LinKey => "LinKey",
                        KeyType::BezKey => "BezKey",
                        KeyType::TCBKey => "TCBKey",
                        KeyType::EulerKey => "EulerKey",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for KeyType {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        impl ::core::hash::Hash for KeyType {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_discr, state)
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for KeyType {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for KeyType {
            #[inline]
            fn eq(&self, other: &KeyType) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for KeyType {
            #[inline]
            fn default() -> KeyType {
                Self::NoInterp
            }
        }
        #[repr(i32)]
        pub enum ForceType {
            #[default]
            Planar = 0,
            Spherical = 1,
        }
        const _: () = {
            use bytes_io::*;
            impl AsRepr for ForceType {
                type Repr = i32;
            }
            impl TryFrom<i32> for ForceType {
                type Error = ();
                fn try_from(value: i32) -> Result<Self, Self::Error> {
                    match value {
                        0 => Ok(Self::Planar),
                        1 => Ok(Self::Spherical),
                        _ => Err(()),
                    }
                }
            }
            impl Load for ForceType {
                fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                    let value: i32 = stream.load()?;
                    Ok(value.try_into().unwrap_or_default())
                }
            }
            impl Save for ForceType {
                fn save(&self, stream: &mut Writer) -> io::Result<()> {
                    stream.save(&(*self as i32))
                }
            }
            impl ForceType {
                pub const fn display(&self) -> &'static str {
                    match self {
                        Self::Planar => "Planar",
                        Self::Spherical => "Spherical",
                    }
                }
            }
        };
        unsafe impl ::bytemuck::NoUninit for ForceType {}
        #[automatically_derived]
        impl ::core::clone::Clone for ForceType {
            #[inline]
            fn clone(&self) -> ForceType {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for ForceType {}
        #[automatically_derived]
        impl ::core::fmt::Debug for ForceType {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        ForceType::Planar => "Planar",
                        ForceType::Spherical => "Spherical",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for ForceType {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        impl ::core::hash::Hash for ForceType {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_discr, state)
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for ForceType {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for ForceType {
            #[inline]
            fn eq(&self, other: &ForceType) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for ForceType {
            #[inline]
            fn default() -> ForceType {
                Self::Planar
            }
        }
        #[repr(i32)]
        pub enum ColorField {
            #[default]
            Ambient = 0,
            Diffuse = 1,
            Specular = 2,
            Emissive = 3,
        }
        const _: () = {
            use bytes_io::*;
            impl AsRepr for ColorField {
                type Repr = i32;
            }
            impl TryFrom<i32> for ColorField {
                type Error = ();
                fn try_from(value: i32) -> Result<Self, Self::Error> {
                    match value {
                        0 => Ok(Self::Ambient),
                        1 => Ok(Self::Diffuse),
                        2 => Ok(Self::Specular),
                        3 => Ok(Self::Emissive),
                        _ => Err(()),
                    }
                }
            }
            impl Load for ColorField {
                fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                    let value: i32 = stream.load()?;
                    Ok(value.try_into().unwrap_or_default())
                }
            }
            impl Save for ColorField {
                fn save(&self, stream: &mut Writer) -> io::Result<()> {
                    stream.save(&(*self as i32))
                }
            }
            impl ColorField {
                pub const fn display(&self) -> &'static str {
                    match self {
                        Self::Ambient => "Ambient",
                        Self::Diffuse => "Diffuse",
                        Self::Specular => "Specular",
                        Self::Emissive => "Emissive",
                    }
                }
            }
        };
        unsafe impl ::bytemuck::NoUninit for ColorField {}
        #[automatically_derived]
        impl ::core::clone::Clone for ColorField {
            #[inline]
            fn clone(&self) -> ColorField {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for ColorField {}
        #[automatically_derived]
        impl ::core::fmt::Debug for ColorField {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        ColorField::Ambient => "Ambient",
                        ColorField::Diffuse => "Diffuse",
                        ColorField::Specular => "Specular",
                        ColorField::Emissive => "Emissive",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for ColorField {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        impl ::core::hash::Hash for ColorField {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_discr, state)
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for ColorField {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for ColorField {
            #[inline]
            fn eq(&self, other: &ColorField) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for ColorField {
            #[inline]
            fn default() -> ColorField {
                Self::Ambient
            }
        }
        #[repr(i32)]
        pub enum DecayType {
            #[default]
            None = 0,
            Linear = 1,
            Exponential = 2,
        }
        const _: () = {
            use bytes_io::*;
            impl AsRepr for DecayType {
                type Repr = i32;
            }
            impl TryFrom<i32> for DecayType {
                type Error = ();
                fn try_from(value: i32) -> Result<Self, Self::Error> {
                    match value {
                        0 => Ok(Self::None),
                        1 => Ok(Self::Linear),
                        2 => Ok(Self::Exponential),
                        _ => Err(()),
                    }
                }
            }
            impl Load for DecayType {
                fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                    let value: i32 = stream.load()?;
                    Ok(value.try_into().unwrap_or_default())
                }
            }
            impl Save for DecayType {
                fn save(&self, stream: &mut Writer) -> io::Result<()> {
                    stream.save(&(*self as i32))
                }
            }
            impl DecayType {
                pub const fn display(&self) -> &'static str {
                    match self {
                        Self::None => "None",
                        Self::Linear => "Linear",
                        Self::Exponential => "Exponential",
                    }
                }
            }
        };
        unsafe impl ::bytemuck::NoUninit for DecayType {}
        #[automatically_derived]
        impl ::core::clone::Clone for DecayType {
            #[inline]
            fn clone(&self) -> DecayType {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for DecayType {}
        #[automatically_derived]
        impl ::core::fmt::Debug for DecayType {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        DecayType::None => "None",
                        DecayType::Linear => "Linear",
                        DecayType::Exponential => "Exponential",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for DecayType {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        impl ::core::hash::Hash for DecayType {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_discr, state)
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for DecayType {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for DecayType {
            #[inline]
            fn eq(&self, other: &DecayType) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for DecayType {
            #[inline]
            fn default() -> DecayType {
                Self::None
            }
        }
        #[repr(i32)]
        pub enum SymmetryType {
            #[default]
            Spherical = 0,
            Cylindrical = 1,
            Planar = 2,
        }
        const _: () = {
            use bytes_io::*;
            impl AsRepr for SymmetryType {
                type Repr = i32;
            }
            impl TryFrom<i32> for SymmetryType {
                type Error = ();
                fn try_from(value: i32) -> Result<Self, Self::Error> {
                    match value {
                        0 => Ok(Self::Spherical),
                        1 => Ok(Self::Cylindrical),
                        2 => Ok(Self::Planar),
                        _ => Err(()),
                    }
                }
            }
            impl Load for SymmetryType {
                fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                    let value: i32 = stream.load()?;
                    Ok(value.try_into().unwrap_or_default())
                }
            }
            impl Save for SymmetryType {
                fn save(&self, stream: &mut Writer) -> io::Result<()> {
                    stream.save(&(*self as i32))
                }
            }
            impl SymmetryType {
                pub const fn display(&self) -> &'static str {
                    match self {
                        Self::Spherical => "Spherical",
                        Self::Cylindrical => "Cylindrical",
                        Self::Planar => "Planar",
                    }
                }
            }
        };
        unsafe impl ::bytemuck::NoUninit for SymmetryType {}
        #[automatically_derived]
        impl ::core::clone::Clone for SymmetryType {
            #[inline]
            fn clone(&self) -> SymmetryType {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for SymmetryType {}
        #[automatically_derived]
        impl ::core::fmt::Debug for SymmetryType {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        SymmetryType::Spherical => "Spherical",
                        SymmetryType::Cylindrical => "Cylindrical",
                        SymmetryType::Planar => "Planar",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for SymmetryType {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        impl ::core::hash::Hash for SymmetryType {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_discr, state)
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for SymmetryType {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for SymmetryType {
            #[inline]
            fn eq(&self, other: &SymmetryType) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for SymmetryType {
            #[inline]
            fn default() -> SymmetryType {
                Self::Spherical
            }
        }
        #[repr(i32)]
        pub enum BankDirection {
            Negative = -1,
            #[default]
            Positive = 1,
        }
        const _: () = {
            use bytes_io::*;
            impl AsRepr for BankDirection {
                type Repr = i32;
            }
            impl TryFrom<i32> for BankDirection {
                type Error = ();
                fn try_from(value: i32) -> Result<Self, Self::Error> {
                    match value {
                        -1 => Ok(Self::Negative),
                        1 => Ok(Self::Positive),
                        _ => Err(()),
                    }
                }
            }
            impl Load for BankDirection {
                fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                    let value: i32 = stream.load()?;
                    Ok(value.try_into().unwrap_or_default())
                }
            }
            impl Save for BankDirection {
                fn save(&self, stream: &mut Writer) -> io::Result<()> {
                    stream.save(&(*self as i32))
                }
            }
            impl BankDirection {
                pub const fn display(&self) -> &'static str {
                    match self {
                        Self::Negative => "Negative",
                        Self::Positive => "Positive",
                    }
                }
            }
        };
        unsafe impl ::bytemuck::NoUninit for BankDirection {}
        #[automatically_derived]
        impl ::core::clone::Clone for BankDirection {
            #[inline]
            fn clone(&self) -> BankDirection {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for BankDirection {}
        #[automatically_derived]
        impl ::core::fmt::Debug for BankDirection {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        BankDirection::Negative => "Negative",
                        BankDirection::Positive => "Positive",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for BankDirection {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        impl ::core::hash::Hash for BankDirection {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_discr, state)
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for BankDirection {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for BankDirection {
            #[inline]
            fn eq(&self, other: &BankDirection) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for BankDirection {
            #[inline]
            fn default() -> BankDirection {
                Self::Positive
            }
        }
        #[repr(i32)]
        pub enum PixelFormat {
            #[default]
            RGB = 0,
            RGBA = 1,
            PAL = 2,
            PALAlpha = 3,
            Compress1 = 4,
            Compress3 = 5,
            Compress5 = 6,
            RGB24NonInterleaved = 7,
            Bump = 8,
            BumpLuma = 9,
        }
        const _: () = {
            use bytes_io::*;
            impl AsRepr for PixelFormat {
                type Repr = i32;
            }
            impl TryFrom<i32> for PixelFormat {
                type Error = ();
                fn try_from(value: i32) -> Result<Self, Self::Error> {
                    match value {
                        0 => Ok(Self::RGB),
                        1 => Ok(Self::RGBA),
                        2 => Ok(Self::PAL),
                        3 => Ok(Self::PALAlpha),
                        4 => Ok(Self::Compress1),
                        5 => Ok(Self::Compress3),
                        6 => Ok(Self::Compress5),
                        7 => Ok(Self::RGB24NonInterleaved),
                        8 => Ok(Self::Bump),
                        9 => Ok(Self::BumpLuma),
                        _ => Err(()),
                    }
                }
            }
            impl Load for PixelFormat {
                fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                    let value: i32 = stream.load()?;
                    Ok(value.try_into().unwrap_or_default())
                }
            }
            impl Save for PixelFormat {
                fn save(&self, stream: &mut Writer) -> io::Result<()> {
                    stream.save(&(*self as i32))
                }
            }
            impl PixelFormat {
                pub const fn display(&self) -> &'static str {
                    match self {
                        Self::RGB => "RGB",
                        Self::RGBA => "RGBA",
                        Self::PAL => "PAL",
                        Self::PALAlpha => "PALAlpha",
                        Self::Compress1 => "Compress1",
                        Self::Compress3 => "Compress3",
                        Self::Compress5 => "Compress5",
                        Self::RGB24NonInterleaved => "RGB24NonInterleaved",
                        Self::Bump => "Bump",
                        Self::BumpLuma => "BumpLuma",
                    }
                }
            }
        };
        unsafe impl ::bytemuck::NoUninit for PixelFormat {}
        #[automatically_derived]
        impl ::core::clone::Clone for PixelFormat {
            #[inline]
            fn clone(&self) -> PixelFormat {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for PixelFormat {}
        #[automatically_derived]
        impl ::core::fmt::Debug for PixelFormat {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        PixelFormat::RGB => "RGB",
                        PixelFormat::RGBA => "RGBA",
                        PixelFormat::PAL => "PAL",
                        PixelFormat::PALAlpha => "PALAlpha",
                        PixelFormat::Compress1 => "Compress1",
                        PixelFormat::Compress3 => "Compress3",
                        PixelFormat::Compress5 => "Compress5",
                        PixelFormat::RGB24NonInterleaved => "RGB24NonInterleaved",
                        PixelFormat::Bump => "Bump",
                        PixelFormat::BumpLuma => "BumpLuma",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for PixelFormat {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        impl ::core::hash::Hash for PixelFormat {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_discr, state)
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for PixelFormat {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for PixelFormat {
            #[inline]
            fn eq(&self, other: &PixelFormat) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for PixelFormat {
            #[inline]
            fn default() -> PixelFormat {
                Self::RGB
            }
        }
        #[repr(i32)]
        pub enum AxisOrder {
            #[default]
            XYZ = 0,
            XZY = 1,
            YZX = 2,
            YXZ = 3,
            ZXY = 4,
            ZYX = 5,
            XYX = 6,
            YZY = 7,
            ZXZ = 8,
        }
        const _: () = {
            use bytes_io::*;
            impl AsRepr for AxisOrder {
                type Repr = i32;
            }
            impl TryFrom<i32> for AxisOrder {
                type Error = ();
                fn try_from(value: i32) -> Result<Self, Self::Error> {
                    match value {
                        0 => Ok(Self::XYZ),
                        1 => Ok(Self::XZY),
                        2 => Ok(Self::YZX),
                        3 => Ok(Self::YXZ),
                        4 => Ok(Self::ZXY),
                        5 => Ok(Self::ZYX),
                        6 => Ok(Self::XYX),
                        7 => Ok(Self::YZY),
                        8 => Ok(Self::ZXZ),
                        _ => Err(()),
                    }
                }
            }
            impl Load for AxisOrder {
                fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                    let value: i32 = stream.load()?;
                    Ok(value.try_into().unwrap_or_default())
                }
            }
            impl Save for AxisOrder {
                fn save(&self, stream: &mut Writer) -> io::Result<()> {
                    stream.save(&(*self as i32))
                }
            }
            impl AxisOrder {
                pub const fn display(&self) -> &'static str {
                    match self {
                        Self::XYZ => "XYZ",
                        Self::XZY => "XZY",
                        Self::YZX => "YZX",
                        Self::YXZ => "YXZ",
                        Self::ZXY => "ZXY",
                        Self::ZYX => "ZYX",
                        Self::XYX => "XYX",
                        Self::YZY => "YZY",
                        Self::ZXZ => "ZXZ",
                    }
                }
            }
        };
        unsafe impl ::bytemuck::NoUninit for AxisOrder {}
        #[automatically_derived]
        impl ::core::clone::Clone for AxisOrder {
            #[inline]
            fn clone(&self) -> AxisOrder {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for AxisOrder {}
        #[automatically_derived]
        impl ::core::fmt::Debug for AxisOrder {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        AxisOrder::XYZ => "XYZ",
                        AxisOrder::XZY => "XZY",
                        AxisOrder::YZX => "YZX",
                        AxisOrder::YXZ => "YXZ",
                        AxisOrder::ZXY => "ZXY",
                        AxisOrder::ZYX => "ZYX",
                        AxisOrder::XYX => "XYX",
                        AxisOrder::YZY => "YZY",
                        AxisOrder::ZXZ => "ZXZ",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for AxisOrder {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        impl ::core::hash::Hash for AxisOrder {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_discr, state)
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for AxisOrder {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for AxisOrder {
            #[inline]
            fn eq(&self, other: &AxisOrder) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for AxisOrder {
            #[inline]
            fn default() -> AxisOrder {
                Self::XYZ
            }
        }
        #[repr(i32)]
        pub enum SortingMode {
            #[default]
            Inherit = 0,
            Off = 1,
            Subsort = 2,
            Grouped = 64,
        }
        const _: () = {
            use bytes_io::*;
            impl AsRepr for SortingMode {
                type Repr = i32;
            }
            impl TryFrom<i32> for SortingMode {
                type Error = ();
                fn try_from(value: i32) -> Result<Self, Self::Error> {
                    match value {
                        0 => Ok(Self::Inherit),
                        1 => Ok(Self::Off),
                        2 => Ok(Self::Subsort),
                        64 => Ok(Self::Grouped),
                        _ => Err(()),
                    }
                }
            }
            impl Load for SortingMode {
                fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                    let value: i32 = stream.load()?;
                    Ok(value.try_into().unwrap_or_default())
                }
            }
            impl Save for SortingMode {
                fn save(&self, stream: &mut Writer) -> io::Result<()> {
                    stream.save(&(*self as i32))
                }
            }
            impl SortingMode {
                pub const fn display(&self) -> &'static str {
                    match self {
                        Self::Inherit => "Inherit",
                        Self::Off => "Off",
                        Self::Subsort => "Subsort",
                        Self::Grouped => "Grouped",
                    }
                }
            }
        };
        unsafe impl ::bytemuck::NoUninit for SortingMode {}
        #[automatically_derived]
        impl ::core::clone::Clone for SortingMode {
            #[inline]
            fn clone(&self) -> SortingMode {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for SortingMode {}
        #[automatically_derived]
        impl ::core::fmt::Debug for SortingMode {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        SortingMode::Inherit => "Inherit",
                        SortingMode::Off => "Off",
                        SortingMode::Subsort => "Subsort",
                        SortingMode::Grouped => "Grouped",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for SortingMode {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        impl ::core::hash::Hash for SortingMode {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_discr, state)
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for SortingMode {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for SortingMode {
            #[inline]
            fn eq(&self, other: &SortingMode) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for SortingMode {
            #[inline]
            fn default() -> SortingMode {
                Self::Inherit
            }
        }
        #[repr(i32)]
        pub enum PixelLayout {
            Palettized8 = 0,
            HighColor16 = 1,
            TrueColor32 = 2,
            Compressed = 3,
            BumpMap = 4,
            Palettized4 = 5,
            #[default]
            Default = 6,
        }
        const _: () = {
            use bytes_io::*;
            impl AsRepr for PixelLayout {
                type Repr = i32;
            }
            impl TryFrom<i32> for PixelLayout {
                type Error = ();
                fn try_from(value: i32) -> Result<Self, Self::Error> {
                    match value {
                        0 => Ok(Self::Palettized8),
                        1 => Ok(Self::HighColor16),
                        2 => Ok(Self::TrueColor32),
                        3 => Ok(Self::Compressed),
                        4 => Ok(Self::BumpMap),
                        5 => Ok(Self::Palettized4),
                        6 => Ok(Self::Default),
                        _ => Err(()),
                    }
                }
            }
            impl Load for PixelLayout {
                fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                    let value: i32 = stream.load()?;
                    Ok(value.try_into().unwrap_or_default())
                }
            }
            impl Save for PixelLayout {
                fn save(&self, stream: &mut Writer) -> io::Result<()> {
                    stream.save(&(*self as i32))
                }
            }
            impl PixelLayout {
                pub const fn display(&self) -> &'static str {
                    match self {
                        Self::Palettized8 => "Palettized8",
                        Self::HighColor16 => "HighColor16",
                        Self::TrueColor32 => "TrueColor32",
                        Self::Compressed => "Compressed",
                        Self::BumpMap => "BumpMap",
                        Self::Palettized4 => "Palettized4",
                        Self::Default => "Default",
                    }
                }
            }
        };
        unsafe impl ::bytemuck::NoUninit for PixelLayout {}
        #[automatically_derived]
        impl ::core::clone::Clone for PixelLayout {
            #[inline]
            fn clone(&self) -> PixelLayout {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for PixelLayout {}
        #[automatically_derived]
        impl ::core::fmt::Debug for PixelLayout {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        PixelLayout::Palettized8 => "Palettized8",
                        PixelLayout::HighColor16 => "HighColor16",
                        PixelLayout::TrueColor32 => "TrueColor32",
                        PixelLayout::Compressed => "Compressed",
                        PixelLayout::BumpMap => "BumpMap",
                        PixelLayout::Palettized4 => "Palettized4",
                        PixelLayout::Default => "Default",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for PixelLayout {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        impl ::core::hash::Hash for PixelLayout {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_discr, state)
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for PixelLayout {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for PixelLayout {
            #[inline]
            fn eq(&self, other: &PixelLayout) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for PixelLayout {
            #[inline]
            fn default() -> PixelLayout {
                Self::Default
            }
        }
        #[repr(i32)]
        pub enum UseMipMaps {
            No = 0,
            Yes = 1,
            #[default]
            Default = 2,
        }
        const _: () = {
            use bytes_io::*;
            impl AsRepr for UseMipMaps {
                type Repr = i32;
            }
            impl TryFrom<i32> for UseMipMaps {
                type Error = ();
                fn try_from(value: i32) -> Result<Self, Self::Error> {
                    match value {
                        0 => Ok(Self::No),
                        1 => Ok(Self::Yes),
                        2 => Ok(Self::Default),
                        _ => Err(()),
                    }
                }
            }
            impl Load for UseMipMaps {
                fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                    let value: i32 = stream.load()?;
                    Ok(value.try_into().unwrap_or_default())
                }
            }
            impl Save for UseMipMaps {
                fn save(&self, stream: &mut Writer) -> io::Result<()> {
                    stream.save(&(*self as i32))
                }
            }
            impl UseMipMaps {
                pub const fn display(&self) -> &'static str {
                    match self {
                        Self::No => "No",
                        Self::Yes => "Yes",
                        Self::Default => "Default",
                    }
                }
            }
        };
        unsafe impl ::bytemuck::NoUninit for UseMipMaps {}
        #[automatically_derived]
        impl ::core::clone::Clone for UseMipMaps {
            #[inline]
            fn clone(&self) -> UseMipMaps {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for UseMipMaps {}
        #[automatically_derived]
        impl ::core::fmt::Debug for UseMipMaps {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        UseMipMaps::No => "No",
                        UseMipMaps::Yes => "Yes",
                        UseMipMaps::Default => "Default",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for UseMipMaps {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        impl ::core::hash::Hash for UseMipMaps {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_discr, state)
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for UseMipMaps {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for UseMipMaps {
            #[inline]
            fn eq(&self, other: &UseMipMaps) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for UseMipMaps {
            #[inline]
            fn default() -> UseMipMaps {
                Self::Default
            }
        }
        #[repr(i32)]
        pub enum AlphaFormat {
            None = 0,
            Binary = 1,
            Smooth = 2,
            #[default]
            Default = 3,
        }
        const _: () = {
            use bytes_io::*;
            impl AsRepr for AlphaFormat {
                type Repr = i32;
            }
            impl TryFrom<i32> for AlphaFormat {
                type Error = ();
                fn try_from(value: i32) -> Result<Self, Self::Error> {
                    match value {
                        0 => Ok(Self::None),
                        1 => Ok(Self::Binary),
                        2 => Ok(Self::Smooth),
                        3 => Ok(Self::Default),
                        _ => Err(()),
                    }
                }
            }
            impl Load for AlphaFormat {
                fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                    let value: i32 = stream.load()?;
                    Ok(value.try_into().unwrap_or_default())
                }
            }
            impl Save for AlphaFormat {
                fn save(&self, stream: &mut Writer) -> io::Result<()> {
                    stream.save(&(*self as i32))
                }
            }
            impl AlphaFormat {
                pub const fn display(&self) -> &'static str {
                    match self {
                        Self::None => "None",
                        Self::Binary => "Binary",
                        Self::Smooth => "Smooth",
                        Self::Default => "Default",
                    }
                }
            }
        };
        unsafe impl ::bytemuck::NoUninit for AlphaFormat {}
        #[automatically_derived]
        impl ::core::clone::Clone for AlphaFormat {
            #[inline]
            fn clone(&self) -> AlphaFormat {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for AlphaFormat {}
        #[automatically_derived]
        impl ::core::fmt::Debug for AlphaFormat {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        AlphaFormat::None => "None",
                        AlphaFormat::Binary => "Binary",
                        AlphaFormat::Smooth => "Smooth",
                        AlphaFormat::Default => "Default",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for AlphaFormat {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        impl ::core::hash::Hash for AlphaFormat {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_discr, state)
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for AlphaFormat {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for AlphaFormat {
            #[inline]
            fn eq(&self, other: &AlphaFormat) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for AlphaFormat {
            #[inline]
            fn default() -> AlphaFormat {
                Self::Default
            }
        }
        #[repr(i32)]
        pub enum StencilTestFunction {
            #[default]
            Never = 0,
            Less = 1,
            Equal = 2,
            LessEqual = 3,
            Greater = 4,
            NotEqual = 5,
            GreaterEqual = 6,
            Always = 7,
        }
        const _: () = {
            use bytes_io::*;
            impl AsRepr for StencilTestFunction {
                type Repr = i32;
            }
            impl TryFrom<i32> for StencilTestFunction {
                type Error = ();
                fn try_from(value: i32) -> Result<Self, Self::Error> {
                    match value {
                        0 => Ok(Self::Never),
                        1 => Ok(Self::Less),
                        2 => Ok(Self::Equal),
                        3 => Ok(Self::LessEqual),
                        4 => Ok(Self::Greater),
                        5 => Ok(Self::NotEqual),
                        6 => Ok(Self::GreaterEqual),
                        7 => Ok(Self::Always),
                        _ => Err(()),
                    }
                }
            }
            impl Load for StencilTestFunction {
                fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                    let value: i32 = stream.load()?;
                    Ok(value.try_into().unwrap_or_default())
                }
            }
            impl Save for StencilTestFunction {
                fn save(&self, stream: &mut Writer) -> io::Result<()> {
                    stream.save(&(*self as i32))
                }
            }
            impl StencilTestFunction {
                pub const fn display(&self) -> &'static str {
                    match self {
                        Self::Never => "Never",
                        Self::Less => "Less",
                        Self::Equal => "Equal",
                        Self::LessEqual => "LessEqual",
                        Self::Greater => "Greater",
                        Self::NotEqual => "NotEqual",
                        Self::GreaterEqual => "GreaterEqual",
                        Self::Always => "Always",
                    }
                }
            }
        };
        unsafe impl ::bytemuck::NoUninit for StencilTestFunction {}
        #[automatically_derived]
        impl ::core::clone::Clone for StencilTestFunction {
            #[inline]
            fn clone(&self) -> StencilTestFunction {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for StencilTestFunction {}
        #[automatically_derived]
        impl ::core::fmt::Debug for StencilTestFunction {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        StencilTestFunction::Never => "Never",
                        StencilTestFunction::Less => "Less",
                        StencilTestFunction::Equal => "Equal",
                        StencilTestFunction::LessEqual => "LessEqual",
                        StencilTestFunction::Greater => "Greater",
                        StencilTestFunction::NotEqual => "NotEqual",
                        StencilTestFunction::GreaterEqual => "GreaterEqual",
                        StencilTestFunction::Always => "Always",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for StencilTestFunction {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        impl ::core::hash::Hash for StencilTestFunction {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_discr, state)
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for StencilTestFunction {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for StencilTestFunction {
            #[inline]
            fn eq(&self, other: &StencilTestFunction) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for StencilTestFunction {
            #[inline]
            fn default() -> StencilTestFunction {
                Self::Never
            }
        }
        #[repr(i32)]
        pub enum Action {
            #[default]
            Keep = 0,
            Zero = 1,
            Replace = 2,
            Increment = 3,
            Decrement = 4,
            Invert = 5,
        }
        const _: () = {
            use bytes_io::*;
            impl AsRepr for Action {
                type Repr = i32;
            }
            impl TryFrom<i32> for Action {
                type Error = ();
                fn try_from(value: i32) -> Result<Self, Self::Error> {
                    match value {
                        0 => Ok(Self::Keep),
                        1 => Ok(Self::Zero),
                        2 => Ok(Self::Replace),
                        3 => Ok(Self::Increment),
                        4 => Ok(Self::Decrement),
                        5 => Ok(Self::Invert),
                        _ => Err(()),
                    }
                }
            }
            impl Load for Action {
                fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                    let value: i32 = stream.load()?;
                    Ok(value.try_into().unwrap_or_default())
                }
            }
            impl Save for Action {
                fn save(&self, stream: &mut Writer) -> io::Result<()> {
                    stream.save(&(*self as i32))
                }
            }
            impl Action {
                pub const fn display(&self) -> &'static str {
                    match self {
                        Self::Keep => "Keep",
                        Self::Zero => "Zero",
                        Self::Replace => "Replace",
                        Self::Increment => "Increment",
                        Self::Decrement => "Decrement",
                        Self::Invert => "Invert",
                    }
                }
            }
        };
        unsafe impl ::bytemuck::NoUninit for Action {}
        #[automatically_derived]
        impl ::core::clone::Clone for Action {
            #[inline]
            fn clone(&self) -> Action {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for Action {}
        #[automatically_derived]
        impl ::core::fmt::Debug for Action {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        Action::Keep => "Keep",
                        Action::Zero => "Zero",
                        Action::Replace => "Replace",
                        Action::Increment => "Increment",
                        Action::Decrement => "Decrement",
                        Action::Invert => "Invert",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for Action {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        impl ::core::hash::Hash for Action {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_discr, state)
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Action {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Action {
            #[inline]
            fn eq(&self, other: &Action) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for Action {
            #[inline]
            fn default() -> Action {
                Self::Keep
            }
        }
        #[repr(i32)]
        pub enum DrawMode {
            #[default]
            Default = 0,
            CounterClockwise = 1,
            Clockwise = 2,
            Both = 3,
        }
        const _: () = {
            use bytes_io::*;
            impl AsRepr for DrawMode {
                type Repr = i32;
            }
            impl TryFrom<i32> for DrawMode {
                type Error = ();
                fn try_from(value: i32) -> Result<Self, Self::Error> {
                    match value {
                        0 => Ok(Self::Default),
                        1 => Ok(Self::CounterClockwise),
                        2 => Ok(Self::Clockwise),
                        3 => Ok(Self::Both),
                        _ => Err(()),
                    }
                }
            }
            impl Load for DrawMode {
                fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                    let value: i32 = stream.load()?;
                    Ok(value.try_into().unwrap_or_default())
                }
            }
            impl Save for DrawMode {
                fn save(&self, stream: &mut Writer) -> io::Result<()> {
                    stream.save(&(*self as i32))
                }
            }
            impl DrawMode {
                pub const fn display(&self) -> &'static str {
                    match self {
                        Self::Default => "Default",
                        Self::CounterClockwise => "CounterClockwise",
                        Self::Clockwise => "Clockwise",
                        Self::Both => "Both",
                    }
                }
            }
        };
        unsafe impl ::bytemuck::NoUninit for DrawMode {}
        #[automatically_derived]
        impl ::core::clone::Clone for DrawMode {
            #[inline]
            fn clone(&self) -> DrawMode {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for DrawMode {}
        #[automatically_derived]
        impl ::core::fmt::Debug for DrawMode {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        DrawMode::Default => "Default",
                        DrawMode::CounterClockwise => "CounterClockwise",
                        DrawMode::Clockwise => "Clockwise",
                        DrawMode::Both => "Both",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for DrawMode {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        impl ::core::hash::Hash for DrawMode {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_discr, state)
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for DrawMode {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for DrawMode {
            #[inline]
            fn eq(&self, other: &DrawMode) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for DrawMode {
            #[inline]
            fn default() -> DrawMode {
                Self::Default
            }
        }
        #[repr(i32)]
        pub enum TextureType {
            #[default]
            ProjectedLight = 0,
            ProjectedShadow = 1,
            EnvironmentMap = 2,
            FogMap = 3,
        }
        const _: () = {
            use bytes_io::*;
            impl AsRepr for TextureType {
                type Repr = i32;
            }
            impl TryFrom<i32> for TextureType {
                type Error = ();
                fn try_from(value: i32) -> Result<Self, Self::Error> {
                    match value {
                        0 => Ok(Self::ProjectedLight),
                        1 => Ok(Self::ProjectedShadow),
                        2 => Ok(Self::EnvironmentMap),
                        3 => Ok(Self::FogMap),
                        _ => Err(()),
                    }
                }
            }
            impl Load for TextureType {
                fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                    let value: i32 = stream.load()?;
                    Ok(value.try_into().unwrap_or_default())
                }
            }
            impl Save for TextureType {
                fn save(&self, stream: &mut Writer) -> io::Result<()> {
                    stream.save(&(*self as i32))
                }
            }
            impl TextureType {
                pub const fn display(&self) -> &'static str {
                    match self {
                        Self::ProjectedLight => "ProjectedLight",
                        Self::ProjectedShadow => "ProjectedShadow",
                        Self::EnvironmentMap => "EnvironmentMap",
                        Self::FogMap => "FogMap",
                    }
                }
            }
        };
        unsafe impl ::bytemuck::NoUninit for TextureType {}
        #[automatically_derived]
        impl ::core::clone::Clone for TextureType {
            #[inline]
            fn clone(&self) -> TextureType {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for TextureType {}
        #[automatically_derived]
        impl ::core::fmt::Debug for TextureType {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        TextureType::ProjectedLight => "ProjectedLight",
                        TextureType::ProjectedShadow => "ProjectedShadow",
                        TextureType::EnvironmentMap => "EnvironmentMap",
                        TextureType::FogMap => "FogMap",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for TextureType {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        impl ::core::hash::Hash for TextureType {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_discr, state)
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for TextureType {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for TextureType {
            #[inline]
            fn eq(&self, other: &TextureType) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for TextureType {
            #[inline]
            fn default() -> TextureType {
                Self::ProjectedLight
            }
        }
        #[repr(i32)]
        pub enum CoordGenType {
            #[default]
            WorldParallel = 0,
            WorldPerspective = 1,
            SphereMap = 2,
            SpecularCubeMap = 3,
            DiffuseCubeMap = 4,
        }
        const _: () = {
            use bytes_io::*;
            impl AsRepr for CoordGenType {
                type Repr = i32;
            }
            impl TryFrom<i32> for CoordGenType {
                type Error = ();
                fn try_from(value: i32) -> Result<Self, Self::Error> {
                    match value {
                        0 => Ok(Self::WorldParallel),
                        1 => Ok(Self::WorldPerspective),
                        2 => Ok(Self::SphereMap),
                        3 => Ok(Self::SpecularCubeMap),
                        4 => Ok(Self::DiffuseCubeMap),
                        _ => Err(()),
                    }
                }
            }
            impl Load for CoordGenType {
                fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                    let value: i32 = stream.load()?;
                    Ok(value.try_into().unwrap_or_default())
                }
            }
            impl Save for CoordGenType {
                fn save(&self, stream: &mut Writer) -> io::Result<()> {
                    stream.save(&(*self as i32))
                }
            }
            impl CoordGenType {
                pub const fn display(&self) -> &'static str {
                    match self {
                        Self::WorldParallel => "WorldParallel",
                        Self::WorldPerspective => "WorldPerspective",
                        Self::SphereMap => "SphereMap",
                        Self::SpecularCubeMap => "SpecularCubeMap",
                        Self::DiffuseCubeMap => "DiffuseCubeMap",
                    }
                }
            }
        };
        unsafe impl ::bytemuck::NoUninit for CoordGenType {}
        #[automatically_derived]
        impl ::core::clone::Clone for CoordGenType {
            #[inline]
            fn clone(&self) -> CoordGenType {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for CoordGenType {}
        #[automatically_derived]
        impl ::core::fmt::Debug for CoordGenType {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        CoordGenType::WorldParallel => "WorldParallel",
                        CoordGenType::WorldPerspective => "WorldPerspective",
                        CoordGenType::SphereMap => "SphereMap",
                        CoordGenType::SpecularCubeMap => "SpecularCubeMap",
                        CoordGenType::DiffuseCubeMap => "DiffuseCubeMap",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for CoordGenType {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        impl ::core::hash::Hash for CoordGenType {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_discr, state)
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for CoordGenType {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for CoordGenType {
            #[inline]
            fn eq(&self, other: &CoordGenType) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for CoordGenType {
            #[inline]
            fn default() -> CoordGenType {
                Self::WorldParallel
            }
        }
        #[repr(i32)]
        pub enum ClampMode {
            ClampSClampT = 0,
            ClampSWrapT = 1,
            WrapSClampT = 2,
            #[default]
            WrapSWrapT = 3,
        }
        const _: () = {
            use bytes_io::*;
            impl AsRepr for ClampMode {
                type Repr = i32;
            }
            impl TryFrom<i32> for ClampMode {
                type Error = ();
                fn try_from(value: i32) -> Result<Self, Self::Error> {
                    match value {
                        0 => Ok(Self::ClampSClampT),
                        1 => Ok(Self::ClampSWrapT),
                        2 => Ok(Self::WrapSClampT),
                        3 => Ok(Self::WrapSWrapT),
                        _ => Err(()),
                    }
                }
            }
            impl Load for ClampMode {
                fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                    let value: i32 = stream.load()?;
                    Ok(value.try_into().unwrap_or_default())
                }
            }
            impl Save for ClampMode {
                fn save(&self, stream: &mut Writer) -> io::Result<()> {
                    stream.save(&(*self as i32))
                }
            }
            impl ClampMode {
                pub const fn display(&self) -> &'static str {
                    match self {
                        Self::ClampSClampT => "ClampSClampT",
                        Self::ClampSWrapT => "ClampSWrapT",
                        Self::WrapSClampT => "WrapSClampT",
                        Self::WrapSWrapT => "WrapSWrapT",
                    }
                }
            }
        };
        unsafe impl ::bytemuck::NoUninit for ClampMode {}
        #[automatically_derived]
        impl ::core::clone::Clone for ClampMode {
            #[inline]
            fn clone(&self) -> ClampMode {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for ClampMode {}
        #[automatically_derived]
        impl ::core::fmt::Debug for ClampMode {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        ClampMode::ClampSClampT => "ClampSClampT",
                        ClampMode::ClampSWrapT => "ClampSWrapT",
                        ClampMode::WrapSClampT => "WrapSClampT",
                        ClampMode::WrapSWrapT => "WrapSWrapT",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for ClampMode {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        impl ::core::hash::Hash for ClampMode {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_discr, state)
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for ClampMode {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for ClampMode {
            #[inline]
            fn eq(&self, other: &ClampMode) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for ClampMode {
            #[inline]
            fn default() -> ClampMode {
                Self::WrapSWrapT
            }
        }
        #[repr(i32)]
        pub enum FilterMode {
            Nearest = 0,
            Bilerp = 1,
            #[default]
            Trilerp = 2,
            NearestMipNearest = 3,
            NearestMipLerp = 4,
            BilerpMipNearest = 5,
        }
        const _: () = {
            use bytes_io::*;
            impl AsRepr for FilterMode {
                type Repr = i32;
            }
            impl TryFrom<i32> for FilterMode {
                type Error = ();
                fn try_from(value: i32) -> Result<Self, Self::Error> {
                    match value {
                        0 => Ok(Self::Nearest),
                        1 => Ok(Self::Bilerp),
                        2 => Ok(Self::Trilerp),
                        3 => Ok(Self::NearestMipNearest),
                        4 => Ok(Self::NearestMipLerp),
                        5 => Ok(Self::BilerpMipNearest),
                        _ => Err(()),
                    }
                }
            }
            impl Load for FilterMode {
                fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                    let value: i32 = stream.load()?;
                    Ok(value.try_into().unwrap_or_default())
                }
            }
            impl Save for FilterMode {
                fn save(&self, stream: &mut Writer) -> io::Result<()> {
                    stream.save(&(*self as i32))
                }
            }
            impl FilterMode {
                pub const fn display(&self) -> &'static str {
                    match self {
                        Self::Nearest => "Nearest",
                        Self::Bilerp => "Bilerp",
                        Self::Trilerp => "Trilerp",
                        Self::NearestMipNearest => "NearestMipNearest",
                        Self::NearestMipLerp => "NearestMipLerp",
                        Self::BilerpMipNearest => "BilerpMipNearest",
                    }
                }
            }
        };
        unsafe impl ::bytemuck::NoUninit for FilterMode {}
        #[automatically_derived]
        impl ::core::clone::Clone for FilterMode {
            #[inline]
            fn clone(&self) -> FilterMode {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for FilterMode {}
        #[automatically_derived]
        impl ::core::fmt::Debug for FilterMode {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        FilterMode::Nearest => "Nearest",
                        FilterMode::Bilerp => "Bilerp",
                        FilterMode::Trilerp => "Trilerp",
                        FilterMode::NearestMipNearest => "NearestMipNearest",
                        FilterMode::NearestMipLerp => "NearestMipLerp",
                        FilterMode::BilerpMipNearest => "BilerpMipNearest",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for FilterMode {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        impl ::core::hash::Hash for FilterMode {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_discr, state)
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for FilterMode {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for FilterMode {
            #[inline]
            fn eq(&self, other: &FilterMode) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for FilterMode {
            #[inline]
            fn default() -> FilterMode {
                Self::Trilerp
            }
        }
        #[repr(i32)]
        pub enum ApplyMode {
            Replace = 0,
            Decal = 1,
            #[default]
            Modulate = 2,
            Hilight = 3,
            Hilight2 = 4,
        }
        const _: () = {
            use bytes_io::*;
            impl AsRepr for ApplyMode {
                type Repr = i32;
            }
            impl TryFrom<i32> for ApplyMode {
                type Error = ();
                fn try_from(value: i32) -> Result<Self, Self::Error> {
                    match value {
                        0 => Ok(Self::Replace),
                        1 => Ok(Self::Decal),
                        2 => Ok(Self::Modulate),
                        3 => Ok(Self::Hilight),
                        4 => Ok(Self::Hilight2),
                        _ => Err(()),
                    }
                }
            }
            impl Load for ApplyMode {
                fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                    let value: i32 = stream.load()?;
                    Ok(value.try_into().unwrap_or_default())
                }
            }
            impl Save for ApplyMode {
                fn save(&self, stream: &mut Writer) -> io::Result<()> {
                    stream.save(&(*self as i32))
                }
            }
            impl ApplyMode {
                pub const fn display(&self) -> &'static str {
                    match self {
                        Self::Replace => "Replace",
                        Self::Decal => "Decal",
                        Self::Modulate => "Modulate",
                        Self::Hilight => "Hilight",
                        Self::Hilight2 => "Hilight2",
                    }
                }
            }
        };
        unsafe impl ::bytemuck::NoUninit for ApplyMode {}
        #[automatically_derived]
        impl ::core::clone::Clone for ApplyMode {
            #[inline]
            fn clone(&self) -> ApplyMode {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for ApplyMode {}
        #[automatically_derived]
        impl ::core::fmt::Debug for ApplyMode {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        ApplyMode::Replace => "Replace",
                        ApplyMode::Decal => "Decal",
                        ApplyMode::Modulate => "Modulate",
                        ApplyMode::Hilight => "Hilight",
                        ApplyMode::Hilight2 => "Hilight2",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for ApplyMode {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        impl ::core::hash::Hash for ApplyMode {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_discr, state)
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for ApplyMode {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for ApplyMode {
            #[inline]
            fn eq(&self, other: &ApplyMode) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for ApplyMode {
            #[inline]
            fn default() -> ApplyMode {
                Self::Modulate
            }
        }
        #[repr(i32)]
        pub enum SourceVertexMode {
            #[default]
            Ignore = 0,
            Emissive = 1,
            AmbientDiffuse = 2,
        }
        const _: () = {
            use bytes_io::*;
            impl AsRepr for SourceVertexMode {
                type Repr = i32;
            }
            impl TryFrom<i32> for SourceVertexMode {
                type Error = ();
                fn try_from(value: i32) -> Result<Self, Self::Error> {
                    match value {
                        0 => Ok(Self::Ignore),
                        1 => Ok(Self::Emissive),
                        2 => Ok(Self::AmbientDiffuse),
                        _ => Err(()),
                    }
                }
            }
            impl Load for SourceVertexMode {
                fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                    let value: i32 = stream.load()?;
                    Ok(value.try_into().unwrap_or_default())
                }
            }
            impl Save for SourceVertexMode {
                fn save(&self, stream: &mut Writer) -> io::Result<()> {
                    stream.save(&(*self as i32))
                }
            }
            impl SourceVertexMode {
                pub const fn display(&self) -> &'static str {
                    match self {
                        Self::Ignore => "Ignore",
                        Self::Emissive => "Emissive",
                        Self::AmbientDiffuse => "AmbientDiffuse",
                    }
                }
            }
        };
        unsafe impl ::bytemuck::NoUninit for SourceVertexMode {}
        #[automatically_derived]
        impl ::core::clone::Clone for SourceVertexMode {
            #[inline]
            fn clone(&self) -> SourceVertexMode {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for SourceVertexMode {}
        #[automatically_derived]
        impl ::core::fmt::Debug for SourceVertexMode {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        SourceVertexMode::Ignore => "Ignore",
                        SourceVertexMode::Emissive => "Emissive",
                        SourceVertexMode::AmbientDiffuse => "AmbientDiffuse",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for SourceVertexMode {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        impl ::core::hash::Hash for SourceVertexMode {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_discr, state)
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for SourceVertexMode {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for SourceVertexMode {
            #[inline]
            fn eq(&self, other: &SourceVertexMode) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for SourceVertexMode {
            #[inline]
            fn default() -> SourceVertexMode {
                Self::Ignore
            }
        }
        #[repr(i32)]
        pub enum LightingMode {
            Emissive = 0,
            #[default]
            EmissiveAmbientDiffuse = 1,
        }
        const _: () = {
            use bytes_io::*;
            impl AsRepr for LightingMode {
                type Repr = i32;
            }
            impl TryFrom<i32> for LightingMode {
                type Error = ();
                fn try_from(value: i32) -> Result<Self, Self::Error> {
                    match value {
                        0 => Ok(Self::Emissive),
                        1 => Ok(Self::EmissiveAmbientDiffuse),
                        _ => Err(()),
                    }
                }
            }
            impl Load for LightingMode {
                fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                    let value: i32 = stream.load()?;
                    Ok(value.try_into().unwrap_or_default())
                }
            }
            impl Save for LightingMode {
                fn save(&self, stream: &mut Writer) -> io::Result<()> {
                    stream.save(&(*self as i32))
                }
            }
            impl LightingMode {
                pub const fn display(&self) -> &'static str {
                    match self {
                        Self::Emissive => "Emissive",
                        Self::EmissiveAmbientDiffuse => "EmissiveAmbientDiffuse",
                    }
                }
            }
        };
        unsafe impl ::bytemuck::NoUninit for LightingMode {}
        #[automatically_derived]
        impl ::core::clone::Clone for LightingMode {
            #[inline]
            fn clone(&self) -> LightingMode {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for LightingMode {}
        #[automatically_derived]
        impl ::core::fmt::Debug for LightingMode {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        LightingMode::Emissive => "Emissive",
                        LightingMode::EmissiveAmbientDiffuse => "EmissiveAmbientDiffuse",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for LightingMode {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        impl ::core::hash::Hash for LightingMode {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_discr, state)
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for LightingMode {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for LightingMode {
            #[inline]
            fn eq(&self, other: &LightingMode) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for LightingMode {
            #[inline]
            fn default() -> LightingMode {
                Self::EmissiveAmbientDiffuse
            }
        }
        #[repr(u16)]
        pub enum AlphaBlendFunction {
            #[default]
            One = 0,
            Zero = 1,
            SrcColor = 2,
            InvSrcColor = 3,
            DstColor = 4,
            InvDstColor = 5,
            SrcAlpha = 6,
            InvSrcAlpha = 7,
            DstAlpha = 8,
            InvDstAlpha = 9,
            SrcAlphaSat = 10,
        }
        const _: () = {
            use bytes_io::*;
            impl AsRepr for AlphaBlendFunction {
                type Repr = u16;
            }
            impl TryFrom<u16> for AlphaBlendFunction {
                type Error = ();
                fn try_from(value: u16) -> Result<Self, Self::Error> {
                    match value {
                        0 => Ok(Self::One),
                        1 => Ok(Self::Zero),
                        2 => Ok(Self::SrcColor),
                        3 => Ok(Self::InvSrcColor),
                        4 => Ok(Self::DstColor),
                        5 => Ok(Self::InvDstColor),
                        6 => Ok(Self::SrcAlpha),
                        7 => Ok(Self::InvSrcAlpha),
                        8 => Ok(Self::DstAlpha),
                        9 => Ok(Self::InvDstAlpha),
                        10 => Ok(Self::SrcAlphaSat),
                        _ => Err(()),
                    }
                }
            }
            impl Load for AlphaBlendFunction {
                fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                    let value: u16 = stream.load()?;
                    Ok(value.try_into().unwrap_or_default())
                }
            }
            impl Save for AlphaBlendFunction {
                fn save(&self, stream: &mut Writer) -> io::Result<()> {
                    stream.save(&(*self as u16))
                }
            }
            impl AlphaBlendFunction {
                pub const fn display(&self) -> &'static str {
                    match self {
                        Self::One => "One",
                        Self::Zero => "Zero",
                        Self::SrcColor => "SrcColor",
                        Self::InvSrcColor => "InvSrcColor",
                        Self::DstColor => "DstColor",
                        Self::InvDstColor => "InvDstColor",
                        Self::SrcAlpha => "SrcAlpha",
                        Self::InvSrcAlpha => "InvSrcAlpha",
                        Self::DstAlpha => "DstAlpha",
                        Self::InvDstAlpha => "InvDstAlpha",
                        Self::SrcAlphaSat => "SrcAlphaSat",
                    }
                }
            }
        };
        unsafe impl ::bytemuck::NoUninit for AlphaBlendFunction {}
        #[automatically_derived]
        impl ::core::clone::Clone for AlphaBlendFunction {
            #[inline]
            fn clone(&self) -> AlphaBlendFunction {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for AlphaBlendFunction {}
        #[automatically_derived]
        impl ::core::fmt::Debug for AlphaBlendFunction {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        AlphaBlendFunction::One => "One",
                        AlphaBlendFunction::Zero => "Zero",
                        AlphaBlendFunction::SrcColor => "SrcColor",
                        AlphaBlendFunction::InvSrcColor => "InvSrcColor",
                        AlphaBlendFunction::DstColor => "DstColor",
                        AlphaBlendFunction::InvDstColor => "InvDstColor",
                        AlphaBlendFunction::SrcAlpha => "SrcAlpha",
                        AlphaBlendFunction::InvSrcAlpha => "InvSrcAlpha",
                        AlphaBlendFunction::DstAlpha => "DstAlpha",
                        AlphaBlendFunction::InvDstAlpha => "InvDstAlpha",
                        AlphaBlendFunction::SrcAlphaSat => "SrcAlphaSat",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for AlphaBlendFunction {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        impl ::core::hash::Hash for AlphaBlendFunction {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_discr, state)
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for AlphaBlendFunction {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for AlphaBlendFunction {
            #[inline]
            fn eq(&self, other: &AlphaBlendFunction) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for AlphaBlendFunction {
            #[inline]
            fn default() -> AlphaBlendFunction {
                Self::One
            }
        }
        #[repr(u16)]
        pub enum AlphaTestFunction {
            #[default]
            Always = 0,
            Less = 1,
            Equal = 2,
            LessEqual = 3,
            Greater = 4,
            NotEqual = 5,
            GreaterEqual = 6,
            Never = 7,
        }
        const _: () = {
            use bytes_io::*;
            impl AsRepr for AlphaTestFunction {
                type Repr = u16;
            }
            impl TryFrom<u16> for AlphaTestFunction {
                type Error = ();
                fn try_from(value: u16) -> Result<Self, Self::Error> {
                    match value {
                        0 => Ok(Self::Always),
                        1 => Ok(Self::Less),
                        2 => Ok(Self::Equal),
                        3 => Ok(Self::LessEqual),
                        4 => Ok(Self::Greater),
                        5 => Ok(Self::NotEqual),
                        6 => Ok(Self::GreaterEqual),
                        7 => Ok(Self::Never),
                        _ => Err(()),
                    }
                }
            }
            impl Load for AlphaTestFunction {
                fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                    let value: u16 = stream.load()?;
                    Ok(value.try_into().unwrap_or_default())
                }
            }
            impl Save for AlphaTestFunction {
                fn save(&self, stream: &mut Writer) -> io::Result<()> {
                    stream.save(&(*self as u16))
                }
            }
            impl AlphaTestFunction {
                pub const fn display(&self) -> &'static str {
                    match self {
                        Self::Always => "Always",
                        Self::Less => "Less",
                        Self::Equal => "Equal",
                        Self::LessEqual => "LessEqual",
                        Self::Greater => "Greater",
                        Self::NotEqual => "NotEqual",
                        Self::GreaterEqual => "GreaterEqual",
                        Self::Never => "Never",
                    }
                }
            }
        };
        unsafe impl ::bytemuck::NoUninit for AlphaTestFunction {}
        #[automatically_derived]
        impl ::core::clone::Clone for AlphaTestFunction {
            #[inline]
            fn clone(&self) -> AlphaTestFunction {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for AlphaTestFunction {}
        #[automatically_derived]
        impl ::core::fmt::Debug for AlphaTestFunction {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        AlphaTestFunction::Always => "Always",
                        AlphaTestFunction::Less => "Less",
                        AlphaTestFunction::Equal => "Equal",
                        AlphaTestFunction::LessEqual => "LessEqual",
                        AlphaTestFunction::Greater => "Greater",
                        AlphaTestFunction::NotEqual => "NotEqual",
                        AlphaTestFunction::GreaterEqual => "GreaterEqual",
                        AlphaTestFunction::Never => "Never",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for AlphaTestFunction {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        impl ::core::hash::Hash for AlphaTestFunction {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_discr, state)
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for AlphaTestFunction {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for AlphaTestFunction {
            #[inline]
            fn eq(&self, other: &AlphaTestFunction) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for AlphaTestFunction {
            #[inline]
            fn default() -> AlphaTestFunction {
                Self::Always
            }
        }
        #[repr(u16)]
        pub enum PropagateMode {
            #[default]
            None = 0,
            UseTriangles = 1,
            UseOBBs = 2,
            Continue = 3,
        }
        const _: () = {
            use bytes_io::*;
            impl AsRepr for PropagateMode {
                type Repr = u16;
            }
            impl TryFrom<u16> for PropagateMode {
                type Error = ();
                fn try_from(value: u16) -> Result<Self, Self::Error> {
                    match value {
                        0 => Ok(Self::None),
                        1 => Ok(Self::UseTriangles),
                        2 => Ok(Self::UseOBBs),
                        3 => Ok(Self::Continue),
                        _ => Err(()),
                    }
                }
            }
            impl Load for PropagateMode {
                fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                    let value: u16 = stream.load()?;
                    Ok(value.try_into().unwrap_or_default())
                }
            }
            impl Save for PropagateMode {
                fn save(&self, stream: &mut Writer) -> io::Result<()> {
                    stream.save(&(*self as u16))
                }
            }
            impl PropagateMode {
                pub const fn display(&self) -> &'static str {
                    match self {
                        Self::None => "None",
                        Self::UseTriangles => "UseTriangles",
                        Self::UseOBBs => "UseOBBs",
                        Self::Continue => "Continue",
                    }
                }
            }
        };
        unsafe impl ::bytemuck::NoUninit for PropagateMode {}
        #[automatically_derived]
        impl ::core::clone::Clone for PropagateMode {
            #[inline]
            fn clone(&self) -> PropagateMode {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for PropagateMode {}
        #[automatically_derived]
        impl ::core::fmt::Debug for PropagateMode {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        PropagateMode::None => "None",
                        PropagateMode::UseTriangles => "UseTriangles",
                        PropagateMode::UseOBBs => "UseOBBs",
                        PropagateMode::Continue => "Continue",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for PropagateMode {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        impl ::core::hash::Hash for PropagateMode {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_discr, state)
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for PropagateMode {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for PropagateMode {
            #[inline]
            fn eq(&self, other: &PropagateMode) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for PropagateMode {
            #[inline]
            fn default() -> PropagateMode {
                Self::None
            }
        }
        #[repr(u16)]
        pub enum Axis {
            #[default]
            X = 0,
            Y = 1,
            Z = 2,
        }
        const _: () = {
            use bytes_io::*;
            impl AsRepr for Axis {
                type Repr = u16;
            }
            impl TryFrom<u16> for Axis {
                type Error = ();
                fn try_from(value: u16) -> Result<Self, Self::Error> {
                    match value {
                        0 => Ok(Self::X),
                        1 => Ok(Self::Y),
                        2 => Ok(Self::Z),
                        _ => Err(()),
                    }
                }
            }
            impl Load for Axis {
                fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                    let value: u16 = stream.load()?;
                    Ok(value.try_into().unwrap_or_default())
                }
            }
            impl Save for Axis {
                fn save(&self, stream: &mut Writer) -> io::Result<()> {
                    stream.save(&(*self as u16))
                }
            }
            impl Axis {
                pub const fn display(&self) -> &'static str {
                    match self {
                        Self::X => "X",
                        Self::Y => "Y",
                        Self::Z => "Z",
                    }
                }
            }
        };
        unsafe impl ::bytemuck::NoUninit for Axis {}
        #[automatically_derived]
        impl ::core::clone::Clone for Axis {
            #[inline]
            fn clone(&self) -> Axis {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for Axis {}
        #[automatically_derived]
        impl ::core::fmt::Debug for Axis {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        Axis::X => "X",
                        Axis::Y => "Y",
                        Axis::Z => "Z",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for Axis {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        impl ::core::hash::Hash for Axis {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_discr, state)
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Axis {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Axis {
            #[inline]
            fn eq(&self, other: &Axis) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for Axis {
            #[inline]
            fn default() -> Axis {
                Self::X
            }
        }
        #[repr(u16)]
        pub enum CycleType {
            #[default]
            Cycle = 0,
            Reverse = 1,
            Clamp = 2,
        }
        const _: () = {
            use bytes_io::*;
            impl AsRepr for CycleType {
                type Repr = u16;
            }
            impl TryFrom<u16> for CycleType {
                type Error = ();
                fn try_from(value: u16) -> Result<Self, Self::Error> {
                    match value {
                        0 => Ok(Self::Cycle),
                        1 => Ok(Self::Reverse),
                        2 => Ok(Self::Clamp),
                        _ => Err(()),
                    }
                }
            }
            impl Load for CycleType {
                fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                    let value: u16 = stream.load()?;
                    Ok(value.try_into().unwrap_or_default())
                }
            }
            impl Save for CycleType {
                fn save(&self, stream: &mut Writer) -> io::Result<()> {
                    stream.save(&(*self as u16))
                }
            }
            impl CycleType {
                pub const fn display(&self) -> &'static str {
                    match self {
                        Self::Cycle => "Cycle",
                        Self::Reverse => "Reverse",
                        Self::Clamp => "Clamp",
                    }
                }
            }
        };
        unsafe impl ::bytemuck::NoUninit for CycleType {}
        #[automatically_derived]
        impl ::core::clone::Clone for CycleType {
            #[inline]
            fn clone(&self) -> CycleType {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for CycleType {}
        #[automatically_derived]
        impl ::core::fmt::Debug for CycleType {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        CycleType::Cycle => "Cycle",
                        CycleType::Reverse => "Reverse",
                        CycleType::Clamp => "Clamp",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for CycleType {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        impl ::core::hash::Hash for CycleType {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_discr, state)
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for CycleType {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for CycleType {
            #[inline]
            fn eq(&self, other: &CycleType) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for CycleType {
            #[inline]
            fn default() -> CycleType {
                Self::Cycle
            }
        }
        #[repr(u16)]
        pub enum ZBufferTestFunction {
            #[default]
            Always = 0,
            Less = 1,
            Equal = 2,
            LessEqual = 3,
            Greater = 4,
            NotEqual = 5,
            GreaterEqual = 6,
            Never = 7,
        }
        const _: () = {
            use bytes_io::*;
            impl AsRepr for ZBufferTestFunction {
                type Repr = u16;
            }
            impl TryFrom<u16> for ZBufferTestFunction {
                type Error = ();
                fn try_from(value: u16) -> Result<Self, Self::Error> {
                    match value {
                        0 => Ok(Self::Always),
                        1 => Ok(Self::Less),
                        2 => Ok(Self::Equal),
                        3 => Ok(Self::LessEqual),
                        4 => Ok(Self::Greater),
                        5 => Ok(Self::NotEqual),
                        6 => Ok(Self::GreaterEqual),
                        7 => Ok(Self::Never),
                        _ => Err(()),
                    }
                }
            }
            impl Load for ZBufferTestFunction {
                fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                    let value: u16 = stream.load()?;
                    Ok(value.try_into().unwrap_or_default())
                }
            }
            impl Save for ZBufferTestFunction {
                fn save(&self, stream: &mut Writer) -> io::Result<()> {
                    stream.save(&(*self as u16))
                }
            }
            impl ZBufferTestFunction {
                pub const fn display(&self) -> &'static str {
                    match self {
                        Self::Always => "Always",
                        Self::Less => "Less",
                        Self::Equal => "Equal",
                        Self::LessEqual => "LessEqual",
                        Self::Greater => "Greater",
                        Self::NotEqual => "NotEqual",
                        Self::GreaterEqual => "GreaterEqual",
                        Self::Never => "Never",
                    }
                }
            }
        };
        unsafe impl ::bytemuck::NoUninit for ZBufferTestFunction {}
        #[automatically_derived]
        impl ::core::clone::Clone for ZBufferTestFunction {
            #[inline]
            fn clone(&self) -> ZBufferTestFunction {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for ZBufferTestFunction {}
        #[automatically_derived]
        impl ::core::fmt::Debug for ZBufferTestFunction {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        ZBufferTestFunction::Always => "Always",
                        ZBufferTestFunction::Less => "Less",
                        ZBufferTestFunction::Equal => "Equal",
                        ZBufferTestFunction::LessEqual => "LessEqual",
                        ZBufferTestFunction::Greater => "Greater",
                        ZBufferTestFunction::NotEqual => "NotEqual",
                        ZBufferTestFunction::GreaterEqual => "GreaterEqual",
                        ZBufferTestFunction::Never => "Never",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for ZBufferTestFunction {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        impl ::core::hash::Hash for ZBufferTestFunction {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_discr, state)
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for ZBufferTestFunction {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for ZBufferTestFunction {
            #[inline]
            fn eq(&self, other: &ZBufferTestFunction) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for ZBufferTestFunction {
            #[inline]
            fn default() -> ZBufferTestFunction {
                Self::Always
            }
        }
    }
    mod niaccumulator {
        use crate::prelude::*;
        pub struct NiAccumulator {
            pub base: NiObject,
        }
        impl NiAccumulator {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiAccumulator"
            }
        }
        impl Visitor for NiAccumulator {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiAccumulator {
            type Target = NiObject;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiAccumulator {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiAccumulator {
            #[inline]
            fn clone(&self) -> NiAccumulator {
                NiAccumulator {
                    base: ::core::clone::Clone::clone(&self.base),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiAccumulator {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "NiAccumulator",
                    "base",
                    &&self.base,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiAccumulator {
            #[inline]
            fn default() -> NiAccumulator {
                NiAccumulator {
                    base: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for NiAccumulator {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<NiObject>;
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiAccumulator {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiAccumulator {
            #[inline]
            fn eq(&self, other: &NiAccumulator) -> bool {
                self.base == other.base
            }
        }
        impl Load for NiAccumulator {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                Ok(Self { base })
            }
        }
        impl Save for NiAccumulator {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                Ok(())
            }
        }
    }
    mod nialphaaccumulator {
        use crate::prelude::*;
        pub struct NiAlphaAccumulator {
            pub base: NiClusterAccumulator,
        }
        impl NiAlphaAccumulator {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiAlphaAccumulator"
            }
        }
        impl Visitor for NiAlphaAccumulator {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiAlphaAccumulator {
            type Target = NiClusterAccumulator;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiAlphaAccumulator {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiAlphaAccumulator {
            #[inline]
            fn clone(&self) -> NiAlphaAccumulator {
                NiAlphaAccumulator {
                    base: ::core::clone::Clone::clone(&self.base),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiAlphaAccumulator {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "NiAlphaAccumulator",
                    "base",
                    &&self.base,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiAlphaAccumulator {
            #[inline]
            fn default() -> NiAlphaAccumulator {
                NiAlphaAccumulator {
                    base: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for NiAlphaAccumulator {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<NiClusterAccumulator>;
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiAlphaAccumulator {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiAlphaAccumulator {
            #[inline]
            fn eq(&self, other: &NiAlphaAccumulator) -> bool {
                self.base == other.base
            }
        }
        impl Load for NiAlphaAccumulator {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                Ok(Self { base })
            }
        }
        impl Save for NiAlphaAccumulator {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                Ok(())
            }
        }
    }
    mod nialphacontroller {
        use crate::prelude::*;
        pub struct NiAlphaController {
            pub base: NiFloatController,
        }
        impl NiAlphaController {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiAlphaController"
            }
        }
        impl Visitor for NiAlphaController {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiAlphaController {
            type Target = NiFloatController;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiAlphaController {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiAlphaController {
            #[inline]
            fn clone(&self) -> NiAlphaController {
                NiAlphaController {
                    base: ::core::clone::Clone::clone(&self.base),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiAlphaController {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "NiAlphaController",
                    "base",
                    &&self.base,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiAlphaController {
            #[inline]
            fn default() -> NiAlphaController {
                NiAlphaController {
                    base: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiAlphaController {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiAlphaController {
            #[inline]
            fn eq(&self, other: &NiAlphaController) -> bool {
                self.base == other.base
            }
        }
        impl Load for NiAlphaController {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                Ok(Self { base })
            }
        }
        impl Save for NiAlphaController {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                Ok(())
            }
        }
    }
    mod nialphaproperty {
        use crate::prelude::*;
        pub struct NiAlphaProperty {
            pub base: NiProperty,
            pub test_ref: u8,
        }
        impl NiAlphaProperty {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiAlphaProperty"
            }
        }
        impl Visitor for NiAlphaProperty {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.test_ref).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiAlphaProperty {
            type Target = NiProperty;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiAlphaProperty {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiAlphaProperty {
            #[inline]
            fn clone(&self) -> NiAlphaProperty {
                NiAlphaProperty {
                    base: ::core::clone::Clone::clone(&self.base),
                    test_ref: ::core::clone::Clone::clone(&self.test_ref),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiAlphaProperty {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "NiAlphaProperty",
                    "base",
                    &self.base,
                    "test_ref",
                    &&self.test_ref,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiAlphaProperty {
            #[inline]
            fn default() -> NiAlphaProperty {
                NiAlphaProperty {
                    base: ::core::default::Default::default(),
                    test_ref: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiAlphaProperty {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiAlphaProperty {
            #[inline]
            fn eq(&self, other: &NiAlphaProperty) -> bool {
                self.test_ref == other.test_ref && self.base == other.base
            }
        }
        impl Load for NiAlphaProperty {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let test_ref = stream.load()?;
                Ok(Self { base, test_ref })
            }
        }
        impl Save for NiAlphaProperty {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save(&self.test_ref)?;
                Ok(())
            }
        }
        impl NiAlphaProperty {
            #[inline]
            pub fn alpha_blending(&self) -> bool {
                self.flags & 0x0001 != 0
            }
            #[inline]
            pub fn set_alpha_blending(&mut self, value: bool) {
                if value {
                    self.flags |= 0x0001;
                } else {
                    self.flags &= !0x0001;
                }
            }
            #[inline]
            pub fn src_blend_mode(&self) -> AlphaBlendFunction {
                let value = (self.flags & 0x001E) >> 1;
                value.try_into().unwrap_or_default()
            }
            #[inline]
            pub fn set_src_blend_mode(&mut self, value: AlphaBlendFunction) {
                self.flags = (self.flags & !0x001E) | ((value as u16) << 1);
            }
            #[inline]
            pub fn dst_blend_mode(&self) -> AlphaBlendFunction {
                let value = (self.flags & 0x01E0) >> 5;
                value.try_into().unwrap_or_default()
            }
            #[inline]
            pub fn set_dst_blend_mode(&mut self, value: AlphaBlendFunction) {
                self.flags = (self.flags & !0x01E0) | ((value as u16) << 5);
            }
            #[inline]
            pub fn alpha_testing(&self) -> bool {
                self.flags & 0x0200 != 0
            }
            #[inline]
            pub fn set_alpha_testing(&mut self, value: bool) {
                if value {
                    self.flags |= 0x0200;
                } else {
                    self.flags &= !0x0200;
                }
            }
            #[inline]
            pub fn test_mode(&self) -> AlphaTestFunction {
                let value = (self.flags & 0x1C00) >> 10;
                value.try_into().unwrap_or_default()
            }
            #[inline]
            pub fn set_test_mode(&mut self, value: AlphaTestFunction) {
                self.flags = (self.flags & !0x1C00) | ((value as u16) << 10);
            }
        }
    }
    mod niambientlight {
        use crate::prelude::*;
        pub struct NiAmbientLight {
            pub base: NiLight,
        }
        impl NiAmbientLight {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiAmbientLight"
            }
        }
        impl Visitor for NiAmbientLight {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiAmbientLight {
            type Target = NiLight;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiAmbientLight {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiAmbientLight {
            #[inline]
            fn clone(&self) -> NiAmbientLight {
                NiAmbientLight {
                    base: ::core::clone::Clone::clone(&self.base),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiAmbientLight {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "NiAmbientLight",
                    "base",
                    &&self.base,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiAmbientLight {
            #[inline]
            fn default() -> NiAmbientLight {
                NiAmbientLight {
                    base: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiAmbientLight {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiAmbientLight {
            #[inline]
            fn eq(&self, other: &NiAmbientLight) -> bool {
                self.base == other.base
            }
        }
        impl Load for NiAmbientLight {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                Ok(Self { base })
            }
        }
        impl Save for NiAmbientLight {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                Ok(())
            }
        }
    }
    mod niautonormalparticles {
        use crate::prelude::*;
        pub struct NiAutoNormalParticles {
            pub base: NiParticles,
        }
        impl NiAutoNormalParticles {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiAutoNormalParticles"
            }
        }
        impl Visitor for NiAutoNormalParticles {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiAutoNormalParticles {
            type Target = NiParticles;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiAutoNormalParticles {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiAutoNormalParticles {
            #[inline]
            fn clone(&self) -> NiAutoNormalParticles {
                NiAutoNormalParticles {
                    base: ::core::clone::Clone::clone(&self.base),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiAutoNormalParticles {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "NiAutoNormalParticles",
                    "base",
                    &&self.base,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiAutoNormalParticles {
            #[inline]
            fn default() -> NiAutoNormalParticles {
                NiAutoNormalParticles {
                    base: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiAutoNormalParticles {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiAutoNormalParticles {
            #[inline]
            fn eq(&self, other: &NiAutoNormalParticles) -> bool {
                self.base == other.base
            }
        }
        impl Load for NiAutoNormalParticles {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                Ok(Self { base })
            }
        }
        impl Save for NiAutoNormalParticles {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                Ok(())
            }
        }
    }
    mod niautonormalparticlesdata {
        use crate::prelude::*;
        pub struct NiAutoNormalParticlesData {
            pub base: NiParticlesData,
        }
        impl NiAutoNormalParticlesData {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiAutoNormalParticlesData"
            }
        }
        impl Visitor for NiAutoNormalParticlesData {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiAutoNormalParticlesData {
            type Target = NiParticlesData;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiAutoNormalParticlesData {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiAutoNormalParticlesData {
            #[inline]
            fn clone(&self) -> NiAutoNormalParticlesData {
                NiAutoNormalParticlesData {
                    base: ::core::clone::Clone::clone(&self.base),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiAutoNormalParticlesData {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "NiAutoNormalParticlesData",
                    "base",
                    &&self.base,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiAutoNormalParticlesData {
            #[inline]
            fn default() -> NiAutoNormalParticlesData {
                NiAutoNormalParticlesData {
                    base: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiAutoNormalParticlesData {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiAutoNormalParticlesData {
            #[inline]
            fn eq(&self, other: &NiAutoNormalParticlesData) -> bool {
                self.base == other.base
            }
        }
        impl Load for NiAutoNormalParticlesData {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                Ok(Self { base })
            }
        }
        impl Save for NiAutoNormalParticlesData {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                Ok(())
            }
        }
    }
    mod niavobject {
        use crate::prelude::*;
        pub struct NiAVObject {
            pub base: NiObjectNET,
            pub flags: u16,
            pub translation: Vec3,
            #[default(Mat3::IDENTITY)]
            pub rotation: Mat3,
            #[default(1.0)]
            pub scale: f32,
            pub velocity: Vec3,
            pub properties: Vec<NiLink<NiProperty>>,
            pub bounding_volume: Option<NiBoundingVolume>,
        }
        impl NiAVObject {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiAVObject"
            }
        }
        impl Visitor for NiAVObject {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.bounding_volume).visitor(f);
                (&self.properties).visitor(f);
                (&self.velocity).visitor(f);
                (&self.scale).visitor(f);
                (&self.rotation).visitor(f);
                (&self.translation).visitor(f);
                (&self.flags).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiAVObject {
            type Target = NiObjectNET;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiAVObject {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiAVObject {
            #[inline]
            fn clone(&self) -> NiAVObject {
                NiAVObject {
                    base: ::core::clone::Clone::clone(&self.base),
                    flags: ::core::clone::Clone::clone(&self.flags),
                    translation: ::core::clone::Clone::clone(&self.translation),
                    rotation: ::core::clone::Clone::clone(&self.rotation),
                    scale: ::core::clone::Clone::clone(&self.scale),
                    velocity: ::core::clone::Clone::clone(&self.velocity),
                    properties: ::core::clone::Clone::clone(&self.properties),
                    bounding_volume: ::core::clone::Clone::clone(&self.bounding_volume),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiAVObject {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "base",
                    "flags",
                    "translation",
                    "rotation",
                    "scale",
                    "velocity",
                    "properties",
                    "bounding_volume",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.base,
                    &self.flags,
                    &self.translation,
                    &self.rotation,
                    &self.scale,
                    &self.velocity,
                    &self.properties,
                    &&self.bounding_volume,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "NiAVObject",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiAVObject {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiAVObject {
            #[inline]
            fn eq(&self, other: &NiAVObject) -> bool {
                self.flags == other.flags && self.scale == other.scale
                    && self.base == other.base && self.translation == other.translation
                    && self.rotation == other.rotation && self.velocity == other.velocity
                    && self.properties == other.properties
                    && self.bounding_volume == other.bounding_volume
            }
        }
        #[automatically_derived]
        impl Default for NiAVObject {
            /**Return `NiAVObject {
    base: Default::default(),
    flags: Default::default(),
    translation: Default::default(),
    rotation: Mat3::IDENTITY,
    scale: 1.0,
    velocity: Default::default(),
    properties: Default::default(),
    bounding_volume: Default::default()
}`*/
            fn default() -> Self {
                NiAVObject {
                    base: Default::default(),
                    flags: Default::default(),
                    translation: Default::default(),
                    rotation: Mat3::IDENTITY,
                    scale: 1.0,
                    velocity: Default::default(),
                    properties: Default::default(),
                    bounding_volume: Default::default(),
                }
            }
        }
        impl NiAVObject {
            pub fn transform(&self) -> Affine3A {
                Affine3A {
                    matrix3: (self.rotation * self.scale).transpose().into(),
                    translation: self.translation.into(),
                }
            }
            pub const fn clear_transform(&mut self) {
                self.translation = Vec3::ZERO;
                self.rotation = Mat3::IDENTITY;
                self.scale = 1.0;
            }
        }
        impl Load for NiAVObject {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let flags = stream.load()?;
                let translation = stream.load()?;
                let rotation = stream.load()?;
                let scale = stream.load()?;
                let velocity = stream.load()?;
                let properties = stream.load()?;
                let has_bounding_volume: u32 = stream.load()?;
                let bounding_volume = match has_bounding_volume {
                    0 => None,
                    _ => Some(stream.load()?),
                };
                Ok(Self {
                    base,
                    flags,
                    translation,
                    rotation,
                    scale,
                    velocity,
                    properties,
                    bounding_volume,
                })
            }
        }
        impl Save for NiAVObject {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save(&self.flags)?;
                stream.save(&self.translation)?;
                stream.save(&self.rotation)?;
                stream.save(&self.scale)?;
                stream.save(&self.velocity)?;
                stream.save(&self.properties)?;
                stream.save_as::<u32>(self.bounding_volume.is_some())?;
                if let Some(bounding_volume) = &self.bounding_volume {
                    stream.save(bounding_volume)?;
                }
                Ok(())
            }
        }
        impl NiAVObject {
            #[inline]
            pub fn app_culled(&self) -> bool {
                self.flags & 0x0001 != 0
            }
            #[inline]
            pub fn set_app_culled(&mut self, value: bool) {
                if value {
                    self.flags |= 0x0001;
                } else {
                    self.flags &= !0x0001;
                }
            }
            #[inline]
            pub fn propagate_mode(&self) -> PropagateMode {
                let value = (self.flags & 0x0006) >> 1;
                value.try_into().unwrap_or_default()
            }
            #[inline]
            pub fn set_propagate_mode(&mut self, value: PropagateMode) {
                self.flags = (self.flags & !0x0006) | ((value as u16) << 1);
            }
            #[inline]
            pub fn visual(&self) -> bool {
                self.flags & 0x0008 != 0
            }
            #[inline]
            pub fn set_visual(&mut self, value: bool) {
                if value {
                    self.flags |= 0x0008;
                } else {
                    self.flags &= !0x0008;
                }
            }
        }
    }
    mod nibillboardnode {
        use crate::prelude::*;
        pub struct NiBillboardNode {
            pub base: NiNode,
        }
        impl NiBillboardNode {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiBillboardNode"
            }
        }
        impl Visitor for NiBillboardNode {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiBillboardNode {
            type Target = NiNode;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiBillboardNode {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiBillboardNode {
            #[inline]
            fn clone(&self) -> NiBillboardNode {
                NiBillboardNode {
                    base: ::core::clone::Clone::clone(&self.base),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiBillboardNode {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "NiBillboardNode",
                    "base",
                    &&self.base,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiBillboardNode {
            #[inline]
            fn default() -> NiBillboardNode {
                NiBillboardNode {
                    base: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiBillboardNode {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiBillboardNode {
            #[inline]
            fn eq(&self, other: &NiBillboardNode) -> bool {
                self.base == other.base
            }
        }
        impl Load for NiBillboardNode {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                Ok(Self { base })
            }
        }
        impl Save for NiBillboardNode {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                Ok(())
            }
        }
    }
    mod nibltsource {
        use crate::prelude::*;
        pub struct NiBltSource {
            pub base: NiObject,
            #[default(TextureSource::Internal(NiLink::null()))]
            pub source: TextureSource,
        }
        impl NiBltSource {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiBltSource"
            }
        }
        impl Visitor for NiBltSource {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.source).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiBltSource {
            type Target = NiObject;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiBltSource {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiBltSource {
            #[inline]
            fn clone(&self) -> NiBltSource {
                NiBltSource {
                    base: ::core::clone::Clone::clone(&self.base),
                    source: ::core::clone::Clone::clone(&self.source),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiBltSource {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "NiBltSource",
                    "base",
                    &self.base,
                    "source",
                    &&self.source,
                )
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for NiBltSource {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<NiObject>;
                let _: ::core::cmp::AssertParamIsEq<TextureSource>;
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiBltSource {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiBltSource {
            #[inline]
            fn eq(&self, other: &NiBltSource) -> bool {
                self.base == other.base && self.source == other.source
            }
        }
        #[automatically_derived]
        impl Default for NiBltSource {
            /**Return `NiBltSource {
    base: Default::default(),
    source: TextureSource::Internal(NiLink::null())
}`*/
            fn default() -> Self {
                NiBltSource {
                    base: Default::default(),
                    source: TextureSource::Internal(NiLink::null()),
                }
            }
        }
        impl Load for NiBltSource {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let source = stream.load()?;
                Ok(Self { base, source })
            }
        }
        impl Save for NiBltSource {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save(&self.source)?;
                Ok(())
            }
        }
    }
    mod nibound {
        use crate::prelude::*;
        pub struct NiBound {
            pub center: Vec3,
            pub radius: f32,
        }
        impl NiBound {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiBound"
            }
        }
        impl Visitor for NiBound {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.radius).visitor(f);
                (&self.center).visitor(f);
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiBound {
            #[inline]
            fn clone(&self) -> NiBound {
                let _: ::core::clone::AssertParamIsClone<Vec3>;
                let _: ::core::clone::AssertParamIsClone<f32>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for NiBound {}
        #[automatically_derived]
        impl ::core::fmt::Debug for NiBound {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "NiBound",
                    "center",
                    &self.center,
                    "radius",
                    &&self.radius,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiBound {
            #[inline]
            fn default() -> NiBound {
                NiBound {
                    center: ::core::default::Default::default(),
                    radius: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiBound {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiBound {
            #[inline]
            fn eq(&self, other: &NiBound) -> bool {
                self.radius == other.radius && self.center == other.center
            }
        }
        impl Load for NiBound {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let center = stream.load()?;
                let radius = stream.load()?;
                Ok(Self { center, radius })
            }
        }
        impl Save for NiBound {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.center)?;
                stream.save(&self.radius)?;
                Ok(())
            }
        }
        impl NiBound {
            /// Merges this bounding sphere with another, creating a new bounding sphere that encloses both.
            ///
            #[must_use]
            pub fn merged_with(self, other: Self) -> Self {
                let (center, radius) = {
                    let c_diff = self.center - other.center;
                    let len_sq = c_diff.length_squared();
                    if len_sq < 1e-6 {
                        if other.radius > self.radius {
                            (other.center, other.radius)
                        } else {
                            (self.center, self.radius)
                        }
                    } else {
                        let r_diff = other.radius - self.radius;
                        if r_diff.abs().powi(2) >= len_sq {
                            if r_diff >= 0.0 {
                                (other.center, other.radius)
                            } else {
                                (self.center, self.radius)
                            }
                        } else {
                            let dist = len_sq.sqrt();
                            let alpha = (dist - r_diff) / (2.0 * dist);
                            let center = other.center + alpha * c_diff;
                            let radius = 0.5 * (other.radius + dist + self.radius);
                            (center, radius)
                        }
                    }
                };
                Self { center, radius }
            }
            /// Returns the bounding sphere transformed by the given transform.
            ///
            #[must_use]
            pub fn transformed_by(self, transform: &Affine3A) -> Self {
                let scale = transform.matrix3.z_axis.length();
                let center = transform.transform_point3(self.center);
                let radius = self.radius * scale;
                Self { center, radius }
            }
            /// Computes the bounding sphere of the given geometries.
            ///
            #[allow(private_bounds)]
            pub fn from_geometries(
                geometries: impl IntoIterator<Item: GeometryTransform>,
            ) -> Option<Self> {
                let mut merged: Option<NiBound> = None;
                for item in geometries {
                    let (data, transform) = item.get();
                    let bound = data.bound.transformed_by(transform);
                    merged = Some(
                        merged.map_or(bound, |inner| inner.merged_with(bound)),
                    );
                }
                merged
            }
            /// Computes the axis-aligned bounding box of the given geometries.
            ///
            #[allow(private_bounds)]
            pub fn aabb_from_geometries(
                geometries: impl IntoIterator<Item: GeometryTransform>,
            ) -> Option<(Vec3, Vec3)> {
                let mut min = Vec3::splat(f32::INFINITY);
                let mut max = Vec3::splat(f32::NEG_INFINITY);
                for item in geometries {
                    let (data, transform) = item.get();
                    for v_vec in &data.vertices {
                        let v_vec3 = Vec3::from_array(*v_vec);
                        let v = transform.transform_point3(v_vec3);
                        min = min.min(v);
                        max = max.max(v);
                    }
                }
                if min.is_finite() && max.is_finite() { Some((min, max)) } else { None }
            }
        }
        /// Blanket trait to allow passing in either slices or iterators.
        ///
        trait GeometryTransform {
            fn get(&self) -> (&NiGeometryData, &Affine3A);
        }
        impl<T> GeometryTransform for (T, Affine3A)
        where
            T: AsRef<NiGeometryData>,
        {
            #[inline]
            fn get(&self) -> (&NiGeometryData, &Affine3A) {
                (self.0.as_ref(), &self.1)
            }
        }
        impl<T> GeometryTransform for &(T, Affine3A)
        where
            T: AsRef<NiGeometryData>,
        {
            #[inline]
            fn get(&self) -> (&NiGeometryData, &Affine3A) {
                (self.0.as_ref(), &self.1)
            }
        }
    }
    mod niboundingvolume {
        use crate::prelude::*;
        pub struct NiBoundingVolume {
            pub bound_data: BoundData,
        }
        impl NiBoundingVolume {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiBoundingVolume"
            }
        }
        impl Visitor for NiBoundingVolume {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.bound_data).visitor(f);
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiBoundingVolume {
            #[inline]
            fn clone(&self) -> NiBoundingVolume {
                NiBoundingVolume {
                    bound_data: ::core::clone::Clone::clone(&self.bound_data),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiBoundingVolume {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "NiBoundingVolume",
                    "bound_data",
                    &&self.bound_data,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiBoundingVolume {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiBoundingVolume {
            #[inline]
            fn eq(&self, other: &NiBoundingVolume) -> bool {
                self.bound_data == other.bound_data
            }
        }
        #[automatically_derived]
        impl Default for NiBoundingVolume {
            /**Return `NiBoundingVolume {
    bound_data: Default::default()
}`*/
            fn default() -> Self {
                NiBoundingVolume {
                    bound_data: Default::default(),
                }
            }
        }
        pub enum BoundData {
            #[default]
            NiBoxBV(NiBoxBV),
            NiSphereBV(NiSphereBV),
            NiUnionBV(NiUnionBV),
        }
        impl BoundData {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"BoundData"
            }
        }
        impl Visitor for BoundData {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {}
        }
        #[automatically_derived]
        impl ::core::clone::Clone for BoundData {
            #[inline]
            fn clone(&self) -> BoundData {
                match self {
                    BoundData::NiBoxBV(__self_0) => {
                        BoundData::NiBoxBV(::core::clone::Clone::clone(__self_0))
                    }
                    BoundData::NiSphereBV(__self_0) => {
                        BoundData::NiSphereBV(::core::clone::Clone::clone(__self_0))
                    }
                    BoundData::NiUnionBV(__self_0) => {
                        BoundData::NiUnionBV(::core::clone::Clone::clone(__self_0))
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for BoundData {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    BoundData::NiBoxBV(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "NiBoxBV",
                            &__self_0,
                        )
                    }
                    BoundData::NiSphereBV(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "NiSphereBV",
                            &__self_0,
                        )
                    }
                    BoundData::NiUnionBV(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "NiUnionBV",
                            &__self_0,
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for BoundData {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for BoundData {
            #[inline]
            fn eq(&self, other: &BoundData) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
                    && match (self, other) {
                        (BoundData::NiBoxBV(__self_0), BoundData::NiBoxBV(__arg1_0)) => {
                            __self_0 == __arg1_0
                        }
                        (
                            BoundData::NiSphereBV(__self_0),
                            BoundData::NiSphereBV(__arg1_0),
                        ) => __self_0 == __arg1_0,
                        (
                            BoundData::NiUnionBV(__self_0),
                            BoundData::NiUnionBV(__arg1_0),
                        ) => __self_0 == __arg1_0,
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
            }
        }
        #[automatically_derived]
        impl Default for BoundData {
            ///Return `BoundData::NiBoxBV(Default::default())`
            fn default() -> Self {
                BoundData::NiBoxBV(Default::default())
            }
        }
        impl BoundData {
            const fn bound_type(&self) -> BoundType {
                match self {
                    BoundData::NiBoxBV(_) => BoundType::Box,
                    BoundData::NiSphereBV(_) => BoundType::Sphere,
                    BoundData::NiUnionBV(_) => BoundType::Union,
                }
            }
        }
        impl Load for NiBoundingVolume {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let bound_type = stream.load()?;
                let bound_data = match bound_type {
                    BoundType::Box => BoundData::NiBoxBV(stream.load()?),
                    BoundType::Sphere => BoundData::NiSphereBV(stream.load()?),
                    BoundType::Union => BoundData::NiUnionBV(stream.load()?),
                    _ => {
                        Reader::error(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("Invalid BoundType: {0:?}", bound_type),
                                )
                            }),
                        )?
                    }
                };
                Ok(Self { bound_data })
            }
        }
        impl Save for NiBoundingVolume {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.bound_data.bound_type())?;
                match &self.bound_data {
                    BoundData::NiBoxBV(data) => stream.save(data)?,
                    BoundData::NiSphereBV(data) => stream.save(data)?,
                    BoundData::NiUnionBV(data) => stream.save(data)?,
                }
                Ok(())
            }
        }
    }
    mod niboxbv {
        use crate::prelude::*;
        pub struct NiBoxBV {
            pub center: Vec3,
            #[default(Mat3::IDENTITY)]
            pub axis: Mat3,
            pub extents: Vec3,
        }
        impl NiBoxBV {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiBoxBV"
            }
        }
        impl Visitor for NiBoxBV {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.extents).visitor(f);
                (&self.axis).visitor(f);
                (&self.center).visitor(f);
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiBoxBV {
            #[inline]
            fn clone(&self) -> NiBoxBV {
                NiBoxBV {
                    center: ::core::clone::Clone::clone(&self.center),
                    axis: ::core::clone::Clone::clone(&self.axis),
                    extents: ::core::clone::Clone::clone(&self.extents),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiBoxBV {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "NiBoxBV",
                    "center",
                    &self.center,
                    "axis",
                    &self.axis,
                    "extents",
                    &&self.extents,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiBoxBV {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiBoxBV {
            #[inline]
            fn eq(&self, other: &NiBoxBV) -> bool {
                self.center == other.center && self.axis == other.axis
                    && self.extents == other.extents
            }
        }
        #[automatically_derived]
        impl Default for NiBoxBV {
            /**Return `NiBoxBV {
    center: Default::default(),
    axis: Mat3::IDENTITY,
    extents: Default::default()
}`*/
            fn default() -> Self {
                NiBoxBV {
                    center: Default::default(),
                    axis: Mat3::IDENTITY,
                    extents: Default::default(),
                }
            }
        }
        impl Load for NiBoxBV {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let center = stream.load()?;
                let axis = stream.load()?;
                let extents = stream.load()?;
                Ok(Self { center, axis, extents })
            }
        }
        impl Save for NiBoxBV {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.center)?;
                stream.save(&self.axis)?;
                stream.save(&self.extents)?;
                Ok(())
            }
        }
    }
    mod nibsanimationmanager {
        use crate::prelude::*;
        pub struct NiBSAnimationManager {
            pub base: NiNode,
        }
        impl NiBSAnimationManager {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiBSAnimationManager"
            }
        }
        impl Visitor for NiBSAnimationManager {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiBSAnimationManager {
            type Target = NiNode;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiBSAnimationManager {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiBSAnimationManager {
            #[inline]
            fn clone(&self) -> NiBSAnimationManager {
                NiBSAnimationManager {
                    base: ::core::clone::Clone::clone(&self.base),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiBSAnimationManager {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "NiBSAnimationManager",
                    "base",
                    &&self.base,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiBSAnimationManager {
            #[inline]
            fn default() -> NiBSAnimationManager {
                NiBSAnimationManager {
                    base: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiBSAnimationManager {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiBSAnimationManager {
            #[inline]
            fn eq(&self, other: &NiBSAnimationManager) -> bool {
                self.base == other.base
            }
        }
        impl Load for NiBSAnimationManager {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                Ok(Self { base })
            }
        }
        impl Save for NiBSAnimationManager {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                Ok(())
            }
        }
    }
    mod nibsanimationnode {
        use crate::prelude::*;
        pub struct NiBSAnimationNode {
            pub base: NiNode,
        }
        impl NiBSAnimationNode {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiBSAnimationNode"
            }
        }
        impl Visitor for NiBSAnimationNode {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiBSAnimationNode {
            type Target = NiNode;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiBSAnimationNode {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiBSAnimationNode {
            #[inline]
            fn clone(&self) -> NiBSAnimationNode {
                NiBSAnimationNode {
                    base: ::core::clone::Clone::clone(&self.base),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiBSAnimationNode {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "NiBSAnimationNode",
                    "base",
                    &&self.base,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiBSAnimationNode {
            #[inline]
            fn default() -> NiBSAnimationNode {
                NiBSAnimationNode {
                    base: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiBSAnimationNode {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiBSAnimationNode {
            #[inline]
            fn eq(&self, other: &NiBSAnimationNode) -> bool {
                self.base == other.base
            }
        }
        impl Load for NiBSAnimationNode {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                Ok(Self { base })
            }
        }
        impl Save for NiBSAnimationNode {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                Ok(())
            }
        }
        impl NiBSAnimationNode {
            #[inline]
            pub fn animated(&self) -> bool {
                self.flags & 0x0020 != 0
            }
            #[inline]
            pub fn set_animated(&mut self, value: bool) {
                if value {
                    self.flags |= 0x0020;
                } else {
                    self.flags &= !0x0020;
                }
            }
            #[inline]
            pub fn not_random(&self) -> bool {
                self.flags & 0x0040 != 0
            }
            #[inline]
            pub fn set_not_random(&mut self, value: bool) {
                if value {
                    self.flags |= 0x0040;
                } else {
                    self.flags &= !0x0040;
                }
            }
        }
    }
    mod nibsparraycontroller {
        use crate::prelude::*;
        pub struct NiBSPArrayController {
            pub base: NiParticleSystemController,
        }
        impl NiBSPArrayController {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiBSPArrayController"
            }
        }
        impl Visitor for NiBSPArrayController {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiBSPArrayController {
            type Target = NiParticleSystemController;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiBSPArrayController {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiBSPArrayController {
            #[inline]
            fn clone(&self) -> NiBSPArrayController {
                NiBSPArrayController {
                    base: ::core::clone::Clone::clone(&self.base),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiBSPArrayController {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "NiBSPArrayController",
                    "base",
                    &&self.base,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiBSPArrayController {
            #[inline]
            fn default() -> NiBSPArrayController {
                NiBSPArrayController {
                    base: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiBSPArrayController {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiBSPArrayController {
            #[inline]
            fn eq(&self, other: &NiBSPArrayController) -> bool {
                self.base == other.base
            }
        }
        impl Load for NiBSPArrayController {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                Ok(Self { base })
            }
        }
        impl Save for NiBSPArrayController {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                Ok(())
            }
        }
        impl NiBSPArrayController {
            #[inline]
            pub fn at_vertices(&self) -> bool {
                self.flags & 0x0010 != 0
            }
            #[inline]
            pub fn set_at_vertices(&mut self, value: bool) {
                if value {
                    self.flags |= 0x0010;
                } else {
                    self.flags &= !0x0010;
                }
            }
        }
    }
    mod nibsparticlenode {
        use crate::prelude::*;
        pub struct NiBSParticleNode {
            pub base: NiNode,
        }
        impl NiBSParticleNode {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiBSParticleNode"
            }
        }
        impl Visitor for NiBSParticleNode {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiBSParticleNode {
            type Target = NiNode;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiBSParticleNode {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiBSParticleNode {
            #[inline]
            fn clone(&self) -> NiBSParticleNode {
                NiBSParticleNode {
                    base: ::core::clone::Clone::clone(&self.base),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiBSParticleNode {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "NiBSParticleNode",
                    "base",
                    &&self.base,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiBSParticleNode {
            #[inline]
            fn default() -> NiBSParticleNode {
                NiBSParticleNode {
                    base: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiBSParticleNode {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiBSParticleNode {
            #[inline]
            fn eq(&self, other: &NiBSParticleNode) -> bool {
                self.base == other.base
            }
        }
        impl Load for NiBSParticleNode {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                Ok(Self { base })
            }
        }
        impl Save for NiBSParticleNode {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                Ok(())
            }
        }
        impl NiBSParticleNode {
            #[inline]
            pub fn follow(&self) -> bool {
                self.flags & 0x0080 != 0
            }
            #[inline]
            pub fn set_follow(&mut self, value: bool) {
                if value {
                    self.flags |= 0x0080;
                } else {
                    self.flags &= !0x0080;
                }
            }
        }
    }
    mod nibspnode {
        use crate::prelude::*;
        pub struct NiBSPNode {
            pub base: NiNode,
            pub plane: [f32; 4],
        }
        impl NiBSPNode {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiBSPNode"
            }
        }
        impl Visitor for NiBSPNode {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.plane).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiBSPNode {
            type Target = NiNode;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiBSPNode {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiBSPNode {
            #[inline]
            fn clone(&self) -> NiBSPNode {
                NiBSPNode {
                    base: ::core::clone::Clone::clone(&self.base),
                    plane: ::core::clone::Clone::clone(&self.plane),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiBSPNode {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "NiBSPNode",
                    "base",
                    &self.base,
                    "plane",
                    &&self.plane,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiBSPNode {
            #[inline]
            fn default() -> NiBSPNode {
                NiBSPNode {
                    base: ::core::default::Default::default(),
                    plane: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiBSPNode {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiBSPNode {
            #[inline]
            fn eq(&self, other: &NiBSPNode) -> bool {
                self.base == other.base && self.plane == other.plane
            }
        }
        impl Load for NiBSPNode {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let plane = stream.load()?;
                Ok(Self { base, plane })
            }
        }
        impl Save for NiBSPNode {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save(&self.plane)?;
                Ok(())
            }
        }
    }
    mod nicamera {
        use crate::prelude::*;
        pub struct NiCamera {
            pub base: NiAVObject,
            pub view_frustum: [f32; 6],
            pub view_port: [f32; 4],
            pub lod_adjust: f32,
            pub scene: NiLink<NiNode>,
            pub screen_polygons: Vec<NiLink<NiScreenPolygon>>,
        }
        impl NiCamera {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiCamera"
            }
        }
        impl Visitor for NiCamera {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.screen_polygons).visitor(f);
                (&self.scene).visitor(f);
                (&self.lod_adjust).visitor(f);
                (&self.view_port).visitor(f);
                (&self.view_frustum).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiCamera {
            type Target = NiAVObject;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiCamera {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiCamera {
            #[inline]
            fn clone(&self) -> NiCamera {
                NiCamera {
                    base: ::core::clone::Clone::clone(&self.base),
                    view_frustum: ::core::clone::Clone::clone(&self.view_frustum),
                    view_port: ::core::clone::Clone::clone(&self.view_port),
                    lod_adjust: ::core::clone::Clone::clone(&self.lod_adjust),
                    scene: ::core::clone::Clone::clone(&self.scene),
                    screen_polygons: ::core::clone::Clone::clone(&self.screen_polygons),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiCamera {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "base",
                    "view_frustum",
                    "view_port",
                    "lod_adjust",
                    "scene",
                    "screen_polygons",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.base,
                    &self.view_frustum,
                    &self.view_port,
                    &self.lod_adjust,
                    &self.scene,
                    &&self.screen_polygons,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "NiCamera",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiCamera {
            #[inline]
            fn default() -> NiCamera {
                NiCamera {
                    base: ::core::default::Default::default(),
                    view_frustum: ::core::default::Default::default(),
                    view_port: ::core::default::Default::default(),
                    lod_adjust: ::core::default::Default::default(),
                    scene: ::core::default::Default::default(),
                    screen_polygons: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiCamera {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiCamera {
            #[inline]
            fn eq(&self, other: &NiCamera) -> bool {
                self.lod_adjust == other.lod_adjust && self.base == other.base
                    && self.view_frustum == other.view_frustum
                    && self.view_port == other.view_port && self.scene == other.scene
                    && self.screen_polygons == other.screen_polygons
            }
        }
        impl Load for NiCamera {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let view_frustum = stream.load()?;
                let view_port = stream.load()?;
                let lod_adjust = stream.load()?;
                let scene = stream.load()?;
                let screen_polygons = stream.load()?;
                Ok(Self {
                    base,
                    view_frustum,
                    view_port,
                    lod_adjust,
                    scene,
                    screen_polygons,
                })
            }
        }
        impl Save for NiCamera {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save(&self.view_frustum)?;
                stream.save(&self.view_port)?;
                stream.save(&self.lod_adjust)?;
                stream.save(&self.scene)?;
                stream.save(&self.screen_polygons)?;
                Ok(())
            }
        }
    }
    mod niclusteraccumulator {
        use crate::prelude::*;
        pub struct NiClusterAccumulator {
            pub base: NiAccumulator,
        }
        impl NiClusterAccumulator {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiClusterAccumulator"
            }
        }
        impl Visitor for NiClusterAccumulator {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiClusterAccumulator {
            type Target = NiAccumulator;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiClusterAccumulator {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiClusterAccumulator {
            #[inline]
            fn clone(&self) -> NiClusterAccumulator {
                NiClusterAccumulator {
                    base: ::core::clone::Clone::clone(&self.base),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiClusterAccumulator {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "NiClusterAccumulator",
                    "base",
                    &&self.base,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiClusterAccumulator {
            #[inline]
            fn default() -> NiClusterAccumulator {
                NiClusterAccumulator {
                    base: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for NiClusterAccumulator {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<NiAccumulator>;
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiClusterAccumulator {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiClusterAccumulator {
            #[inline]
            fn eq(&self, other: &NiClusterAccumulator) -> bool {
                self.base == other.base
            }
        }
        impl Load for NiClusterAccumulator {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                Ok(Self { base })
            }
        }
        impl Save for NiClusterAccumulator {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                Ok(())
            }
        }
    }
    mod nicollisionswitch {
        use crate::prelude::*;
        pub struct NiCollisionSwitch {
            pub base: NiNode,
        }
        impl NiCollisionSwitch {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiCollisionSwitch"
            }
        }
        impl Visitor for NiCollisionSwitch {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiCollisionSwitch {
            type Target = NiNode;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiCollisionSwitch {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiCollisionSwitch {
            #[inline]
            fn clone(&self) -> NiCollisionSwitch {
                NiCollisionSwitch {
                    base: ::core::clone::Clone::clone(&self.base),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiCollisionSwitch {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "NiCollisionSwitch",
                    "base",
                    &&self.base,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiCollisionSwitch {
            #[inline]
            fn default() -> NiCollisionSwitch {
                NiCollisionSwitch {
                    base: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiCollisionSwitch {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiCollisionSwitch {
            #[inline]
            fn eq(&self, other: &NiCollisionSwitch) -> bool {
                self.base == other.base
            }
        }
        impl Load for NiCollisionSwitch {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                Ok(Self { base })
            }
        }
        impl Save for NiCollisionSwitch {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                Ok(())
            }
        }
        impl NiCollisionSwitch {
            #[inline]
            pub fn propagate(&self) -> bool {
                self.flags & 0x0020 != 0
            }
            #[inline]
            pub fn set_propagate(&mut self, value: bool) {
                if value {
                    self.flags |= 0x0020;
                } else {
                    self.flags &= !0x0020;
                }
            }
        }
    }
    mod nicolordata {
        use crate::prelude::*;
        pub struct NiColorData {
            pub base: NiObject,
            pub keys: NiColorKey,
        }
        impl NiColorData {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiColorData"
            }
        }
        impl Visitor for NiColorData {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.keys).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiColorData {
            type Target = NiObject;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiColorData {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiColorData {
            #[inline]
            fn clone(&self) -> NiColorData {
                NiColorData {
                    base: ::core::clone::Clone::clone(&self.base),
                    keys: ::core::clone::Clone::clone(&self.keys),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiColorData {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "NiColorData",
                    "base",
                    &self.base,
                    "keys",
                    &&self.keys,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiColorData {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiColorData {
            #[inline]
            fn eq(&self, other: &NiColorData) -> bool {
                self.base == other.base && self.keys == other.keys
            }
        }
        #[automatically_derived]
        impl Default for NiColorData {
            /**Return `NiColorData {
    base: Default::default(),
    keys: Default::default()
}`*/
            fn default() -> Self {
                NiColorData {
                    base: Default::default(),
                    keys: Default::default(),
                }
            }
        }
        impl Load for NiColorData {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let keys = stream.load()?;
                Ok(Self { base, keys })
            }
        }
        impl Save for NiColorData {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save(&self.keys)?;
                Ok(())
            }
        }
    }
    mod nicolorkey {
        use crate::prelude::*;
        pub enum NiColorKey {
            #[default]
            LinKey(Vec<NiLinColKey>),
        }
        impl NiColorKey {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiColorKey"
            }
        }
        impl Visitor for NiColorKey {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {}
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiColorKey {
            #[inline]
            fn clone(&self) -> NiColorKey {
                match self {
                    NiColorKey::LinKey(__self_0) => {
                        NiColorKey::LinKey(::core::clone::Clone::clone(__self_0))
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiColorKey {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    NiColorKey::LinKey(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "LinKey",
                            &__self_0,
                        )
                    }
                }
            }
        }
        #[allow(unreachable_code)]
        #[automatically_derived]
        impl derive_more::core::convert::From<(Vec<NiLinColKey>)> for NiColorKey {
            #[inline]
            fn from(value: (Vec<NiLinColKey>)) -> Self {
                NiColorKey::LinKey(value)
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiColorKey {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiColorKey {
            #[inline]
            fn eq(&self, other: &NiColorKey) -> bool {
                match (self, other) {
                    (NiColorKey::LinKey(__self_0), NiColorKey::LinKey(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                }
            }
        }
        #[automatically_derived]
        impl Default for NiColorKey {
            ///Return `NiColorKey::LinKey(Default::default())`
            fn default() -> Self {
                NiColorKey::LinKey(Default::default())
            }
        }
        pub struct NiLinColKey {
            pub time: f32,
            pub value: ColorA,
        }
        impl NiLinColKey {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiLinColKey"
            }
        }
        impl Visitor for NiLinColKey {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.value).visitor(f);
                (&self.time).visitor(f);
            }
        }
        const _: () = {
            use crate::prelude::*;
            impl Load for NiLinColKey {
                fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                    Ok(Self {
                        time: stream.load()?,
                        value: stream.load()?,
                    })
                }
            }
            impl Save for NiLinColKey {
                fn save(&self, stream: &mut Writer) -> io::Result<()> {
                    stream.save(&self.time)?;
                    stream.save(&self.value)?;
                    Ok(())
                }
            }
        };
        #[automatically_derived]
        impl ::core::clone::Clone for NiLinColKey {
            #[inline]
            fn clone(&self) -> NiLinColKey {
                let _: ::core::clone::AssertParamIsClone<f32>;
                let _: ::core::clone::AssertParamIsClone<ColorA>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for NiLinColKey {}
        #[automatically_derived]
        impl ::core::fmt::Debug for NiLinColKey {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "NiLinColKey",
                    "time",
                    &self.time,
                    "value",
                    &&self.value,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiLinColKey {
            #[inline]
            fn default() -> NiLinColKey {
                NiLinColKey {
                    time: ::core::default::Default::default(),
                    value: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiLinColKey {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiLinColKey {
            #[inline]
            fn eq(&self, other: &NiLinColKey) -> bool {
                self.time == other.time && self.value == other.value
            }
        }
        const _: fn() = || {
            #[allow(clippy::missing_const_for_fn)]
            #[doc(hidden)]
            fn check() {
                fn assert_impl<T: ::bytemuck::Zeroable>() {}
                assert_impl::<f32>();
            }
        };
        const _: fn() = || {
            #[allow(clippy::missing_const_for_fn)]
            #[doc(hidden)]
            fn check() {
                fn assert_impl<T: ::bytemuck::Zeroable>() {}
                assert_impl::<ColorA>();
            }
        };
        unsafe impl ::bytemuck::Zeroable for NiLinColKey {}
        impl Load for NiColorKey {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let num_keys: u32 = stream.load()?;
                let key_type = if num_keys == 0 {
                    KeyType::LinKey
                } else {
                    stream.load()?
                };
                Ok(
                    match key_type {
                        KeyType::LinKey => NiColorKey::LinKey(stream.load_seq(num_keys)?),
                        _ => {
                            Reader::error(
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!("Invalid KeyType: {0:?}", key_type),
                                    )
                                }),
                            )?
                        }
                    },
                )
            }
        }
        impl Save for NiColorKey {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                match self {
                    NiColorKey::LinKey(keys) => {
                        stream.save_as::<u32>(keys.len())?;
                        if !keys.is_empty() {
                            stream.save(&KeyType::LinKey)?;
                            stream.save_seq(keys)?;
                        }
                    }
                }
                Ok(())
            }
        }
    }
    mod nidirectionallight {
        use crate::prelude::*;
        pub struct NiDirectionalLight {
            pub base: NiLight,
        }
        impl NiDirectionalLight {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiDirectionalLight"
            }
        }
        impl Visitor for NiDirectionalLight {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiDirectionalLight {
            type Target = NiLight;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiDirectionalLight {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiDirectionalLight {
            #[inline]
            fn clone(&self) -> NiDirectionalLight {
                NiDirectionalLight {
                    base: ::core::clone::Clone::clone(&self.base),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiDirectionalLight {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "NiDirectionalLight",
                    "base",
                    &&self.base,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiDirectionalLight {
            #[inline]
            fn default() -> NiDirectionalLight {
                NiDirectionalLight {
                    base: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiDirectionalLight {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiDirectionalLight {
            #[inline]
            fn eq(&self, other: &NiDirectionalLight) -> bool {
                self.base == other.base
            }
        }
        impl Load for NiDirectionalLight {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                Ok(Self { base })
            }
        }
        impl Save for NiDirectionalLight {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                Ok(())
            }
        }
    }
    mod niditherproperty {
        use crate::prelude::*;
        pub struct NiDitherProperty {
            pub base: NiProperty,
        }
        impl NiDitherProperty {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiDitherProperty"
            }
        }
        impl Visitor for NiDitherProperty {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiDitherProperty {
            type Target = NiProperty;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiDitherProperty {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiDitherProperty {
            #[inline]
            fn clone(&self) -> NiDitherProperty {
                NiDitherProperty {
                    base: ::core::clone::Clone::clone(&self.base),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiDitherProperty {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "NiDitherProperty",
                    "base",
                    &&self.base,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiDitherProperty {
            #[inline]
            fn default() -> NiDitherProperty {
                NiDitherProperty {
                    base: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiDitherProperty {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiDitherProperty {
            #[inline]
            fn eq(&self, other: &NiDitherProperty) -> bool {
                self.base == other.base
            }
        }
        impl Load for NiDitherProperty {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                Ok(Self { base })
            }
        }
        impl Save for NiDitherProperty {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                Ok(())
            }
        }
    }
    mod nidx8renderer {
        use crate::prelude::*;
        pub struct NiDX8Renderer {
            pub base: NiRenderer,
        }
        impl NiDX8Renderer {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiDX8Renderer"
            }
        }
        impl Visitor for NiDX8Renderer {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiDX8Renderer {
            type Target = NiRenderer;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiDX8Renderer {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiDX8Renderer {
            #[inline]
            fn clone(&self) -> NiDX8Renderer {
                NiDX8Renderer {
                    base: ::core::clone::Clone::clone(&self.base),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiDX8Renderer {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "NiDX8Renderer",
                    "base",
                    &&self.base,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiDX8Renderer {
            #[inline]
            fn default() -> NiDX8Renderer {
                NiDX8Renderer {
                    base: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for NiDX8Renderer {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<NiRenderer>;
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiDX8Renderer {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiDX8Renderer {
            #[inline]
            fn eq(&self, other: &NiDX8Renderer) -> bool {
                self.base == other.base
            }
        }
        impl Load for NiDX8Renderer {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                Ok(Self { base })
            }
        }
        impl Save for NiDX8Renderer {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                Ok(())
            }
        }
    }
    mod nidynamiceffect {
        use crate::prelude::*;
        pub struct NiDynamicEffect {
            pub base: NiAVObject,
            pub affected_nodes: Vec<i32>,
        }
        impl NiDynamicEffect {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiDynamicEffect"
            }
        }
        impl Visitor for NiDynamicEffect {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.affected_nodes).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiDynamicEffect {
            type Target = NiAVObject;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiDynamicEffect {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiDynamicEffect {
            #[inline]
            fn clone(&self) -> NiDynamicEffect {
                NiDynamicEffect {
                    base: ::core::clone::Clone::clone(&self.base),
                    affected_nodes: ::core::clone::Clone::clone(&self.affected_nodes),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiDynamicEffect {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "NiDynamicEffect",
                    "base",
                    &self.base,
                    "affected_nodes",
                    &&self.affected_nodes,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiDynamicEffect {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiDynamicEffect {
            #[inline]
            fn eq(&self, other: &NiDynamicEffect) -> bool {
                self.base == other.base && self.affected_nodes == other.affected_nodes
            }
        }
        #[automatically_derived]
        impl Default for NiDynamicEffect {
            /**Return `NiDynamicEffect {
    base: Default::default(),
    affected_nodes: Default::default()
}`*/
            fn default() -> Self {
                NiDynamicEffect {
                    base: Default::default(),
                    affected_nodes: Default::default(),
                }
            }
        }
        impl Load for NiDynamicEffect {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let num_affected_nodes: u32 = stream.load()?;
                let affected_nodes = stream.load_vec(num_affected_nodes)?;
                Ok(Self { base, affected_nodes })
            }
        }
        impl Save for NiDynamicEffect {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save_as::<u32>(self.affected_nodes.len())?;
                stream.save_vec(&self.affected_nodes)?;
                Ok(())
            }
        }
    }
    mod niemittermodifier {
        use crate::prelude::*;
        pub struct NiEmitterModifier {
            pub base: NiObject,
        }
        impl NiEmitterModifier {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiEmitterModifier"
            }
        }
        impl Visitor for NiEmitterModifier {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiEmitterModifier {
            type Target = NiObject;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiEmitterModifier {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiEmitterModifier {
            #[inline]
            fn clone(&self) -> NiEmitterModifier {
                NiEmitterModifier {
                    base: ::core::clone::Clone::clone(&self.base),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiEmitterModifier {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "NiEmitterModifier",
                    "base",
                    &&self.base,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiEmitterModifier {
            #[inline]
            fn default() -> NiEmitterModifier {
                NiEmitterModifier {
                    base: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for NiEmitterModifier {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<NiObject>;
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiEmitterModifier {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiEmitterModifier {
            #[inline]
            fn eq(&self, other: &NiEmitterModifier) -> bool {
                self.base == other.base
            }
        }
        impl Load for NiEmitterModifier {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                Ok(Self { base })
            }
        }
        impl Save for NiEmitterModifier {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                Ok(())
            }
        }
    }
    mod niextradata {
        use crate::prelude::*;
        pub struct NiExtraData {
            pub base: NiObject,
            pub next: NiLink<NiExtraData>,
            pub bytes_remaining: u32,
        }
        impl NiExtraData {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiExtraData"
            }
        }
        impl Visitor for NiExtraData {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.bytes_remaining).visitor(f);
                (&self.next).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiExtraData {
            type Target = NiObject;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiExtraData {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiExtraData {
            #[inline]
            fn clone(&self) -> NiExtraData {
                NiExtraData {
                    base: ::core::clone::Clone::clone(&self.base),
                    next: ::core::clone::Clone::clone(&self.next),
                    bytes_remaining: ::core::clone::Clone::clone(&self.bytes_remaining),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiExtraData {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "NiExtraData",
                    "base",
                    &self.base,
                    "next",
                    &self.next,
                    "bytes_remaining",
                    &&self.bytes_remaining,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiExtraData {
            #[inline]
            fn default() -> NiExtraData {
                NiExtraData {
                    base: ::core::default::Default::default(),
                    next: ::core::default::Default::default(),
                    bytes_remaining: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiExtraData {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiExtraData {
            #[inline]
            fn eq(&self, other: &NiExtraData) -> bool {
                self.bytes_remaining == other.bytes_remaining && self.base == other.base
                    && self.next == other.next
            }
        }
        impl Load for NiExtraData {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let next = stream.load()?;
                let bytes_remaining = stream.load()?;
                Ok(Self {
                    base,
                    next,
                    bytes_remaining,
                })
            }
        }
        impl Save for NiExtraData {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save(&self.next)?;
                stream.save(&self.bytes_remaining)?;
                Ok(())
            }
        }
    }
    mod niflipcontroller {
        use crate::prelude::*;
        pub struct NiFlipController {
            pub base: NiTimeController,
            pub affected_map: u32,
            pub flip_start_time: f32,
            pub secs_per_frame: f32,
            pub textures: Vec<NiLink<NiSourceTexture>>,
        }
        impl NiFlipController {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiFlipController"
            }
        }
        impl Visitor for NiFlipController {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.textures).visitor(f);
                (&self.secs_per_frame).visitor(f);
                (&self.flip_start_time).visitor(f);
                (&self.affected_map).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiFlipController {
            type Target = NiTimeController;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiFlipController {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiFlipController {
            #[inline]
            fn clone(&self) -> NiFlipController {
                NiFlipController {
                    base: ::core::clone::Clone::clone(&self.base),
                    affected_map: ::core::clone::Clone::clone(&self.affected_map),
                    flip_start_time: ::core::clone::Clone::clone(&self.flip_start_time),
                    secs_per_frame: ::core::clone::Clone::clone(&self.secs_per_frame),
                    textures: ::core::clone::Clone::clone(&self.textures),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiFlipController {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field5_finish(
                    f,
                    "NiFlipController",
                    "base",
                    &self.base,
                    "affected_map",
                    &self.affected_map,
                    "flip_start_time",
                    &self.flip_start_time,
                    "secs_per_frame",
                    &self.secs_per_frame,
                    "textures",
                    &&self.textures,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiFlipController {
            #[inline]
            fn default() -> NiFlipController {
                NiFlipController {
                    base: ::core::default::Default::default(),
                    affected_map: ::core::default::Default::default(),
                    flip_start_time: ::core::default::Default::default(),
                    secs_per_frame: ::core::default::Default::default(),
                    textures: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiFlipController {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiFlipController {
            #[inline]
            fn eq(&self, other: &NiFlipController) -> bool {
                self.affected_map == other.affected_map
                    && self.flip_start_time == other.flip_start_time
                    && self.secs_per_frame == other.secs_per_frame
                    && self.base == other.base && self.textures == other.textures
            }
        }
        impl Load for NiFlipController {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let affected_map = stream.load()?;
                let flip_start_time = stream.load()?;
                let secs_per_frame = stream.load()?;
                let textures = stream.load()?;
                Ok(Self {
                    base,
                    affected_map,
                    flip_start_time,
                    secs_per_frame,
                    textures,
                })
            }
        }
        impl Save for NiFlipController {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save(&self.affected_map)?;
                stream.save(&self.flip_start_time)?;
                stream.save(&self.secs_per_frame)?;
                stream.save(&self.textures)?;
                Ok(())
            }
        }
    }
    mod nifloatcontroller {
        use crate::prelude::*;
        pub struct NiFloatController {
            pub base: NiTimeController,
            pub data: NiLink<NiFloatData>,
        }
        impl NiFloatController {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiFloatController"
            }
        }
        impl Visitor for NiFloatController {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.data).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiFloatController {
            type Target = NiTimeController;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiFloatController {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiFloatController {
            #[inline]
            fn clone(&self) -> NiFloatController {
                NiFloatController {
                    base: ::core::clone::Clone::clone(&self.base),
                    data: ::core::clone::Clone::clone(&self.data),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiFloatController {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "NiFloatController",
                    "base",
                    &self.base,
                    "data",
                    &&self.data,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiFloatController {
            #[inline]
            fn default() -> NiFloatController {
                NiFloatController {
                    base: ::core::default::Default::default(),
                    data: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiFloatController {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiFloatController {
            #[inline]
            fn eq(&self, other: &NiFloatController) -> bool {
                self.base == other.base && self.data == other.data
            }
        }
        impl Load for NiFloatController {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let data = stream.load()?;
                Ok(Self { base, data })
            }
        }
        impl Save for NiFloatController {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save(&self.data)?;
                Ok(())
            }
        }
    }
    mod nifloatdata {
        use crate::prelude::*;
        pub struct NiFloatData {
            pub base: NiObject,
            pub keys: NiFloatKey,
        }
        impl NiFloatData {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiFloatData"
            }
        }
        impl Visitor for NiFloatData {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.keys).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiFloatData {
            type Target = NiObject;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiFloatData {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiFloatData {
            #[inline]
            fn clone(&self) -> NiFloatData {
                NiFloatData {
                    base: ::core::clone::Clone::clone(&self.base),
                    keys: ::core::clone::Clone::clone(&self.keys),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiFloatData {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "NiFloatData",
                    "base",
                    &self.base,
                    "keys",
                    &&self.keys,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiFloatData {
            #[inline]
            fn default() -> NiFloatData {
                NiFloatData {
                    base: ::core::default::Default::default(),
                    keys: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiFloatData {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiFloatData {
            #[inline]
            fn eq(&self, other: &NiFloatData) -> bool {
                self.base == other.base && self.keys == other.keys
            }
        }
        impl Load for NiFloatData {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let keys = stream.load()?;
                Ok(Self { base, keys })
            }
        }
        impl Save for NiFloatData {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save(&self.keys)?;
                Ok(())
            }
        }
    }
    mod nifloatkey {
        use bytemuck::cast_slice;
        use crate::prelude::*;
        pub enum NiFloatKey {
            #[default]
            LinKey(Vec<NiLinFloatKey>),
            BezKey(Vec<NiBezFloatKey>),
            TCBKey(Vec<NiTCBFloatKey>),
        }
        impl NiFloatKey {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiFloatKey"
            }
        }
        impl Visitor for NiFloatKey {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {}
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiFloatKey {
            #[inline]
            fn clone(&self) -> NiFloatKey {
                match self {
                    NiFloatKey::LinKey(__self_0) => {
                        NiFloatKey::LinKey(::core::clone::Clone::clone(__self_0))
                    }
                    NiFloatKey::BezKey(__self_0) => {
                        NiFloatKey::BezKey(::core::clone::Clone::clone(__self_0))
                    }
                    NiFloatKey::TCBKey(__self_0) => {
                        NiFloatKey::TCBKey(::core::clone::Clone::clone(__self_0))
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiFloatKey {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    NiFloatKey::LinKey(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "LinKey",
                            &__self_0,
                        )
                    }
                    NiFloatKey::BezKey(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "BezKey",
                            &__self_0,
                        )
                    }
                    NiFloatKey::TCBKey(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "TCBKey",
                            &__self_0,
                        )
                    }
                }
            }
        }
        #[allow(unreachable_code)]
        #[automatically_derived]
        impl derive_more::core::convert::From<(Vec<NiLinFloatKey>)> for NiFloatKey {
            #[inline]
            fn from(value: (Vec<NiLinFloatKey>)) -> Self {
                NiFloatKey::LinKey(value)
            }
        }
        #[allow(unreachable_code)]
        #[automatically_derived]
        impl derive_more::core::convert::From<(Vec<NiBezFloatKey>)> for NiFloatKey {
            #[inline]
            fn from(value: (Vec<NiBezFloatKey>)) -> Self {
                NiFloatKey::BezKey(value)
            }
        }
        #[allow(unreachable_code)]
        #[automatically_derived]
        impl derive_more::core::convert::From<(Vec<NiTCBFloatKey>)> for NiFloatKey {
            #[inline]
            fn from(value: (Vec<NiTCBFloatKey>)) -> Self {
                NiFloatKey::TCBKey(value)
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiFloatKey {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiFloatKey {
            #[inline]
            fn eq(&self, other: &NiFloatKey) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
                    && match (self, other) {
                        (NiFloatKey::LinKey(__self_0), NiFloatKey::LinKey(__arg1_0)) => {
                            __self_0 == __arg1_0
                        }
                        (NiFloatKey::BezKey(__self_0), NiFloatKey::BezKey(__arg1_0)) => {
                            __self_0 == __arg1_0
                        }
                        (NiFloatKey::TCBKey(__self_0), NiFloatKey::TCBKey(__arg1_0)) => {
                            __self_0 == __arg1_0
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
            }
        }
        #[automatically_derived]
        impl Default for NiFloatKey {
            ///Return `NiFloatKey::LinKey(Default::default())`
            fn default() -> Self {
                NiFloatKey::LinKey(Default::default())
            }
        }
        #[repr(C)]
        pub struct NiLinFloatKey {
            pub time: f32,
            pub value: f32,
        }
        impl NiLinFloatKey {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiLinFloatKey"
            }
        }
        impl Visitor for NiLinFloatKey {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.value).visitor(f);
                (&self.time).visitor(f);
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiLinFloatKey {
            #[inline]
            fn clone(&self) -> NiLinFloatKey {
                let _: ::core::clone::AssertParamIsClone<f32>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for NiLinFloatKey {}
        #[automatically_derived]
        impl ::core::fmt::Debug for NiLinFloatKey {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "NiLinFloatKey",
                    "time",
                    &self.time,
                    "value",
                    &&self.value,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiLinFloatKey {
            #[inline]
            fn default() -> NiLinFloatKey {
                NiLinFloatKey {
                    time: ::core::default::Default::default(),
                    value: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiLinFloatKey {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiLinFloatKey {
            #[inline]
            fn eq(&self, other: &NiLinFloatKey) -> bool {
                self.time == other.time && self.value == other.value
            }
        }
        const _: () = {
            if !(::core::mem::size_of::<NiLinFloatKey>()
                == (::core::mem::size_of::<f32>() + ::core::mem::size_of::<f32>()))
            {
                {
                    ::std::rt::begin_panic(
                        "derive(Pod) was applied to a type with padding",
                    );
                }
            }
        };
        const _: fn() = || {
            #[allow(clippy::missing_const_for_fn)]
            #[doc(hidden)]
            fn check() {
                fn assert_impl<T: ::bytemuck::Pod>() {}
                assert_impl::<f32>();
            }
        };
        const _: fn() = || {
            #[allow(clippy::missing_const_for_fn)]
            #[doc(hidden)]
            fn check() {
                fn assert_impl<T: ::bytemuck::Pod>() {}
                assert_impl::<f32>();
            }
        };
        unsafe impl ::bytemuck::Pod for NiLinFloatKey {}
        const _: fn() = || {
            #[allow(clippy::missing_const_for_fn)]
            #[doc(hidden)]
            fn check() {
                fn assert_impl<T: ::bytemuck::Zeroable>() {}
                assert_impl::<f32>();
            }
        };
        const _: fn() = || {
            #[allow(clippy::missing_const_for_fn)]
            #[doc(hidden)]
            fn check() {
                fn assert_impl<T: ::bytemuck::Zeroable>() {}
                assert_impl::<f32>();
            }
        };
        unsafe impl ::bytemuck::Zeroable for NiLinFloatKey {}
        #[repr(C)]
        pub struct NiBezFloatKey {
            pub time: f32,
            pub value: f32,
            pub in_tan: f32,
            pub out_tan: f32,
        }
        impl NiBezFloatKey {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiBezFloatKey"
            }
        }
        impl Visitor for NiBezFloatKey {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.out_tan).visitor(f);
                (&self.in_tan).visitor(f);
                (&self.value).visitor(f);
                (&self.time).visitor(f);
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiBezFloatKey {
            #[inline]
            fn clone(&self) -> NiBezFloatKey {
                let _: ::core::clone::AssertParamIsClone<f32>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for NiBezFloatKey {}
        #[automatically_derived]
        impl ::core::fmt::Debug for NiBezFloatKey {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "NiBezFloatKey",
                    "time",
                    &self.time,
                    "value",
                    &self.value,
                    "in_tan",
                    &self.in_tan,
                    "out_tan",
                    &&self.out_tan,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiBezFloatKey {
            #[inline]
            fn default() -> NiBezFloatKey {
                NiBezFloatKey {
                    time: ::core::default::Default::default(),
                    value: ::core::default::Default::default(),
                    in_tan: ::core::default::Default::default(),
                    out_tan: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiBezFloatKey {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiBezFloatKey {
            #[inline]
            fn eq(&self, other: &NiBezFloatKey) -> bool {
                self.time == other.time && self.value == other.value
                    && self.in_tan == other.in_tan && self.out_tan == other.out_tan
            }
        }
        const _: () = {
            if !(::core::mem::size_of::<NiBezFloatKey>()
                == (::core::mem::size_of::<f32>() + ::core::mem::size_of::<f32>()
                    + ::core::mem::size_of::<f32>() + ::core::mem::size_of::<f32>()))
            {
                {
                    ::std::rt::begin_panic(
                        "derive(Pod) was applied to a type with padding",
                    );
                }
            }
        };
        const _: fn() = || {
            #[allow(clippy::missing_const_for_fn)]
            #[doc(hidden)]
            fn check() {
                fn assert_impl<T: ::bytemuck::Pod>() {}
                assert_impl::<f32>();
            }
        };
        const _: fn() = || {
            #[allow(clippy::missing_const_for_fn)]
            #[doc(hidden)]
            fn check() {
                fn assert_impl<T: ::bytemuck::Pod>() {}
                assert_impl::<f32>();
            }
        };
        const _: fn() = || {
            #[allow(clippy::missing_const_for_fn)]
            #[doc(hidden)]
            fn check() {
                fn assert_impl<T: ::bytemuck::Pod>() {}
                assert_impl::<f32>();
            }
        };
        const _: fn() = || {
            #[allow(clippy::missing_const_for_fn)]
            #[doc(hidden)]
            fn check() {
                fn assert_impl<T: ::bytemuck::Pod>() {}
                assert_impl::<f32>();
            }
        };
        unsafe impl ::bytemuck::Pod for NiBezFloatKey {}
        const _: fn() = || {
            #[allow(clippy::missing_const_for_fn)]
            #[doc(hidden)]
            fn check() {
                fn assert_impl<T: ::bytemuck::Zeroable>() {}
                assert_impl::<f32>();
            }
        };
        const _: fn() = || {
            #[allow(clippy::missing_const_for_fn)]
            #[doc(hidden)]
            fn check() {
                fn assert_impl<T: ::bytemuck::Zeroable>() {}
                assert_impl::<f32>();
            }
        };
        const _: fn() = || {
            #[allow(clippy::missing_const_for_fn)]
            #[doc(hidden)]
            fn check() {
                fn assert_impl<T: ::bytemuck::Zeroable>() {}
                assert_impl::<f32>();
            }
        };
        const _: fn() = || {
            #[allow(clippy::missing_const_for_fn)]
            #[doc(hidden)]
            fn check() {
                fn assert_impl<T: ::bytemuck::Zeroable>() {}
                assert_impl::<f32>();
            }
        };
        unsafe impl ::bytemuck::Zeroable for NiBezFloatKey {}
        #[repr(C)]
        pub struct NiTCBFloatKey {
            pub time: f32,
            pub value: f32,
            pub tension: f32,
            pub continuity: f32,
            pub bias: f32,
        }
        impl NiTCBFloatKey {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiTCBFloatKey"
            }
        }
        impl Visitor for NiTCBFloatKey {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.bias).visitor(f);
                (&self.continuity).visitor(f);
                (&self.tension).visitor(f);
                (&self.value).visitor(f);
                (&self.time).visitor(f);
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiTCBFloatKey {
            #[inline]
            fn clone(&self) -> NiTCBFloatKey {
                let _: ::core::clone::AssertParamIsClone<f32>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for NiTCBFloatKey {}
        #[automatically_derived]
        impl ::core::fmt::Debug for NiTCBFloatKey {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field5_finish(
                    f,
                    "NiTCBFloatKey",
                    "time",
                    &self.time,
                    "value",
                    &self.value,
                    "tension",
                    &self.tension,
                    "continuity",
                    &self.continuity,
                    "bias",
                    &&self.bias,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiTCBFloatKey {
            #[inline]
            fn default() -> NiTCBFloatKey {
                NiTCBFloatKey {
                    time: ::core::default::Default::default(),
                    value: ::core::default::Default::default(),
                    tension: ::core::default::Default::default(),
                    continuity: ::core::default::Default::default(),
                    bias: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiTCBFloatKey {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiTCBFloatKey {
            #[inline]
            fn eq(&self, other: &NiTCBFloatKey) -> bool {
                self.time == other.time && self.value == other.value
                    && self.tension == other.tension
                    && self.continuity == other.continuity && self.bias == other.bias
            }
        }
        const _: () = {
            if !(::core::mem::size_of::<NiTCBFloatKey>()
                == (::core::mem::size_of::<f32>() + ::core::mem::size_of::<f32>()
                    + ::core::mem::size_of::<f32>() + ::core::mem::size_of::<f32>()
                    + ::core::mem::size_of::<f32>()))
            {
                {
                    ::std::rt::begin_panic(
                        "derive(Pod) was applied to a type with padding",
                    );
                }
            }
        };
        const _: fn() = || {
            #[allow(clippy::missing_const_for_fn)]
            #[doc(hidden)]
            fn check() {
                fn assert_impl<T: ::bytemuck::Pod>() {}
                assert_impl::<f32>();
            }
        };
        const _: fn() = || {
            #[allow(clippy::missing_const_for_fn)]
            #[doc(hidden)]
            fn check() {
                fn assert_impl<T: ::bytemuck::Pod>() {}
                assert_impl::<f32>();
            }
        };
        const _: fn() = || {
            #[allow(clippy::missing_const_for_fn)]
            #[doc(hidden)]
            fn check() {
                fn assert_impl<T: ::bytemuck::Pod>() {}
                assert_impl::<f32>();
            }
        };
        const _: fn() = || {
            #[allow(clippy::missing_const_for_fn)]
            #[doc(hidden)]
            fn check() {
                fn assert_impl<T: ::bytemuck::Pod>() {}
                assert_impl::<f32>();
            }
        };
        const _: fn() = || {
            #[allow(clippy::missing_const_for_fn)]
            #[doc(hidden)]
            fn check() {
                fn assert_impl<T: ::bytemuck::Pod>() {}
                assert_impl::<f32>();
            }
        };
        unsafe impl ::bytemuck::Pod for NiTCBFloatKey {}
        const _: fn() = || {
            #[allow(clippy::missing_const_for_fn)]
            #[doc(hidden)]
            fn check() {
                fn assert_impl<T: ::bytemuck::Zeroable>() {}
                assert_impl::<f32>();
            }
        };
        const _: fn() = || {
            #[allow(clippy::missing_const_for_fn)]
            #[doc(hidden)]
            fn check() {
                fn assert_impl<T: ::bytemuck::Zeroable>() {}
                assert_impl::<f32>();
            }
        };
        const _: fn() = || {
            #[allow(clippy::missing_const_for_fn)]
            #[doc(hidden)]
            fn check() {
                fn assert_impl<T: ::bytemuck::Zeroable>() {}
                assert_impl::<f32>();
            }
        };
        const _: fn() = || {
            #[allow(clippy::missing_const_for_fn)]
            #[doc(hidden)]
            fn check() {
                fn assert_impl<T: ::bytemuck::Zeroable>() {}
                assert_impl::<f32>();
            }
        };
        const _: fn() = || {
            #[allow(clippy::missing_const_for_fn)]
            #[doc(hidden)]
            fn check() {
                fn assert_impl<T: ::bytemuck::Zeroable>() {}
                assert_impl::<f32>();
            }
        };
        unsafe impl ::bytemuck::Zeroable for NiTCBFloatKey {}
        impl Load for NiFloatKey {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let num_keys: u32 = stream.load()?;
                let key_type = if num_keys == 0 {
                    KeyType::LinKey
                } else {
                    stream.load()?
                };
                Ok(
                    match key_type {
                        KeyType::LinKey => NiFloatKey::LinKey(stream.load_vec(num_keys)?),
                        KeyType::BezKey => NiFloatKey::BezKey(stream.load_vec(num_keys)?),
                        KeyType::TCBKey => NiFloatKey::TCBKey(stream.load_vec(num_keys)?),
                        _ => {
                            Reader::error(
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!("Invalid KeyType: {0:?}", key_type),
                                    )
                                }),
                            )?
                        }
                    },
                )
            }
        }
        impl Save for NiFloatKey {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                let (len, key_type, bytes) = match self {
                    NiFloatKey::LinKey(keys) => {
                        (keys.len(), KeyType::LinKey, cast_slice(keys))
                    }
                    NiFloatKey::BezKey(keys) => {
                        (keys.len(), KeyType::BezKey, cast_slice(keys))
                    }
                    NiFloatKey::TCBKey(keys) => {
                        (keys.len(), KeyType::TCBKey, cast_slice(keys))
                    }
                };
                stream.save_as::<u32>(len)?;
                if !bytes.is_empty() {
                    stream.save(&key_type)?;
                    stream.save_bytes(bytes)?;
                }
                Ok(())
            }
        }
    }
    mod nifltanimationnode {
        use crate::prelude::*;
        pub struct NiFltAnimationNode {
            pub base: NiSwitchNode,
            pub period: f32,
        }
        impl NiFltAnimationNode {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiFltAnimationNode"
            }
        }
        impl Visitor for NiFltAnimationNode {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.period).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiFltAnimationNode {
            type Target = NiSwitchNode;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiFltAnimationNode {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiFltAnimationNode {
            #[inline]
            fn clone(&self) -> NiFltAnimationNode {
                NiFltAnimationNode {
                    base: ::core::clone::Clone::clone(&self.base),
                    period: ::core::clone::Clone::clone(&self.period),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiFltAnimationNode {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "NiFltAnimationNode",
                    "base",
                    &self.base,
                    "period",
                    &&self.period,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiFltAnimationNode {
            #[inline]
            fn default() -> NiFltAnimationNode {
                NiFltAnimationNode {
                    base: ::core::default::Default::default(),
                    period: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiFltAnimationNode {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiFltAnimationNode {
            #[inline]
            fn eq(&self, other: &NiFltAnimationNode) -> bool {
                self.period == other.period && self.base == other.base
            }
        }
        impl Load for NiFltAnimationNode {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let period = stream.load()?;
                Ok(Self { base, period })
            }
        }
        impl Save for NiFltAnimationNode {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save(&self.period)?;
                Ok(())
            }
        }
        impl NiFltAnimationNode {
            #[inline]
            pub fn bounce(&self) -> bool {
                self.flags & 0x0040 != 0
            }
            #[inline]
            pub fn set_bounce(&mut self, value: bool) {
                if value {
                    self.flags |= 0x0040;
                } else {
                    self.flags &= !0x0040;
                }
            }
        }
    }
    mod nifogproperty {
        use crate::prelude::*;
        pub struct NiFogProperty {
            pub base: NiProperty,
            pub fog_depth: f32,
            pub fog_color: Vec3,
        }
        impl NiFogProperty {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiFogProperty"
            }
        }
        impl Visitor for NiFogProperty {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.fog_color).visitor(f);
                (&self.fog_depth).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiFogProperty {
            type Target = NiProperty;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiFogProperty {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiFogProperty {
            #[inline]
            fn clone(&self) -> NiFogProperty {
                NiFogProperty {
                    base: ::core::clone::Clone::clone(&self.base),
                    fog_depth: ::core::clone::Clone::clone(&self.fog_depth),
                    fog_color: ::core::clone::Clone::clone(&self.fog_color),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiFogProperty {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "NiFogProperty",
                    "base",
                    &self.base,
                    "fog_depth",
                    &self.fog_depth,
                    "fog_color",
                    &&self.fog_color,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiFogProperty {
            #[inline]
            fn default() -> NiFogProperty {
                NiFogProperty {
                    base: ::core::default::Default::default(),
                    fog_depth: ::core::default::Default::default(),
                    fog_color: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiFogProperty {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiFogProperty {
            #[inline]
            fn eq(&self, other: &NiFogProperty) -> bool {
                self.fog_depth == other.fog_depth && self.base == other.base
                    && self.fog_color == other.fog_color
            }
        }
        impl Load for NiFogProperty {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let fog_depth = stream.load()?;
                let fog_color = stream.load()?;
                Ok(Self { base, fog_depth, fog_color })
            }
        }
        impl Save for NiFogProperty {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save(&self.fog_depth)?;
                stream.save(&self.fog_color)?;
                Ok(())
            }
        }
    }
    mod nigeometry {
        use crate::prelude::*;
        pub struct NiGeometry {
            pub base: NiAVObject,
            pub geometry_data: NiLink<NiGeometryData>,
            pub skin_instance: NiLink<NiSkinInstance>,
        }
        impl NiGeometry {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiGeometry"
            }
        }
        impl Visitor for NiGeometry {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.skin_instance).visitor(f);
                (&self.geometry_data).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiGeometry {
            type Target = NiAVObject;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiGeometry {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiGeometry {
            #[inline]
            fn clone(&self) -> NiGeometry {
                NiGeometry {
                    base: ::core::clone::Clone::clone(&self.base),
                    geometry_data: ::core::clone::Clone::clone(&self.geometry_data),
                    skin_instance: ::core::clone::Clone::clone(&self.skin_instance),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiGeometry {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "NiGeometry",
                    "base",
                    &self.base,
                    "geometry_data",
                    &self.geometry_data,
                    "skin_instance",
                    &&self.skin_instance,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiGeometry {
            #[inline]
            fn default() -> NiGeometry {
                NiGeometry {
                    base: ::core::default::Default::default(),
                    geometry_data: ::core::default::Default::default(),
                    skin_instance: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiGeometry {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiGeometry {
            #[inline]
            fn eq(&self, other: &NiGeometry) -> bool {
                self.base == other.base && self.geometry_data == other.geometry_data
                    && self.skin_instance == other.skin_instance
            }
        }
        impl Load for NiGeometry {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let geometry_data = stream.load()?;
                let skin_instance = stream.load()?;
                Ok(Self {
                    base,
                    geometry_data,
                    skin_instance,
                })
            }
        }
        impl Save for NiGeometry {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save(&self.geometry_data)?;
                stream.save(&self.skin_instance)?;
                Ok(())
            }
        }
        impl NiGeometry {
            #[inline]
            pub fn compress_vertices(&self) -> bool {
                self.flags & 0x0008 != 0
            }
            #[inline]
            pub fn set_compress_vertices(&mut self, value: bool) {
                if value {
                    self.flags |= 0x0008;
                } else {
                    self.flags &= !0x0008;
                }
            }
            #[inline]
            pub fn compress_normals(&self) -> bool {
                self.flags & 0x0010 != 0
            }
            #[inline]
            pub fn set_compress_normals(&mut self, value: bool) {
                if value {
                    self.flags |= 0x0010;
                } else {
                    self.flags &= !0x0010;
                }
            }
            #[inline]
            pub fn compress_uv_sets(&self) -> bool {
                self.flags & 0x0020 != 0
            }
            #[inline]
            pub fn set_compress_uv_sets(&mut self, value: bool) {
                if value {
                    self.flags |= 0x0020;
                } else {
                    self.flags &= !0x0020;
                }
            }
            #[inline]
            pub fn shadow(&self) -> bool {
                self.flags & 0x0040 != 0
            }
            #[inline]
            pub fn set_shadow(&mut self, value: bool) {
                if value {
                    self.flags |= 0x0040;
                } else {
                    self.flags &= !0x0040;
                }
            }
        }
    }
    mod nigeometrydata {
        use crate::prelude::*;
        pub struct NiGeometryData {
            pub base: NiObject,
            pub vertices: Vec<[f32; 3]>,
            pub normals: Vec<[f32; 3]>,
            pub bound: NiBound,
            pub vertex_colors: Vec<ColorA>,
            pub uv_sets: Vec<[f32; 2]>,
        }
        impl NiGeometryData {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiGeometryData"
            }
        }
        impl Visitor for NiGeometryData {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.uv_sets).visitor(f);
                (&self.vertex_colors).visitor(f);
                (&self.bound).visitor(f);
                (&self.normals).visitor(f);
                (&self.vertices).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiGeometryData {
            type Target = NiObject;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiGeometryData {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiGeometryData {
            #[inline]
            fn clone(&self) -> NiGeometryData {
                NiGeometryData {
                    base: ::core::clone::Clone::clone(&self.base),
                    vertices: ::core::clone::Clone::clone(&self.vertices),
                    normals: ::core::clone::Clone::clone(&self.normals),
                    bound: ::core::clone::Clone::clone(&self.bound),
                    vertex_colors: ::core::clone::Clone::clone(&self.vertex_colors),
                    uv_sets: ::core::clone::Clone::clone(&self.uv_sets),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiGeometryData {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "base",
                    "vertices",
                    "normals",
                    "bound",
                    "vertex_colors",
                    "uv_sets",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.base,
                    &self.vertices,
                    &self.normals,
                    &self.bound,
                    &self.vertex_colors,
                    &&self.uv_sets,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "NiGeometryData",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiGeometryData {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiGeometryData {
            #[inline]
            fn eq(&self, other: &NiGeometryData) -> bool {
                self.base == other.base && self.vertices == other.vertices
                    && self.normals == other.normals && self.bound == other.bound
                    && self.vertex_colors == other.vertex_colors
                    && self.uv_sets == other.uv_sets
            }
        }
        #[automatically_derived]
        impl Default for NiGeometryData {
            /**Return `NiGeometryData {
    base: Default::default(),
    vertices: Default::default(),
    normals: Default::default(),
    bound: Default::default(),
    vertex_colors: Default::default(),
    uv_sets: Default::default()
}`*/
            fn default() -> Self {
                NiGeometryData {
                    base: Default::default(),
                    vertices: Default::default(),
                    normals: Default::default(),
                    bound: Default::default(),
                    vertex_colors: Default::default(),
                    uv_sets: Default::default(),
                }
            }
        }
        impl Load for NiGeometryData {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let num_vertices = stream.load_as::<u16, usize>()?;
                let has_vertices = stream.load::<u32>()? != 0;
                let num_vertices = if has_vertices { num_vertices } else { 0 };
                let vertices = stream.load_vec(num_vertices)?;
                let has_normals = stream.load::<u32>()? != 0;
                let num_normals = if has_normals { num_vertices } else { 0 };
                let normals = stream.load_vec(num_normals)?;
                let bound = stream.load()?;
                let has_vertex_colors = stream.load::<u32>()? != 0;
                let num_vertex_colors = if has_vertex_colors { num_vertices } else { 0 };
                let vertex_colors = stream.load_vec(num_vertex_colors)?;
                let num_uv_sets = stream.load_as::<u16, usize>()?;
                let has_uv_sets = stream.load::<u32>()? != 0;
                let num_uv_sets = if has_uv_sets { num_uv_sets } else { 0 };
                let uv_sets = stream.load_vec(num_vertices * num_uv_sets)?;
                Ok(Self {
                    base,
                    vertices,
                    normals,
                    bound,
                    vertex_colors,
                    uv_sets,
                })
            }
        }
        impl Save for NiGeometryData {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save_as::<u16>(self.vertices.len())?;
                stream.save_as::<u32>(!self.vertices.is_empty())?;
                stream.save_vec(&self.vertices)?;
                stream.save_as::<u32>(!self.normals.is_empty())?;
                stream.save_vec(&self.normals)?;
                stream.save(&self.bound)?;
                stream.save_as::<u32>(!self.vertex_colors.is_empty())?;
                stream.save_vec(&self.vertex_colors)?;
                stream.save_as::<u16>(self.num_uv_sets())?;
                stream.save_as::<u32>(!self.uv_sets.is_empty())?;
                stream.save_vec(&self.uv_sets)?;
                Ok(())
            }
        }
        impl NiGeometryData {
            pub fn num_uv_sets(&self) -> usize {
                if self.vertices.is_empty() {
                    0
                } else {
                    self.uv_sets.len() / self.vertices.len()
                }
            }
            pub fn uv_set(&self, index: usize) -> Option<&[[f32; 2]]> {
                let start = index * self.vertices.len();
                let end = start + self.vertices.len();
                self.uv_sets.get(start..end)
            }
            pub fn uv_set_mut(&mut self, index: usize) -> Option<&mut [[f32; 2]]> {
                let start = index * self.vertices.len();
                let end = start + self.vertices.len();
                self.uv_sets.get_mut(start..end)
            }
            pub fn update_center_radius(&mut self) {
                if self.vertices.is_empty() {
                    self.bound.center = Vec3::ZERO;
                    self.bound.radius = 0.0;
                    return;
                }
                let mut min = Vec3::splat(f32::INFINITY);
                let mut max = Vec3::splat(f32::NEG_INFINITY);
                for v_array in &self.vertices {
                    let v = Vec3::from_array(*v_array);
                    min = min.min(v);
                    max = max.max(v);
                }
                let center = 0.5 * (min + max);
                let mut radius = 0.0;
                for v_array in &self.vertices {
                    let v = Vec3::from_array(*v_array);
                    let d = v - center;
                    radius = d.dot(d).max(radius);
                }
                self.bound.center = center;
                self.bound.radius = radius.sqrt();
            }
        }
    }
    mod nigeommorphercontroller {
        use crate::prelude::*;
        pub struct NiGeomMorpherController {
            pub base: NiMorpherController,
            pub always_update: bool,
        }
        impl NiGeomMorpherController {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiGeomMorpherController"
            }
        }
        impl Visitor for NiGeomMorpherController {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.always_update).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiGeomMorpherController {
            type Target = NiMorpherController;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiGeomMorpherController {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiGeomMorpherController {
            #[inline]
            fn clone(&self) -> NiGeomMorpherController {
                NiGeomMorpherController {
                    base: ::core::clone::Clone::clone(&self.base),
                    always_update: ::core::clone::Clone::clone(&self.always_update),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiGeomMorpherController {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "NiGeomMorpherController",
                    "base",
                    &self.base,
                    "always_update",
                    &&self.always_update,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiGeomMorpherController {
            #[inline]
            fn default() -> NiGeomMorpherController {
                NiGeomMorpherController {
                    base: ::core::default::Default::default(),
                    always_update: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiGeomMorpherController {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiGeomMorpherController {
            #[inline]
            fn eq(&self, other: &NiGeomMorpherController) -> bool {
                self.always_update == other.always_update && self.base == other.base
            }
        }
        impl Load for NiGeomMorpherController {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let always_update = stream.load::<u8>()? != 0;
                Ok(Self { base, always_update })
            }
        }
        impl Save for NiGeomMorpherController {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save_as::<u8>(self.always_update)?;
                Ok(())
            }
        }
    }
    mod nigravity {
        use crate::prelude::*;
        pub struct NiGravity {
            pub base: NiParticleModifier,
            pub decay: f32,
            pub strength: f32,
            pub force_type: ForceType,
            pub position: Vec3,
            pub direction: Vec3,
        }
        impl NiGravity {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiGravity"
            }
        }
        impl Visitor for NiGravity {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.direction).visitor(f);
                (&self.position).visitor(f);
                (&self.force_type).visitor(f);
                (&self.strength).visitor(f);
                (&self.decay).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiGravity {
            type Target = NiParticleModifier;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiGravity {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiGravity {
            #[inline]
            fn clone(&self) -> NiGravity {
                NiGravity {
                    base: ::core::clone::Clone::clone(&self.base),
                    decay: ::core::clone::Clone::clone(&self.decay),
                    strength: ::core::clone::Clone::clone(&self.strength),
                    force_type: ::core::clone::Clone::clone(&self.force_type),
                    position: ::core::clone::Clone::clone(&self.position),
                    direction: ::core::clone::Clone::clone(&self.direction),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiGravity {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "base",
                    "decay",
                    "strength",
                    "force_type",
                    "position",
                    "direction",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.base,
                    &self.decay,
                    &self.strength,
                    &self.force_type,
                    &self.position,
                    &&self.direction,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "NiGravity",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiGravity {
            #[inline]
            fn default() -> NiGravity {
                NiGravity {
                    base: ::core::default::Default::default(),
                    decay: ::core::default::Default::default(),
                    strength: ::core::default::Default::default(),
                    force_type: ::core::default::Default::default(),
                    position: ::core::default::Default::default(),
                    direction: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiGravity {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiGravity {
            #[inline]
            fn eq(&self, other: &NiGravity) -> bool {
                self.decay == other.decay && self.strength == other.strength
                    && self.base == other.base && self.force_type == other.force_type
                    && self.position == other.position
                    && self.direction == other.direction
            }
        }
        impl Load for NiGravity {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let decay = stream.load()?;
                let strength = stream.load()?;
                let force_type = stream.load()?;
                let position = stream.load()?;
                let direction = stream.load()?;
                Ok(Self {
                    base,
                    decay,
                    strength,
                    force_type,
                    position,
                    direction,
                })
            }
        }
        impl Save for NiGravity {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save(&self.decay)?;
                stream.save(&self.strength)?;
                stream.save(&self.force_type)?;
                stream.save(&self.position)?;
                stream.save(&self.direction)?;
                Ok(())
            }
        }
    }
    mod nikeyframecontroller {
        use crate::prelude::*;
        pub struct NiKeyframeController {
            pub base: NiTimeController,
            pub data: NiLink<NiKeyframeData>,
        }
        impl NiKeyframeController {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiKeyframeController"
            }
        }
        impl Visitor for NiKeyframeController {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.data).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiKeyframeController {
            type Target = NiTimeController;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiKeyframeController {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiKeyframeController {
            #[inline]
            fn clone(&self) -> NiKeyframeController {
                NiKeyframeController {
                    base: ::core::clone::Clone::clone(&self.base),
                    data: ::core::clone::Clone::clone(&self.data),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiKeyframeController {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "NiKeyframeController",
                    "base",
                    &self.base,
                    "data",
                    &&self.data,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiKeyframeController {
            #[inline]
            fn default() -> NiKeyframeController {
                NiKeyframeController {
                    base: ::core::default::Default::default(),
                    data: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiKeyframeController {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiKeyframeController {
            #[inline]
            fn eq(&self, other: &NiKeyframeController) -> bool {
                self.base == other.base && self.data == other.data
            }
        }
        impl Load for NiKeyframeController {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let data = stream.load()?;
                Ok(Self { base, data })
            }
        }
        impl Save for NiKeyframeController {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save(&self.data)?;
                Ok(())
            }
        }
    }
    mod nikeyframedata {
        use crate::prelude::*;
        pub struct NiKeyframeData {
            pub base: NiObject,
            pub rotations: NiRotData,
            pub translations: NiPosData,
            pub scales: NiFloatData,
        }
        impl NiKeyframeData {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiKeyframeData"
            }
        }
        impl Visitor for NiKeyframeData {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.scales).visitor(f);
                (&self.translations).visitor(f);
                (&self.rotations).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiKeyframeData {
            type Target = NiObject;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiKeyframeData {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiKeyframeData {
            #[inline]
            fn clone(&self) -> NiKeyframeData {
                NiKeyframeData {
                    base: ::core::clone::Clone::clone(&self.base),
                    rotations: ::core::clone::Clone::clone(&self.rotations),
                    translations: ::core::clone::Clone::clone(&self.translations),
                    scales: ::core::clone::Clone::clone(&self.scales),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiKeyframeData {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "NiKeyframeData",
                    "base",
                    &self.base,
                    "rotations",
                    &self.rotations,
                    "translations",
                    &self.translations,
                    "scales",
                    &&self.scales,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiKeyframeData {
            #[inline]
            fn default() -> NiKeyframeData {
                NiKeyframeData {
                    base: ::core::default::Default::default(),
                    rotations: ::core::default::Default::default(),
                    translations: ::core::default::Default::default(),
                    scales: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiKeyframeData {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiKeyframeData {
            #[inline]
            fn eq(&self, other: &NiKeyframeData) -> bool {
                self.base == other.base && self.rotations == other.rotations
                    && self.translations == other.translations
                    && self.scales == other.scales
            }
        }
        impl Load for NiKeyframeData {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let rotations = stream.load()?;
                let translations = stream.load()?;
                let scales = stream.load()?;
                Ok(Self {
                    base,
                    rotations,
                    translations,
                    scales,
                })
            }
        }
        impl Save for NiKeyframeData {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save(&self.rotations)?;
                stream.save(&self.translations)?;
                stream.save(&self.scales)?;
                Ok(())
            }
        }
    }
    mod nikeyframemanager {
        use crate::prelude::*;
        pub struct NiKeyframeManager {
            pub base: NiTimeController,
            pub sequences: Vec<NiSequence>,
        }
        impl NiKeyframeManager {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiKeyframeManager"
            }
        }
        impl Visitor for NiKeyframeManager {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.sequences).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiKeyframeManager {
            type Target = NiTimeController;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiKeyframeManager {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiKeyframeManager {
            #[inline]
            fn clone(&self) -> NiKeyframeManager {
                NiKeyframeManager {
                    base: ::core::clone::Clone::clone(&self.base),
                    sequences: ::core::clone::Clone::clone(&self.sequences),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiKeyframeManager {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "NiKeyframeManager",
                    "base",
                    &self.base,
                    "sequences",
                    &&self.sequences,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiKeyframeManager {
            #[inline]
            fn default() -> NiKeyframeManager {
                NiKeyframeManager {
                    base: ::core::default::Default::default(),
                    sequences: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiKeyframeManager {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiKeyframeManager {
            #[inline]
            fn eq(&self, other: &NiKeyframeManager) -> bool {
                self.base == other.base && self.sequences == other.sequences
            }
        }
        impl Load for NiKeyframeManager {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let sequences = stream.load()?;
                Ok(Self { base, sequences })
            }
        }
        impl Save for NiKeyframeManager {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save(&self.sequences)?;
                Ok(())
            }
        }
    }
    mod nilight {
        use crate::prelude::*;
        pub struct NiLight {
            pub base: NiDynamicEffect,
            pub dimmer: f32,
            pub ambient_color: Vec3,
            pub diffuse_color: Vec3,
            pub specular_color: Vec3,
        }
        impl NiLight {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiLight"
            }
        }
        impl Visitor for NiLight {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.specular_color).visitor(f);
                (&self.diffuse_color).visitor(f);
                (&self.ambient_color).visitor(f);
                (&self.dimmer).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiLight {
            type Target = NiDynamicEffect;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiLight {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiLight {
            #[inline]
            fn clone(&self) -> NiLight {
                NiLight {
                    base: ::core::clone::Clone::clone(&self.base),
                    dimmer: ::core::clone::Clone::clone(&self.dimmer),
                    ambient_color: ::core::clone::Clone::clone(&self.ambient_color),
                    diffuse_color: ::core::clone::Clone::clone(&self.diffuse_color),
                    specular_color: ::core::clone::Clone::clone(&self.specular_color),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiLight {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field5_finish(
                    f,
                    "NiLight",
                    "base",
                    &self.base,
                    "dimmer",
                    &self.dimmer,
                    "ambient_color",
                    &self.ambient_color,
                    "diffuse_color",
                    &self.diffuse_color,
                    "specular_color",
                    &&self.specular_color,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiLight {
            #[inline]
            fn default() -> NiLight {
                NiLight {
                    base: ::core::default::Default::default(),
                    dimmer: ::core::default::Default::default(),
                    ambient_color: ::core::default::Default::default(),
                    diffuse_color: ::core::default::Default::default(),
                    specular_color: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiLight {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiLight {
            #[inline]
            fn eq(&self, other: &NiLight) -> bool {
                self.dimmer == other.dimmer && self.base == other.base
                    && self.ambient_color == other.ambient_color
                    && self.diffuse_color == other.diffuse_color
                    && self.specular_color == other.specular_color
            }
        }
        impl Load for NiLight {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let dimmer = stream.load()?;
                let ambient_color = stream.load()?;
                let diffuse_color = stream.load()?;
                let specular_color = stream.load()?;
                Ok(Self {
                    base,
                    dimmer,
                    ambient_color,
                    diffuse_color,
                    specular_color,
                })
            }
        }
        impl Save for NiLight {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save(&self.dimmer)?;
                stream.save(&self.ambient_color)?;
                stream.save(&self.diffuse_color)?;
                stream.save(&self.specular_color)?;
                Ok(())
            }
        }
    }
    mod nilightcolorcontroller {
        use crate::prelude::*;
        pub struct NiLightColorController {
            pub base: NiTimeController,
            pub data: NiLink<NiPosData>,
        }
        impl NiLightColorController {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiLightColorController"
            }
        }
        impl Visitor for NiLightColorController {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.data).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiLightColorController {
            type Target = NiTimeController;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiLightColorController {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiLightColorController {
            #[inline]
            fn clone(&self) -> NiLightColorController {
                NiLightColorController {
                    base: ::core::clone::Clone::clone(&self.base),
                    data: ::core::clone::Clone::clone(&self.data),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiLightColorController {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "NiLightColorController",
                    "base",
                    &self.base,
                    "data",
                    &&self.data,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiLightColorController {
            #[inline]
            fn default() -> NiLightColorController {
                NiLightColorController {
                    base: ::core::default::Default::default(),
                    data: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiLightColorController {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiLightColorController {
            #[inline]
            fn eq(&self, other: &NiLightColorController) -> bool {
                self.base == other.base && self.data == other.data
            }
        }
        impl Load for NiLightColorController {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let data = stream.load()?;
                Ok(Self { base, data })
            }
        }
        impl Save for NiLightColorController {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save(&self.data)?;
                Ok(())
            }
        }
        impl NiLightColorController {
            #[inline]
            pub fn ambient(&self) -> bool {
                self.flags & 0x0010 != 0
            }
            #[inline]
            pub fn set_ambient(&mut self, value: bool) {
                if value {
                    self.flags |= 0x0010;
                } else {
                    self.flags &= !0x0010;
                }
            }
        }
    }
    mod nilines {
        use crate::prelude::*;
        pub struct NiLines {
            pub base: NiGeometry,
        }
        impl NiLines {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiLines"
            }
        }
        impl Visitor for NiLines {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiLines {
            type Target = NiGeometry;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiLines {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiLines {
            #[inline]
            fn clone(&self) -> NiLines {
                NiLines {
                    base: ::core::clone::Clone::clone(&self.base),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiLines {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "NiLines",
                    "base",
                    &&self.base,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiLines {
            #[inline]
            fn default() -> NiLines {
                NiLines {
                    base: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiLines {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiLines {
            #[inline]
            fn eq(&self, other: &NiLines) -> bool {
                self.base == other.base
            }
        }
        impl Load for NiLines {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                Ok(Self { base })
            }
        }
        impl Save for NiLines {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                Ok(())
            }
        }
    }
    mod nilinesdata {
        use crate::prelude::*;
        pub struct NiLinesData {
            pub base: NiGeometryData,
            pub vertex_connectivity_flags: Vec<u8>,
        }
        impl NiLinesData {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiLinesData"
            }
        }
        impl Visitor for NiLinesData {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.vertex_connectivity_flags).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiLinesData {
            type Target = NiGeometryData;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiLinesData {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiLinesData {
            #[inline]
            fn clone(&self) -> NiLinesData {
                NiLinesData {
                    base: ::core::clone::Clone::clone(&self.base),
                    vertex_connectivity_flags: ::core::clone::Clone::clone(
                        &self.vertex_connectivity_flags,
                    ),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiLinesData {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "NiLinesData",
                    "base",
                    &self.base,
                    "vertex_connectivity_flags",
                    &&self.vertex_connectivity_flags,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiLinesData {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiLinesData {
            #[inline]
            fn eq(&self, other: &NiLinesData) -> bool {
                self.base == other.base
                    && self.vertex_connectivity_flags == other.vertex_connectivity_flags
            }
        }
        #[automatically_derived]
        impl Default for NiLinesData {
            /**Return `NiLinesData {
    base: Default::default(),
    vertex_connectivity_flags: Default::default()
}`*/
            fn default() -> Self {
                NiLinesData {
                    base: Default::default(),
                    vertex_connectivity_flags: Default::default(),
                }
            }
        }
        impl Load for NiLinesData {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base: NiGeometryData = stream.load()?;
                let vertex_connectivity_flags = stream.load_vec(base.vertices.len())?;
                Ok(Self {
                    base,
                    vertex_connectivity_flags,
                })
            }
        }
        impl Save for NiLinesData {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save_vec(&self.vertex_connectivity_flags)?;
                Ok(())
            }
        }
    }
    mod nilink {
        use std::marker::PhantomData;
        use slotmap::{Key, KeyData};
        use crate::prelude::*;
        pub struct NiLink<T> {
            pub key: NiKey,
            phantom: PhantomData<fn() -> T>,
        }
        #[automatically_derived]
        impl<T: ::core::fmt::Debug> ::core::fmt::Debug for NiLink<T> {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "NiLink",
                    "key",
                    &self.key,
                    "phantom",
                    &&self.phantom,
                )
            }
        }
        #[automatically_derived]
        impl<T: ::core::default::Default> ::core::default::Default for NiLink<T> {
            #[inline]
            fn default() -> NiLink<T> {
                NiLink {
                    key: ::core::default::Default::default(),
                    phantom: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl<T: ::core::cmp::Eq> ::core::cmp::Eq for NiLink<T> {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<NiKey>;
                let _: ::core::cmp::AssertParamIsEq<PhantomData<fn() -> T>>;
            }
        }
        #[automatically_derived]
        impl<T> ::core::marker::StructuralPartialEq for NiLink<T> {}
        #[automatically_derived]
        impl<T: ::core::cmp::PartialEq> ::core::cmp::PartialEq for NiLink<T> {
            #[inline]
            fn eq(&self, other: &NiLink<T>) -> bool {
                self.key == other.key && self.phantom == other.phantom
            }
        }
        impl<T> NiLink<T> {
            #[inline]
            pub const fn new(key: NiKey) -> Self {
                Self { key, phantom: PhantomData }
            }
            #[inline]
            pub fn null() -> Self {
                Self::new(NiKey::null())
            }
            #[inline]
            pub fn is_null(&self) -> bool {
                self.key.is_null()
            }
            #[inline]
            pub const fn cast<U>(&self) -> NiLink<U> {
                NiLink::new(self.key)
            }
        }
        impl<T> Clone for NiLink<T> {
            fn clone(&self) -> Self {
                *self
            }
        }
        impl<T> Copy for NiLink<T> {}
        impl<T> Load for NiLink<T>
        where
            T: Load,
        {
            #[allow(clippy::cast_sign_loss)]
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let idx: i32 = stream.load()?;
                let key = match idx {
                    i if (i < 0) => NiKey::null(),
                    i => KeyData::from_ffi((1 << 32) | (i as u64 + 1)).into(),
                };
                Ok(Self::new(key))
            }
        }
        impl<T> Save for NiLink<T>
        where
            T: Save,
        {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                if self.is_null() {
                    stream.save(&-1i32)?;
                } else {
                    let key = self.key.data().as_ffi();
                    stream.save_as::<i32>(stream.context[&key])?;
                }
                Ok(())
            }
        }
        pub trait Visitor {
            fn visitor<F>(&self, f: &mut F)
            where
                F: FnMut(NiKey);
        }
        impl<T> Visitor for &T {
            #[inline]
            fn visitor<F>(&self, _: &mut F)
            where
                F: FnMut(NiKey),
            {}
        }
        impl<V: Visitor> Visitor for Option<V> {
            #[inline]
            fn visitor<F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                if let Some(inner) = self {
                    inner.visitor(f);
                }
            }
        }
        impl<V: Visitor> Visitor for Vec<V> {
            #[inline]
            fn visitor<F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                for item in self.iter().rev() {
                    item.visitor(f);
                }
            }
        }
        impl<T> Visitor for NiLink<T> {
            #[inline]
            fn visitor<F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                f(self.key);
            }
        }
        impl Visitor for TextureMap {
            #[inline]
            fn visitor<F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                match self {
                    TextureMap::Map(inner) => inner.visitor(f),
                    TextureMap::BumpMap(inner) => inner.visitor(f),
                }
            }
        }
        impl Visitor for TextureSource {
            #[inline]
            fn visitor<F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                match self {
                    TextureSource::External(inner) => inner.visitor(f),
                    TextureSource::Internal(inner) => inner.visitor(f),
                }
            }
        }
    }
    mod nilodnode {
        use crate::prelude::*;
        pub struct NiLODNode {
            pub base: NiSwitchNode,
            pub lod_center: Vec3,
            pub lod_levels: Vec<[f32; 2]>,
        }
        impl NiLODNode {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiLODNode"
            }
        }
        impl Visitor for NiLODNode {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.lod_levels).visitor(f);
                (&self.lod_center).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiLODNode {
            type Target = NiSwitchNode;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiLODNode {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiLODNode {
            #[inline]
            fn clone(&self) -> NiLODNode {
                NiLODNode {
                    base: ::core::clone::Clone::clone(&self.base),
                    lod_center: ::core::clone::Clone::clone(&self.lod_center),
                    lod_levels: ::core::clone::Clone::clone(&self.lod_levels),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiLODNode {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "NiLODNode",
                    "base",
                    &self.base,
                    "lod_center",
                    &self.lod_center,
                    "lod_levels",
                    &&self.lod_levels,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiLODNode {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiLODNode {
            #[inline]
            fn eq(&self, other: &NiLODNode) -> bool {
                self.base == other.base && self.lod_center == other.lod_center
                    && self.lod_levels == other.lod_levels
            }
        }
        #[automatically_derived]
        impl Default for NiLODNode {
            /**Return `NiLODNode {
    base: Default::default(),
    lod_center: Default::default(),
    lod_levels: Default::default()
}`*/
            fn default() -> Self {
                NiLODNode {
                    base: Default::default(),
                    lod_center: Default::default(),
                    lod_levels: Default::default(),
                }
            }
        }
        impl Load for NiLODNode {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let lod_center = stream.load()?;
                let num_lod_levels: u32 = stream.load()?;
                let lod_levels = stream.load_vec(num_lod_levels)?;
                Ok(Self {
                    base,
                    lod_center,
                    lod_levels,
                })
            }
        }
        impl Save for NiLODNode {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save(&self.lod_center)?;
                stream.save_as::<u32>(self.lod_levels.len())?;
                stream.save_vec(&self.lod_levels)?;
                Ok(())
            }
        }
    }
    mod nilookatcontroller {
        use crate::prelude::*;
        pub struct NiLookAtController {
            pub base: NiTimeController,
            pub look_at: NiLink<NiAVObject>,
        }
        impl NiLookAtController {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiLookAtController"
            }
        }
        impl Visitor for NiLookAtController {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.look_at).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiLookAtController {
            type Target = NiTimeController;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiLookAtController {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiLookAtController {
            #[inline]
            fn clone(&self) -> NiLookAtController {
                NiLookAtController {
                    base: ::core::clone::Clone::clone(&self.base),
                    look_at: ::core::clone::Clone::clone(&self.look_at),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiLookAtController {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "NiLookAtController",
                    "base",
                    &self.base,
                    "look_at",
                    &&self.look_at,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiLookAtController {
            #[inline]
            fn default() -> NiLookAtController {
                NiLookAtController {
                    base: ::core::default::Default::default(),
                    look_at: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiLookAtController {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiLookAtController {
            #[inline]
            fn eq(&self, other: &NiLookAtController) -> bool {
                self.base == other.base && self.look_at == other.look_at
            }
        }
        impl Load for NiLookAtController {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let look_at = stream.load()?;
                Ok(Self { base, look_at })
            }
        }
        impl Save for NiLookAtController {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save(&self.look_at)?;
                Ok(())
            }
        }
        impl NiLookAtController {
            #[inline]
            pub fn flip(&self) -> bool {
                self.flags & 0x0010 != 0
            }
            #[inline]
            pub fn set_flip(&mut self, value: bool) {
                if value {
                    self.flags |= 0x0010;
                } else {
                    self.flags &= !0x0010;
                }
            }
            #[inline]
            pub fn axis(&self) -> Axis {
                let value = (self.flags & 0x0060) >> 5;
                value.try_into().unwrap_or_default()
            }
            #[inline]
            pub fn set_axis(&mut self, value: Axis) {
                self.flags = (self.flags & !0x0060) | ((value as u16) << 5);
            }
        }
    }
    mod nimaterialcolorcontroller {
        use crate::prelude::*;
        pub struct NiMaterialColorController {
            pub base: NiTimeController,
            pub data: NiLink<NiPosData>,
        }
        impl NiMaterialColorController {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiMaterialColorController"
            }
        }
        impl Visitor for NiMaterialColorController {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.data).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiMaterialColorController {
            type Target = NiTimeController;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiMaterialColorController {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiMaterialColorController {
            #[inline]
            fn clone(&self) -> NiMaterialColorController {
                NiMaterialColorController {
                    base: ::core::clone::Clone::clone(&self.base),
                    data: ::core::clone::Clone::clone(&self.data),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiMaterialColorController {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "NiMaterialColorController",
                    "base",
                    &self.base,
                    "data",
                    &&self.data,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiMaterialColorController {
            #[inline]
            fn default() -> NiMaterialColorController {
                NiMaterialColorController {
                    base: ::core::default::Default::default(),
                    data: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiMaterialColorController {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiMaterialColorController {
            #[inline]
            fn eq(&self, other: &NiMaterialColorController) -> bool {
                self.base == other.base && self.data == other.data
            }
        }
        impl Load for NiMaterialColorController {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let data = stream.load()?;
                Ok(Self { base, data })
            }
        }
        impl Save for NiMaterialColorController {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save(&self.data)?;
                Ok(())
            }
        }
    }
    mod nimaterialproperty {
        use crate::prelude::*;
        pub struct NiMaterialProperty {
            pub base: NiProperty,
            pub ambient_color: Vec3,
            pub diffuse_color: Vec3,
            pub specular_color: Vec3,
            pub emissive_color: Vec3,
            pub shine: f32,
            pub alpha: f32,
        }
        impl NiMaterialProperty {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiMaterialProperty"
            }
        }
        impl Visitor for NiMaterialProperty {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.alpha).visitor(f);
                (&self.shine).visitor(f);
                (&self.emissive_color).visitor(f);
                (&self.specular_color).visitor(f);
                (&self.diffuse_color).visitor(f);
                (&self.ambient_color).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiMaterialProperty {
            type Target = NiProperty;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiMaterialProperty {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiMaterialProperty {
            #[inline]
            fn clone(&self) -> NiMaterialProperty {
                NiMaterialProperty {
                    base: ::core::clone::Clone::clone(&self.base),
                    ambient_color: ::core::clone::Clone::clone(&self.ambient_color),
                    diffuse_color: ::core::clone::Clone::clone(&self.diffuse_color),
                    specular_color: ::core::clone::Clone::clone(&self.specular_color),
                    emissive_color: ::core::clone::Clone::clone(&self.emissive_color),
                    shine: ::core::clone::Clone::clone(&self.shine),
                    alpha: ::core::clone::Clone::clone(&self.alpha),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiMaterialProperty {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "base",
                    "ambient_color",
                    "diffuse_color",
                    "specular_color",
                    "emissive_color",
                    "shine",
                    "alpha",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.base,
                    &self.ambient_color,
                    &self.diffuse_color,
                    &self.specular_color,
                    &self.emissive_color,
                    &self.shine,
                    &&self.alpha,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "NiMaterialProperty",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiMaterialProperty {
            #[inline]
            fn default() -> NiMaterialProperty {
                NiMaterialProperty {
                    base: ::core::default::Default::default(),
                    ambient_color: ::core::default::Default::default(),
                    diffuse_color: ::core::default::Default::default(),
                    specular_color: ::core::default::Default::default(),
                    emissive_color: ::core::default::Default::default(),
                    shine: ::core::default::Default::default(),
                    alpha: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiMaterialProperty {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiMaterialProperty {
            #[inline]
            fn eq(&self, other: &NiMaterialProperty) -> bool {
                self.shine == other.shine && self.alpha == other.alpha
                    && self.base == other.base
                    && self.ambient_color == other.ambient_color
                    && self.diffuse_color == other.diffuse_color
                    && self.specular_color == other.specular_color
                    && self.emissive_color == other.emissive_color
            }
        }
        impl Load for NiMaterialProperty {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let ambient_color = stream.load()?;
                let diffuse_color = stream.load()?;
                let specular_color = stream.load()?;
                let emissive_color = stream.load()?;
                let shine = stream.load()?;
                let alpha = stream.load()?;
                Ok(Self {
                    base,
                    ambient_color,
                    diffuse_color,
                    specular_color,
                    emissive_color,
                    shine,
                    alpha,
                })
            }
        }
        impl Save for NiMaterialProperty {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save(&self.ambient_color)?;
                stream.save(&self.diffuse_color)?;
                stream.save(&self.specular_color)?;
                stream.save(&self.emissive_color)?;
                stream.save(&self.shine)?;
                stream.save(&self.alpha)?;
                Ok(())
            }
        }
    }
    mod nimorphdata {
        use bytemuck::cast_slice;
        use crate::prelude::*;
        pub struct NiMorphData {
            pub base: NiObject,
            #[default(true)]
            pub relative_targets: bool,
            pub targets: Vec<MorphTarget>,
        }
        impl NiMorphData {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiMorphData"
            }
        }
        impl Visitor for NiMorphData {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.targets).visitor(f);
                (&self.relative_targets).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiMorphData {
            type Target = NiObject;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiMorphData {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiMorphData {
            #[inline]
            fn clone(&self) -> NiMorphData {
                NiMorphData {
                    base: ::core::clone::Clone::clone(&self.base),
                    relative_targets: ::core::clone::Clone::clone(
                        &self.relative_targets,
                    ),
                    targets: ::core::clone::Clone::clone(&self.targets),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiMorphData {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "NiMorphData",
                    "base",
                    &self.base,
                    "relative_targets",
                    &self.relative_targets,
                    "targets",
                    &&self.targets,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiMorphData {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiMorphData {
            #[inline]
            fn eq(&self, other: &NiMorphData) -> bool {
                self.relative_targets == other.relative_targets
                    && self.base == other.base && self.targets == other.targets
            }
        }
        #[automatically_derived]
        impl Default for NiMorphData {
            /**Return `NiMorphData {
    base: Default::default(),
    relative_targets: true,
    targets: Default::default()
}`*/
            fn default() -> Self {
                NiMorphData {
                    base: Default::default(),
                    relative_targets: true,
                    targets: Default::default(),
                }
            }
        }
        impl Load for NiMorphData {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let num_targets: u32 = stream.load()?;
                let num_vertices: u32 = stream.load()?;
                let relative_targets = stream.load::<u8>()? != 0;
                let targets = (0..num_targets)
                    .load(|_| MorphTarget::load(stream, num_vertices))?;
                Ok(Self {
                    base,
                    relative_targets,
                    targets,
                })
            }
        }
        impl Save for NiMorphData {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save_as::<u32>(self.targets.len())?;
                stream
                    .save_as::<
                        u32,
                    >(self.targets.first().map_or(0, |target| target.vertices.len()))?;
                stream.save_as::<u8>(self.relative_targets)?;
                stream.save_seq(&self.targets)?;
                Ok(())
            }
        }
        pub struct MorphTarget {
            pub keys: NiFloatKey,
            pub vertices: Vec<Vec3>,
        }
        impl MorphTarget {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"MorphTarget"
            }
        }
        impl Visitor for MorphTarget {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.vertices).visitor(f);
                (&self.keys).visitor(f);
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for MorphTarget {
            #[inline]
            fn clone(&self) -> MorphTarget {
                MorphTarget {
                    keys: ::core::clone::Clone::clone(&self.keys),
                    vertices: ::core::clone::Clone::clone(&self.vertices),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for MorphTarget {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "MorphTarget",
                    "keys",
                    &self.keys,
                    "vertices",
                    &&self.vertices,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for MorphTarget {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for MorphTarget {
            #[inline]
            fn eq(&self, other: &MorphTarget) -> bool {
                self.keys == other.keys && self.vertices == other.vertices
            }
        }
        #[automatically_derived]
        impl Default for MorphTarget {
            /**Return `MorphTarget {
    keys: Default::default(),
    vertices: Default::default()
}`*/
            fn default() -> Self {
                MorphTarget {
                    keys: Default::default(),
                    vertices: Default::default(),
                }
            }
        }
        impl MorphTarget {
            fn load(stream: &mut Reader<'_>, num_vertices: u32) -> io::Result<Self> {
                let num_keys: u32 = stream.load()?;
                let key_type = stream.load()?;
                let keys = match key_type {
                    KeyType::LinKey => NiFloatKey::LinKey(stream.load_vec(num_keys)?),
                    KeyType::BezKey => NiFloatKey::BezKey(stream.load_vec(num_keys)?),
                    KeyType::TCBKey => NiFloatKey::TCBKey(stream.load_vec(num_keys)?),
                    _ if (num_keys == 0) => default(),
                    _ => {
                        Reader::error(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("Invalid KeyType: {0:?}", key_type),
                                )
                            }),
                        )?
                    }
                };
                let vertices = stream.load_vec(num_vertices)?;
                Ok(Self { keys, vertices })
            }
        }
        impl Save for MorphTarget {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                let (len, key_type, bytes) = match &self.keys {
                    NiFloatKey::LinKey(keys) => {
                        (keys.len(), KeyType::LinKey, cast_slice(keys))
                    }
                    NiFloatKey::BezKey(keys) => {
                        (keys.len(), KeyType::BezKey, cast_slice(keys))
                    }
                    NiFloatKey::TCBKey(keys) => {
                        (keys.len(), KeyType::TCBKey, cast_slice(keys))
                    }
                };
                stream.save_as::<u32>(len)?;
                stream.save(&key_type)?;
                stream.save_bytes(bytes)?;
                stream.save_vec(&self.vertices)?;
                Ok(())
            }
        }
    }
    mod nimorphercontroller {
        use crate::prelude::*;
        pub struct NiMorpherController {
            pub base: NiTimeController,
            pub data: NiLink<NiMorphData>,
        }
        impl NiMorpherController {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiMorpherController"
            }
        }
        impl Visitor for NiMorpherController {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.data).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiMorpherController {
            type Target = NiTimeController;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiMorpherController {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiMorpherController {
            #[inline]
            fn clone(&self) -> NiMorpherController {
                NiMorpherController {
                    base: ::core::clone::Clone::clone(&self.base),
                    data: ::core::clone::Clone::clone(&self.data),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiMorpherController {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "NiMorpherController",
                    "base",
                    &self.base,
                    "data",
                    &&self.data,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiMorpherController {
            #[inline]
            fn default() -> NiMorpherController {
                NiMorpherController {
                    base: ::core::default::Default::default(),
                    data: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiMorpherController {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiMorpherController {
            #[inline]
            fn eq(&self, other: &NiMorpherController) -> bool {
                self.base == other.base && self.data == other.data
            }
        }
        impl Load for NiMorpherController {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let data = stream.load()?;
                Ok(Self { base, data })
            }
        }
        impl Save for NiMorpherController {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save(&self.data)?;
                Ok(())
            }
        }
    }
    mod ninode {
        use std::collections::VecDeque;
        use crate::prelude::*;
        pub struct NiNode {
            pub base: NiAVObject,
            pub children: Vec<NiLink<NiAVObject>>,
            pub effects: Vec<NiLink<NiDynamicEffect>>,
        }
        impl NiNode {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiNode"
            }
        }
        impl Visitor for NiNode {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.effects).visitor(f);
                (&self.children).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiNode {
            type Target = NiAVObject;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiNode {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiNode {
            #[inline]
            fn clone(&self) -> NiNode {
                NiNode {
                    base: ::core::clone::Clone::clone(&self.base),
                    children: ::core::clone::Clone::clone(&self.children),
                    effects: ::core::clone::Clone::clone(&self.effects),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiNode {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "NiNode",
                    "base",
                    &self.base,
                    "children",
                    &self.children,
                    "effects",
                    &&self.effects,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiNode {
            #[inline]
            fn default() -> NiNode {
                NiNode {
                    base: ::core::default::Default::default(),
                    children: ::core::default::Default::default(),
                    effects: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiNode {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiNode {
            #[inline]
            fn eq(&self, other: &NiNode) -> bool {
                self.base == other.base && self.children == other.children
                    && self.effects == other.effects
            }
        }
        impl Load for NiNode {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let children = stream.load()?;
                let effects = stream.load()?;
                Ok(Self { base, children, effects })
            }
        }
        impl Save for NiNode {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save(&self.children)?;
                stream.save(&self.effects)?;
                Ok(())
            }
        }
        impl NiNode {
            pub fn children_recursive<'a>(
                &'a self,
                stream: &'a NiStream,
            ) -> impl 'a + Iterator<Item = NiLink<NiAVObject>> {
                let mut stack: VecDeque<_> = self.children.iter().copied().collect();
                std::iter::from_fn(move || {
                    while let Some(link) = stack.pop_front() {
                        if !link.is_null() {
                            if let Some(node) = stream.get_as::<_, NiNode>(link) {
                                for child in &node.children {
                                    stack.push_front(*child);
                                }
                            }
                            return Some(link);
                        }
                    }
                    None
                })
            }
            pub fn children_of_type<'a, T>(
                &'a self,
                stream: &'a NiStream,
            ) -> impl 'a + Iterator<Item = &'a T>
            where
                &'a T: 'a + TryFrom<&'a NiType>,
            {
                self.children
                    .iter()
                    .filter_map(move |child| stream.get_as::<_, T>(*child))
            }
            pub fn children_of_type_recursive<'a, T>(
                &'a self,
                stream: &'a NiStream,
            ) -> impl 'a + Iterator<Item = &'a T>
            where
                &'a T: 'a + TryFrom<&'a NiType>,
            {
                self.children_recursive(stream)
                    .filter_map(move |child| stream.get_as::<_, T>(child))
            }
        }
    }
    mod niobject {
        #![allow(unused_variables)]
        use crate::prelude::*;
        pub struct NiObject;
        impl NiObject {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiObject"
            }
        }
        impl Visitor for NiObject {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {}
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiObject {
            #[inline]
            fn clone(&self) -> NiObject {
                NiObject
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiObject {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(f, "NiObject")
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiObject {
            #[inline]
            fn default() -> NiObject {
                NiObject {}
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for NiObject {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiObject {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiObject {
            #[inline]
            fn eq(&self, other: &NiObject) -> bool {
                true
            }
        }
        impl Load for NiObject {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                Ok(Self)
            }
        }
        impl Save for NiObject {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                Ok(())
            }
        }
    }
    mod niobjectnet {
        use crate::prelude::*;
        pub struct NiObjectNET {
            pub base: NiObject,
            pub name: String,
            pub extra_data: NiLink<NiExtraData>,
            pub controller: NiLink<NiTimeController>,
        }
        impl NiObjectNET {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiObjectNET"
            }
        }
        impl Visitor for NiObjectNET {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.controller).visitor(f);
                (&self.extra_data).visitor(f);
                (&self.name).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiObjectNET {
            type Target = NiObject;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiObjectNET {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiObjectNET {
            #[inline]
            fn clone(&self) -> NiObjectNET {
                NiObjectNET {
                    base: ::core::clone::Clone::clone(&self.base),
                    name: ::core::clone::Clone::clone(&self.name),
                    extra_data: ::core::clone::Clone::clone(&self.extra_data),
                    controller: ::core::clone::Clone::clone(&self.controller),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiObjectNET {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "NiObjectNET",
                    "base",
                    &self.base,
                    "name",
                    &self.name,
                    "extra_data",
                    &self.extra_data,
                    "controller",
                    &&self.controller,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiObjectNET {
            #[inline]
            fn default() -> NiObjectNET {
                NiObjectNET {
                    base: ::core::default::Default::default(),
                    name: ::core::default::Default::default(),
                    extra_data: ::core::default::Default::default(),
                    controller: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiObjectNET {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiObjectNET {
            #[inline]
            fn eq(&self, other: &NiObjectNET) -> bool {
                self.base == other.base && self.name == other.name
                    && self.extra_data == other.extra_data
                    && self.controller == other.controller
            }
        }
        impl Load for NiObjectNET {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let name = stream.load()?;
                let extra_data = stream.load()?;
                let controller = stream.load()?;
                Ok(Self {
                    base,
                    name,
                    extra_data,
                    controller,
                })
            }
        }
        impl Save for NiObjectNET {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save_string_without_null_terminator(&self.name)?;
                stream.save(&self.extra_data)?;
                stream.save(&self.controller)?;
                Ok(())
            }
        }
        impl NiObjectNET {
            pub fn extra_datas<'a>(
                &'a self,
                stream: &'a NiStream,
            ) -> impl Iterator<Item = &'a NiType> {
                let mut next = self.extra_data;
                std::iter::from_fn(move || {
                    let object = stream.objects.get(next.key)?;
                    let extra_data: &NiExtraData = object.try_into().ok()?;
                    next = extra_data.next;
                    Some(object)
                })
            }
            pub fn extra_datas_of_type<'a, T>(
                &'a self,
                stream: &'a NiStream,
            ) -> impl Iterator<Item = &'a T>
            where
                &'a T: 'a + TryFrom<&'a NiType>,
            {
                self.extra_datas(stream).filter_map(|object| object.try_into().ok())
            }
        }
    }
    mod nipalette {
        use crate::prelude::*;
        pub struct NiPalette {
            pub base: NiObject,
            pub has_alpha: bool,
            pub palettes: Vec<[u8; 4]>,
        }
        impl NiPalette {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiPalette"
            }
        }
        impl Visitor for NiPalette {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.palettes).visitor(f);
                (&self.has_alpha).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiPalette {
            type Target = NiObject;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiPalette {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiPalette {
            #[inline]
            fn clone(&self) -> NiPalette {
                NiPalette {
                    base: ::core::clone::Clone::clone(&self.base),
                    has_alpha: ::core::clone::Clone::clone(&self.has_alpha),
                    palettes: ::core::clone::Clone::clone(&self.palettes),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiPalette {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "NiPalette",
                    "base",
                    &self.base,
                    "has_alpha",
                    &self.has_alpha,
                    "palettes",
                    &&self.palettes,
                )
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for NiPalette {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<NiObject>;
                let _: ::core::cmp::AssertParamIsEq<bool>;
                let _: ::core::cmp::AssertParamIsEq<Vec<[u8; 4]>>;
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiPalette {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiPalette {
            #[inline]
            fn eq(&self, other: &NiPalette) -> bool {
                self.has_alpha == other.has_alpha && self.base == other.base
                    && self.palettes == other.palettes
            }
        }
        #[automatically_derived]
        impl Default for NiPalette {
            /**Return `NiPalette {
    base: Default::default(),
    has_alpha: Default::default(),
    palettes: Default::default()
}`*/
            fn default() -> Self {
                NiPalette {
                    base: Default::default(),
                    has_alpha: Default::default(),
                    palettes: Default::default(),
                }
            }
        }
        impl Load for NiPalette {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let has_alpha = stream.load::<u8>()? != 0;
                let num_palettes: u32 = stream.load()?;
                let palettes = stream.load_vec(num_palettes)?;
                Ok(Self { base, has_alpha, palettes })
            }
        }
        impl Save for NiPalette {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save_as::<u8>(self.has_alpha)?;
                stream.save_as::<u32>(self.palettes.len())?;
                stream.save_vec(&self.palettes)?;
                Ok(())
            }
        }
    }
    mod niparticlebomb {
        use crate::prelude::*;
        pub struct NiParticleBomb {
            pub base: NiParticleModifier,
            pub decay: f32,
            pub duration: f32,
            pub delta_v: f32,
            pub start_time: f32,
            pub decay_type: DecayType,
            pub symmetry_type: SymmetryType,
            pub position: Vec3,
            pub direction: Vec3,
        }
        impl NiParticleBomb {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiParticleBomb"
            }
        }
        impl Visitor for NiParticleBomb {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.direction).visitor(f);
                (&self.position).visitor(f);
                (&self.symmetry_type).visitor(f);
                (&self.decay_type).visitor(f);
                (&self.start_time).visitor(f);
                (&self.delta_v).visitor(f);
                (&self.duration).visitor(f);
                (&self.decay).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiParticleBomb {
            type Target = NiParticleModifier;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiParticleBomb {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiParticleBomb {
            #[inline]
            fn clone(&self) -> NiParticleBomb {
                NiParticleBomb {
                    base: ::core::clone::Clone::clone(&self.base),
                    decay: ::core::clone::Clone::clone(&self.decay),
                    duration: ::core::clone::Clone::clone(&self.duration),
                    delta_v: ::core::clone::Clone::clone(&self.delta_v),
                    start_time: ::core::clone::Clone::clone(&self.start_time),
                    decay_type: ::core::clone::Clone::clone(&self.decay_type),
                    symmetry_type: ::core::clone::Clone::clone(&self.symmetry_type),
                    position: ::core::clone::Clone::clone(&self.position),
                    direction: ::core::clone::Clone::clone(&self.direction),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiParticleBomb {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "base",
                    "decay",
                    "duration",
                    "delta_v",
                    "start_time",
                    "decay_type",
                    "symmetry_type",
                    "position",
                    "direction",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.base,
                    &self.decay,
                    &self.duration,
                    &self.delta_v,
                    &self.start_time,
                    &self.decay_type,
                    &self.symmetry_type,
                    &self.position,
                    &&self.direction,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "NiParticleBomb",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiParticleBomb {
            #[inline]
            fn default() -> NiParticleBomb {
                NiParticleBomb {
                    base: ::core::default::Default::default(),
                    decay: ::core::default::Default::default(),
                    duration: ::core::default::Default::default(),
                    delta_v: ::core::default::Default::default(),
                    start_time: ::core::default::Default::default(),
                    decay_type: ::core::default::Default::default(),
                    symmetry_type: ::core::default::Default::default(),
                    position: ::core::default::Default::default(),
                    direction: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiParticleBomb {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiParticleBomb {
            #[inline]
            fn eq(&self, other: &NiParticleBomb) -> bool {
                self.decay == other.decay && self.duration == other.duration
                    && self.delta_v == other.delta_v
                    && self.start_time == other.start_time && self.base == other.base
                    && self.decay_type == other.decay_type
                    && self.symmetry_type == other.symmetry_type
                    && self.position == other.position
                    && self.direction == other.direction
            }
        }
        impl Load for NiParticleBomb {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let decay = stream.load()?;
                let duration = stream.load()?;
                let delta_v = stream.load()?;
                let start_time = stream.load()?;
                let decay_type = stream.load()?;
                let symmetry_type = stream.load()?;
                let position = stream.load()?;
                let direction = stream.load()?;
                Ok(Self {
                    base,
                    decay,
                    duration,
                    delta_v,
                    start_time,
                    decay_type,
                    symmetry_type,
                    position,
                    direction,
                })
            }
        }
        impl Save for NiParticleBomb {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save(&self.decay)?;
                stream.save(&self.duration)?;
                stream.save(&self.delta_v)?;
                stream.save(&self.start_time)?;
                stream.save(&self.decay_type)?;
                stream.save(&self.symmetry_type)?;
                stream.save(&self.position)?;
                stream.save(&self.direction)?;
                Ok(())
            }
        }
    }
    mod niparticlecollider {
        use crate::prelude::*;
        pub struct NiParticleCollider {
            pub base: NiParticleModifier,
            pub bounce: f32,
        }
        impl NiParticleCollider {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiParticleCollider"
            }
        }
        impl Visitor for NiParticleCollider {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.bounce).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiParticleCollider {
            type Target = NiParticleModifier;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiParticleCollider {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiParticleCollider {
            #[inline]
            fn clone(&self) -> NiParticleCollider {
                NiParticleCollider {
                    base: ::core::clone::Clone::clone(&self.base),
                    bounce: ::core::clone::Clone::clone(&self.bounce),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiParticleCollider {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "NiParticleCollider",
                    "base",
                    &self.base,
                    "bounce",
                    &&self.bounce,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiParticleCollider {
            #[inline]
            fn default() -> NiParticleCollider {
                NiParticleCollider {
                    base: ::core::default::Default::default(),
                    bounce: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiParticleCollider {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiParticleCollider {
            #[inline]
            fn eq(&self, other: &NiParticleCollider) -> bool {
                self.bounce == other.bounce && self.base == other.base
            }
        }
        impl Load for NiParticleCollider {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let bounce = stream.load()?;
                Ok(Self { base, bounce })
            }
        }
        impl Save for NiParticleCollider {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save(&self.bounce)?;
                Ok(())
            }
        }
    }
    mod niparticlecolormodifier {
        use crate::prelude::*;
        pub struct NiParticleColorModifier {
            pub base: NiParticleModifier,
            pub color_data: NiLink<NiColorData>,
        }
        impl NiParticleColorModifier {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiParticleColorModifier"
            }
        }
        impl Visitor for NiParticleColorModifier {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.color_data).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiParticleColorModifier {
            type Target = NiParticleModifier;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiParticleColorModifier {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiParticleColorModifier {
            #[inline]
            fn clone(&self) -> NiParticleColorModifier {
                NiParticleColorModifier {
                    base: ::core::clone::Clone::clone(&self.base),
                    color_data: ::core::clone::Clone::clone(&self.color_data),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiParticleColorModifier {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "NiParticleColorModifier",
                    "base",
                    &self.base,
                    "color_data",
                    &&self.color_data,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiParticleColorModifier {
            #[inline]
            fn default() -> NiParticleColorModifier {
                NiParticleColorModifier {
                    base: ::core::default::Default::default(),
                    color_data: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiParticleColorModifier {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiParticleColorModifier {
            #[inline]
            fn eq(&self, other: &NiParticleColorModifier) -> bool {
                self.base == other.base && self.color_data == other.color_data
            }
        }
        impl Load for NiParticleColorModifier {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let color_data = stream.load()?;
                Ok(Self { base, color_data })
            }
        }
        impl Save for NiParticleColorModifier {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save(&self.color_data)?;
                Ok(())
            }
        }
    }
    mod niparticlegrowfade {
        use crate::prelude::*;
        pub struct NiParticleGrowFade {
            pub base: NiParticleModifier,
            pub grow_time: f32,
            pub fade_time: f32,
        }
        impl NiParticleGrowFade {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiParticleGrowFade"
            }
        }
        impl Visitor for NiParticleGrowFade {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.fade_time).visitor(f);
                (&self.grow_time).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiParticleGrowFade {
            type Target = NiParticleModifier;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiParticleGrowFade {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiParticleGrowFade {
            #[inline]
            fn clone(&self) -> NiParticleGrowFade {
                NiParticleGrowFade {
                    base: ::core::clone::Clone::clone(&self.base),
                    grow_time: ::core::clone::Clone::clone(&self.grow_time),
                    fade_time: ::core::clone::Clone::clone(&self.fade_time),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiParticleGrowFade {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "NiParticleGrowFade",
                    "base",
                    &self.base,
                    "grow_time",
                    &self.grow_time,
                    "fade_time",
                    &&self.fade_time,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiParticleGrowFade {
            #[inline]
            fn default() -> NiParticleGrowFade {
                NiParticleGrowFade {
                    base: ::core::default::Default::default(),
                    grow_time: ::core::default::Default::default(),
                    fade_time: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiParticleGrowFade {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiParticleGrowFade {
            #[inline]
            fn eq(&self, other: &NiParticleGrowFade) -> bool {
                self.grow_time == other.grow_time && self.fade_time == other.fade_time
                    && self.base == other.base
            }
        }
        impl Load for NiParticleGrowFade {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let grow_time = stream.load()?;
                let fade_time = stream.load()?;
                Ok(Self { base, grow_time, fade_time })
            }
        }
        impl Save for NiParticleGrowFade {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save(&self.grow_time)?;
                stream.save(&self.fade_time)?;
                Ok(())
            }
        }
    }
    mod niparticlemodifier {
        use crate::prelude::*;
        pub struct NiParticleModifier {
            pub base: NiObject,
            pub next: NiLink<NiParticleModifier>,
            pub controller: NiLink<NiParticleSystemController>,
        }
        impl NiParticleModifier {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiParticleModifier"
            }
        }
        impl Visitor for NiParticleModifier {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.controller).visitor(f);
                (&self.next).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiParticleModifier {
            type Target = NiObject;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiParticleModifier {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiParticleModifier {
            #[inline]
            fn clone(&self) -> NiParticleModifier {
                NiParticleModifier {
                    base: ::core::clone::Clone::clone(&self.base),
                    next: ::core::clone::Clone::clone(&self.next),
                    controller: ::core::clone::Clone::clone(&self.controller),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiParticleModifier {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "NiParticleModifier",
                    "base",
                    &self.base,
                    "next",
                    &self.next,
                    "controller",
                    &&self.controller,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiParticleModifier {
            #[inline]
            fn default() -> NiParticleModifier {
                NiParticleModifier {
                    base: ::core::default::Default::default(),
                    next: ::core::default::Default::default(),
                    controller: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiParticleModifier {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiParticleModifier {
            #[inline]
            fn eq(&self, other: &NiParticleModifier) -> bool {
                self.base == other.base && self.next == other.next
                    && self.controller == other.controller
            }
        }
        impl Load for NiParticleModifier {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let next = stream.load()?;
                let controller = stream.load()?;
                Ok(Self { base, next, controller })
            }
        }
        impl Save for NiParticleModifier {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save(&self.next)?;
                stream.save(&self.controller)?;
                Ok(())
            }
        }
    }
    mod niparticlerotation {
        use crate::prelude::*;
        pub struct NiParticleRotation {
            pub base: NiParticleModifier,
            pub random_initial_axis: bool,
            pub initial_axis: Vec3,
            pub rotation_speed: f32,
        }
        impl NiParticleRotation {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiParticleRotation"
            }
        }
        impl Visitor for NiParticleRotation {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.rotation_speed).visitor(f);
                (&self.initial_axis).visitor(f);
                (&self.random_initial_axis).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiParticleRotation {
            type Target = NiParticleModifier;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiParticleRotation {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiParticleRotation {
            #[inline]
            fn clone(&self) -> NiParticleRotation {
                NiParticleRotation {
                    base: ::core::clone::Clone::clone(&self.base),
                    random_initial_axis: ::core::clone::Clone::clone(
                        &self.random_initial_axis,
                    ),
                    initial_axis: ::core::clone::Clone::clone(&self.initial_axis),
                    rotation_speed: ::core::clone::Clone::clone(&self.rotation_speed),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiParticleRotation {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "NiParticleRotation",
                    "base",
                    &self.base,
                    "random_initial_axis",
                    &self.random_initial_axis,
                    "initial_axis",
                    &self.initial_axis,
                    "rotation_speed",
                    &&self.rotation_speed,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiParticleRotation {
            #[inline]
            fn default() -> NiParticleRotation {
                NiParticleRotation {
                    base: ::core::default::Default::default(),
                    random_initial_axis: ::core::default::Default::default(),
                    initial_axis: ::core::default::Default::default(),
                    rotation_speed: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiParticleRotation {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiParticleRotation {
            #[inline]
            fn eq(&self, other: &NiParticleRotation) -> bool {
                self.random_initial_axis == other.random_initial_axis
                    && self.rotation_speed == other.rotation_speed
                    && self.base == other.base && self.initial_axis == other.initial_axis
            }
        }
        impl Load for NiParticleRotation {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let random_initial_axis = stream.load::<u8>()? != 0;
                let initial_axis = stream.load()?;
                let rotation_speed = stream.load()?;
                Ok(Self {
                    base,
                    random_initial_axis,
                    initial_axis,
                    rotation_speed,
                })
            }
        }
        impl Save for NiParticleRotation {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save_as::<u8>(self.random_initial_axis)?;
                stream.save(&self.initial_axis)?;
                stream.save(&self.rotation_speed)?;
                Ok(())
            }
        }
    }
    mod niparticles {
        use crate::prelude::*;
        pub struct NiParticles {
            pub base: NiGeometry,
        }
        impl NiParticles {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiParticles"
            }
        }
        impl Visitor for NiParticles {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiParticles {
            type Target = NiGeometry;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiParticles {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiParticles {
            #[inline]
            fn clone(&self) -> NiParticles {
                NiParticles {
                    base: ::core::clone::Clone::clone(&self.base),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiParticles {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "NiParticles",
                    "base",
                    &&self.base,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiParticles {
            #[inline]
            fn default() -> NiParticles {
                NiParticles {
                    base: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiParticles {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiParticles {
            #[inline]
            fn eq(&self, other: &NiParticles) -> bool {
                self.base == other.base
            }
        }
        impl Load for NiParticles {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                Ok(Self { base })
            }
        }
        impl Save for NiParticles {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                Ok(())
            }
        }
    }
    mod niparticlesdata {
        use crate::prelude::*;
        pub struct NiParticlesData {
            pub base: NiGeometryData,
            pub num_particles: u16,
            pub particle_radius: f32,
            pub num_active: u16,
            pub sizes: Vec<f32>,
        }
        impl NiParticlesData {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiParticlesData"
            }
        }
        impl Visitor for NiParticlesData {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.sizes).visitor(f);
                (&self.num_active).visitor(f);
                (&self.particle_radius).visitor(f);
                (&self.num_particles).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiParticlesData {
            type Target = NiGeometryData;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiParticlesData {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiParticlesData {
            #[inline]
            fn clone(&self) -> NiParticlesData {
                NiParticlesData {
                    base: ::core::clone::Clone::clone(&self.base),
                    num_particles: ::core::clone::Clone::clone(&self.num_particles),
                    particle_radius: ::core::clone::Clone::clone(&self.particle_radius),
                    num_active: ::core::clone::Clone::clone(&self.num_active),
                    sizes: ::core::clone::Clone::clone(&self.sizes),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiParticlesData {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field5_finish(
                    f,
                    "NiParticlesData",
                    "base",
                    &self.base,
                    "num_particles",
                    &self.num_particles,
                    "particle_radius",
                    &self.particle_radius,
                    "num_active",
                    &self.num_active,
                    "sizes",
                    &&self.sizes,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiParticlesData {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiParticlesData {
            #[inline]
            fn eq(&self, other: &NiParticlesData) -> bool {
                self.num_particles == other.num_particles
                    && self.particle_radius == other.particle_radius
                    && self.num_active == other.num_active && self.base == other.base
                    && self.sizes == other.sizes
            }
        }
        #[automatically_derived]
        impl Default for NiParticlesData {
            /**Return `NiParticlesData {
    base: Default::default(),
    num_particles: Default::default(),
    particle_radius: Default::default(),
    num_active: Default::default(),
    sizes: Default::default()
}`*/
            fn default() -> Self {
                NiParticlesData {
                    base: Default::default(),
                    num_particles: Default::default(),
                    particle_radius: Default::default(),
                    num_active: Default::default(),
                    sizes: Default::default(),
                }
            }
        }
        impl Load for NiParticlesData {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base: NiGeometryData = stream.load()?;
                let num_particles: u16 = stream.load()?;
                let particle_radius = stream.load()?;
                let num_active: u16 = stream.load()?;
                let has_sizes = stream.load::<u32>()? != 0;
                let num_sizes = if has_sizes { base.vertices.len() } else { 0 };
                let sizes = stream.load_vec(num_sizes)?;
                Ok(Self {
                    base,
                    num_particles,
                    particle_radius,
                    num_active,
                    sizes,
                })
            }
        }
        impl Save for NiParticlesData {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save(&self.num_particles)?;
                stream.save(&self.particle_radius)?;
                stream.save(&self.num_active)?;
                stream.save_as::<u32>(!self.sizes.is_empty())?;
                stream.save_vec(&self.sizes)?;
                Ok(())
            }
        }
    }
    mod niparticlesystemcontroller {
        use crate::prelude::*;
        #[allow(clippy::struct_excessive_bools)]
        pub struct NiParticleSystemController {
            pub base: NiTimeController,
            pub speed: f32,
            pub speed_variation: f32,
            pub declination_angle: f32,
            pub declination_variation: f32,
            pub planar_angle: f32,
            pub planar_angle_variation: f32,
            pub initial_normal: Vec3,
            pub initial_color: ColorA,
            pub initial_size: f32,
            pub emit_start_time: f32,
            pub emit_stop_time: f32,
            pub reset_particle_system: bool,
            pub birth_rate: f32,
            pub lifespan: f32,
            pub lifespan_variation: f32,
            pub use_birth_rate: bool,
            pub spawn_on_death: bool,
            pub emitter_width: f32,
            pub emitter_height: f32,
            pub emitter_depth: f32,
            pub emitter: NiLink<NiAVObject>,
            pub spawn_generations: u16,
            pub spawn_percentage: f32,
            pub spawn_multiplier: u16,
            pub spawned_speed_chaos: f32,
            pub spawned_direction_chaos: f32,
            pub particles: Vec<NiPerParticleData>,
            pub num_active_particles: u16,
            pub emitter_modifier: NiLink<NiEmitterModifier>,
            pub particle_modifier: NiLink<NiParticleModifier>,
            pub particle_collider: NiLink<NiParticleCollider>,
            pub compute_dynamic_bounding_volume: bool,
        }
        impl NiParticleSystemController {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiParticleSystemController"
            }
        }
        impl Visitor for NiParticleSystemController {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.compute_dynamic_bounding_volume).visitor(f);
                (&self.particle_collider).visitor(f);
                (&self.particle_modifier).visitor(f);
                (&self.emitter_modifier).visitor(f);
                (&self.num_active_particles).visitor(f);
                (&self.particles).visitor(f);
                (&self.spawned_direction_chaos).visitor(f);
                (&self.spawned_speed_chaos).visitor(f);
                (&self.spawn_multiplier).visitor(f);
                (&self.spawn_percentage).visitor(f);
                (&self.spawn_generations).visitor(f);
                (&self.emitter).visitor(f);
                (&self.emitter_depth).visitor(f);
                (&self.emitter_height).visitor(f);
                (&self.emitter_width).visitor(f);
                (&self.spawn_on_death).visitor(f);
                (&self.use_birth_rate).visitor(f);
                (&self.lifespan_variation).visitor(f);
                (&self.lifespan).visitor(f);
                (&self.birth_rate).visitor(f);
                (&self.reset_particle_system).visitor(f);
                (&self.emit_stop_time).visitor(f);
                (&self.emit_start_time).visitor(f);
                (&self.initial_size).visitor(f);
                (&self.initial_color).visitor(f);
                (&self.initial_normal).visitor(f);
                (&self.planar_angle_variation).visitor(f);
                (&self.planar_angle).visitor(f);
                (&self.declination_variation).visitor(f);
                (&self.declination_angle).visitor(f);
                (&self.speed_variation).visitor(f);
                (&self.speed).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiParticleSystemController {
            type Target = NiTimeController;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiParticleSystemController {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        #[allow(clippy::struct_excessive_bools)]
        impl ::core::clone::Clone for NiParticleSystemController {
            #[inline]
            fn clone(&self) -> NiParticleSystemController {
                NiParticleSystemController {
                    base: ::core::clone::Clone::clone(&self.base),
                    speed: ::core::clone::Clone::clone(&self.speed),
                    speed_variation: ::core::clone::Clone::clone(&self.speed_variation),
                    declination_angle: ::core::clone::Clone::clone(
                        &self.declination_angle,
                    ),
                    declination_variation: ::core::clone::Clone::clone(
                        &self.declination_variation,
                    ),
                    planar_angle: ::core::clone::Clone::clone(&self.planar_angle),
                    planar_angle_variation: ::core::clone::Clone::clone(
                        &self.planar_angle_variation,
                    ),
                    initial_normal: ::core::clone::Clone::clone(&self.initial_normal),
                    initial_color: ::core::clone::Clone::clone(&self.initial_color),
                    initial_size: ::core::clone::Clone::clone(&self.initial_size),
                    emit_start_time: ::core::clone::Clone::clone(&self.emit_start_time),
                    emit_stop_time: ::core::clone::Clone::clone(&self.emit_stop_time),
                    reset_particle_system: ::core::clone::Clone::clone(
                        &self.reset_particle_system,
                    ),
                    birth_rate: ::core::clone::Clone::clone(&self.birth_rate),
                    lifespan: ::core::clone::Clone::clone(&self.lifespan),
                    lifespan_variation: ::core::clone::Clone::clone(
                        &self.lifespan_variation,
                    ),
                    use_birth_rate: ::core::clone::Clone::clone(&self.use_birth_rate),
                    spawn_on_death: ::core::clone::Clone::clone(&self.spawn_on_death),
                    emitter_width: ::core::clone::Clone::clone(&self.emitter_width),
                    emitter_height: ::core::clone::Clone::clone(&self.emitter_height),
                    emitter_depth: ::core::clone::Clone::clone(&self.emitter_depth),
                    emitter: ::core::clone::Clone::clone(&self.emitter),
                    spawn_generations: ::core::clone::Clone::clone(
                        &self.spawn_generations,
                    ),
                    spawn_percentage: ::core::clone::Clone::clone(
                        &self.spawn_percentage,
                    ),
                    spawn_multiplier: ::core::clone::Clone::clone(
                        &self.spawn_multiplier,
                    ),
                    spawned_speed_chaos: ::core::clone::Clone::clone(
                        &self.spawned_speed_chaos,
                    ),
                    spawned_direction_chaos: ::core::clone::Clone::clone(
                        &self.spawned_direction_chaos,
                    ),
                    particles: ::core::clone::Clone::clone(&self.particles),
                    num_active_particles: ::core::clone::Clone::clone(
                        &self.num_active_particles,
                    ),
                    emitter_modifier: ::core::clone::Clone::clone(
                        &self.emitter_modifier,
                    ),
                    particle_modifier: ::core::clone::Clone::clone(
                        &self.particle_modifier,
                    ),
                    particle_collider: ::core::clone::Clone::clone(
                        &self.particle_collider,
                    ),
                    compute_dynamic_bounding_volume: ::core::clone::Clone::clone(
                        &self.compute_dynamic_bounding_volume,
                    ),
                }
            }
        }
        #[automatically_derived]
        #[allow(clippy::struct_excessive_bools)]
        impl ::core::fmt::Debug for NiParticleSystemController {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "base",
                    "speed",
                    "speed_variation",
                    "declination_angle",
                    "declination_variation",
                    "planar_angle",
                    "planar_angle_variation",
                    "initial_normal",
                    "initial_color",
                    "initial_size",
                    "emit_start_time",
                    "emit_stop_time",
                    "reset_particle_system",
                    "birth_rate",
                    "lifespan",
                    "lifespan_variation",
                    "use_birth_rate",
                    "spawn_on_death",
                    "emitter_width",
                    "emitter_height",
                    "emitter_depth",
                    "emitter",
                    "spawn_generations",
                    "spawn_percentage",
                    "spawn_multiplier",
                    "spawned_speed_chaos",
                    "spawned_direction_chaos",
                    "particles",
                    "num_active_particles",
                    "emitter_modifier",
                    "particle_modifier",
                    "particle_collider",
                    "compute_dynamic_bounding_volume",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.base,
                    &self.speed,
                    &self.speed_variation,
                    &self.declination_angle,
                    &self.declination_variation,
                    &self.planar_angle,
                    &self.planar_angle_variation,
                    &self.initial_normal,
                    &self.initial_color,
                    &self.initial_size,
                    &self.emit_start_time,
                    &self.emit_stop_time,
                    &self.reset_particle_system,
                    &self.birth_rate,
                    &self.lifespan,
                    &self.lifespan_variation,
                    &self.use_birth_rate,
                    &self.spawn_on_death,
                    &self.emitter_width,
                    &self.emitter_height,
                    &self.emitter_depth,
                    &self.emitter,
                    &self.spawn_generations,
                    &self.spawn_percentage,
                    &self.spawn_multiplier,
                    &self.spawned_speed_chaos,
                    &self.spawned_direction_chaos,
                    &self.particles,
                    &self.num_active_particles,
                    &self.emitter_modifier,
                    &self.particle_modifier,
                    &self.particle_collider,
                    &&self.compute_dynamic_bounding_volume,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "NiParticleSystemController",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        #[allow(clippy::struct_excessive_bools)]
        impl ::core::default::Default for NiParticleSystemController {
            #[inline]
            fn default() -> NiParticleSystemController {
                NiParticleSystemController {
                    base: ::core::default::Default::default(),
                    speed: ::core::default::Default::default(),
                    speed_variation: ::core::default::Default::default(),
                    declination_angle: ::core::default::Default::default(),
                    declination_variation: ::core::default::Default::default(),
                    planar_angle: ::core::default::Default::default(),
                    planar_angle_variation: ::core::default::Default::default(),
                    initial_normal: ::core::default::Default::default(),
                    initial_color: ::core::default::Default::default(),
                    initial_size: ::core::default::Default::default(),
                    emit_start_time: ::core::default::Default::default(),
                    emit_stop_time: ::core::default::Default::default(),
                    reset_particle_system: ::core::default::Default::default(),
                    birth_rate: ::core::default::Default::default(),
                    lifespan: ::core::default::Default::default(),
                    lifespan_variation: ::core::default::Default::default(),
                    use_birth_rate: ::core::default::Default::default(),
                    spawn_on_death: ::core::default::Default::default(),
                    emitter_width: ::core::default::Default::default(),
                    emitter_height: ::core::default::Default::default(),
                    emitter_depth: ::core::default::Default::default(),
                    emitter: ::core::default::Default::default(),
                    spawn_generations: ::core::default::Default::default(),
                    spawn_percentage: ::core::default::Default::default(),
                    spawn_multiplier: ::core::default::Default::default(),
                    spawned_speed_chaos: ::core::default::Default::default(),
                    spawned_direction_chaos: ::core::default::Default::default(),
                    particles: ::core::default::Default::default(),
                    num_active_particles: ::core::default::Default::default(),
                    emitter_modifier: ::core::default::Default::default(),
                    particle_modifier: ::core::default::Default::default(),
                    particle_collider: ::core::default::Default::default(),
                    compute_dynamic_bounding_volume: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        #[allow(clippy::struct_excessive_bools)]
        impl ::core::marker::StructuralPartialEq for NiParticleSystemController {}
        #[automatically_derived]
        #[allow(clippy::struct_excessive_bools)]
        impl ::core::cmp::PartialEq for NiParticleSystemController {
            #[inline]
            fn eq(&self, other: &NiParticleSystemController) -> bool {
                self.speed == other.speed
                    && self.speed_variation == other.speed_variation
                    && self.declination_angle == other.declination_angle
                    && self.declination_variation == other.declination_variation
                    && self.planar_angle == other.planar_angle
                    && self.planar_angle_variation == other.planar_angle_variation
                    && self.initial_size == other.initial_size
                    && self.emit_start_time == other.emit_start_time
                    && self.emit_stop_time == other.emit_stop_time
                    && self.reset_particle_system == other.reset_particle_system
                    && self.birth_rate == other.birth_rate
                    && self.lifespan == other.lifespan
                    && self.lifespan_variation == other.lifespan_variation
                    && self.use_birth_rate == other.use_birth_rate
                    && self.spawn_on_death == other.spawn_on_death
                    && self.emitter_width == other.emitter_width
                    && self.emitter_height == other.emitter_height
                    && self.emitter_depth == other.emitter_depth
                    && self.spawn_generations == other.spawn_generations
                    && self.spawn_percentage == other.spawn_percentage
                    && self.spawn_multiplier == other.spawn_multiplier
                    && self.spawned_speed_chaos == other.spawned_speed_chaos
                    && self.spawned_direction_chaos == other.spawned_direction_chaos
                    && self.num_active_particles == other.num_active_particles
                    && self.compute_dynamic_bounding_volume
                        == other.compute_dynamic_bounding_volume
                    && self.base == other.base
                    && self.initial_normal == other.initial_normal
                    && self.initial_color == other.initial_color
                    && self.emitter == other.emitter && self.particles == other.particles
                    && self.emitter_modifier == other.emitter_modifier
                    && self.particle_modifier == other.particle_modifier
                    && self.particle_collider == other.particle_collider
            }
        }
        impl Load for NiParticleSystemController {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let speed = stream.load()?;
                let speed_variation = stream.load()?;
                let declination_angle = stream.load()?;
                let declination_variation = stream.load()?;
                let planar_angle = stream.load()?;
                let planar_angle_variation = stream.load()?;
                let initial_normal = stream.load()?;
                let initial_color = stream.load()?;
                let initial_size = stream.load()?;
                let emit_start_time = stream.load()?;
                let emit_stop_time = stream.load()?;
                let reset_particle_system = stream.load::<u8>()? != 0;
                let birth_rate = stream.load()?;
                let lifespan = stream.load()?;
                let lifespan_variation = stream.load()?;
                let use_birth_rate = stream.load::<u8>()? != 0;
                let spawn_on_death = stream.load::<u8>()? != 0;
                let emitter_width = stream.load()?;
                let emitter_height = stream.load()?;
                let emitter_depth = stream.load()?;
                let emitter = stream.load()?;
                let spawn_generations = stream.load()?;
                let spawn_percentage = stream.load()?;
                let spawn_multiplier = stream.load()?;
                let spawned_speed_chaos = stream.load()?;
                let spawned_direction_chaos = stream.load()?;
                let num_particles: u16 = stream.load()?;
                let particles = stream.load_seq(num_particles)?;
                let num_active_particles = stream.load()?;
                let emitter_modifier = stream.load()?;
                let particle_modifier = stream.load()?;
                let particle_collider = stream.load()?;
                let compute_dynamic_bounding_volume = stream.load::<u8>()? != 0;
                Ok(Self {
                    base,
                    speed,
                    speed_variation,
                    declination_angle,
                    declination_variation,
                    planar_angle,
                    planar_angle_variation,
                    initial_normal,
                    initial_color,
                    initial_size,
                    emit_start_time,
                    emit_stop_time,
                    reset_particle_system,
                    birth_rate,
                    lifespan,
                    lifespan_variation,
                    use_birth_rate,
                    spawn_on_death,
                    emitter_width,
                    emitter_height,
                    emitter_depth,
                    emitter,
                    spawn_generations,
                    spawn_percentage,
                    spawn_multiplier,
                    spawned_speed_chaos,
                    spawned_direction_chaos,
                    particles,
                    num_active_particles,
                    emitter_modifier,
                    particle_modifier,
                    particle_collider,
                    compute_dynamic_bounding_volume,
                })
            }
        }
        impl Save for NiParticleSystemController {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save(&self.speed)?;
                stream.save(&self.speed_variation)?;
                stream.save(&self.declination_angle)?;
                stream.save(&self.declination_variation)?;
                stream.save(&self.planar_angle)?;
                stream.save(&self.planar_angle_variation)?;
                stream.save(&self.initial_normal)?;
                stream.save(&self.initial_color)?;
                stream.save(&self.initial_size)?;
                stream.save(&self.emit_start_time)?;
                stream.save(&self.emit_stop_time)?;
                stream.save_as::<u8>(self.reset_particle_system)?;
                stream.save(&self.birth_rate)?;
                stream.save(&self.lifespan)?;
                stream.save(&self.lifespan_variation)?;
                stream.save_as::<u8>(self.use_birth_rate)?;
                stream.save_as::<u8>(self.spawn_on_death)?;
                stream.save(&self.emitter_width)?;
                stream.save(&self.emitter_height)?;
                stream.save(&self.emitter_depth)?;
                stream.save(&self.emitter)?;
                stream.save(&self.spawn_generations)?;
                stream.save(&self.spawn_percentage)?;
                stream.save(&self.spawn_multiplier)?;
                stream.save(&self.spawned_speed_chaos)?;
                stream.save(&self.spawned_direction_chaos)?;
                stream.save_as::<u16>(self.particles.len())?;
                stream.save_seq(&self.particles)?;
                stream.save(&self.num_active_particles)?;
                stream.save(&self.emitter_modifier)?;
                stream.save(&self.particle_modifier)?;
                stream.save(&self.particle_collider)?;
                stream.save_as::<u8>(self.compute_dynamic_bounding_volume)?;
                Ok(())
            }
        }
    }
    mod nipathcontroller {
        use crate::prelude::*;
        pub struct NiPathController {
            pub base: NiTimeController,
            pub bank_direction: BankDirection,
            pub max_bank_angle: f32,
            pub smoothing: f32,
            pub follow_axis: u16,
            pub data: NiLink<NiPosData>,
            pub percentage_data: NiLink<NiFloatData>,
        }
        impl NiPathController {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiPathController"
            }
        }
        impl Visitor for NiPathController {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.percentage_data).visitor(f);
                (&self.data).visitor(f);
                (&self.follow_axis).visitor(f);
                (&self.smoothing).visitor(f);
                (&self.max_bank_angle).visitor(f);
                (&self.bank_direction).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiPathController {
            type Target = NiTimeController;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiPathController {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiPathController {
            #[inline]
            fn clone(&self) -> NiPathController {
                NiPathController {
                    base: ::core::clone::Clone::clone(&self.base),
                    bank_direction: ::core::clone::Clone::clone(&self.bank_direction),
                    max_bank_angle: ::core::clone::Clone::clone(&self.max_bank_angle),
                    smoothing: ::core::clone::Clone::clone(&self.smoothing),
                    follow_axis: ::core::clone::Clone::clone(&self.follow_axis),
                    data: ::core::clone::Clone::clone(&self.data),
                    percentage_data: ::core::clone::Clone::clone(&self.percentage_data),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiPathController {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "base",
                    "bank_direction",
                    "max_bank_angle",
                    "smoothing",
                    "follow_axis",
                    "data",
                    "percentage_data",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.base,
                    &self.bank_direction,
                    &self.max_bank_angle,
                    &self.smoothing,
                    &self.follow_axis,
                    &self.data,
                    &&self.percentage_data,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "NiPathController",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiPathController {
            #[inline]
            fn default() -> NiPathController {
                NiPathController {
                    base: ::core::default::Default::default(),
                    bank_direction: ::core::default::Default::default(),
                    max_bank_angle: ::core::default::Default::default(),
                    smoothing: ::core::default::Default::default(),
                    follow_axis: ::core::default::Default::default(),
                    data: ::core::default::Default::default(),
                    percentage_data: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiPathController {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiPathController {
            #[inline]
            fn eq(&self, other: &NiPathController) -> bool {
                self.max_bank_angle == other.max_bank_angle
                    && self.smoothing == other.smoothing
                    && self.follow_axis == other.follow_axis && self.base == other.base
                    && self.bank_direction == other.bank_direction
                    && self.data == other.data
                    && self.percentage_data == other.percentage_data
            }
        }
        impl Load for NiPathController {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let bank_direction = stream.load()?;
                let max_bank_angle = stream.load()?;
                let smoothing = stream.load()?;
                let follow_axis = stream.load()?;
                let data = stream.load()?;
                let percentage_data = stream.load()?;
                Ok(Self {
                    base,
                    bank_direction,
                    max_bank_angle,
                    smoothing,
                    follow_axis,
                    data,
                    percentage_data,
                })
            }
        }
        impl Save for NiPathController {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save(&self.bank_direction)?;
                stream.save(&self.max_bank_angle)?;
                stream.save(&self.smoothing)?;
                stream.save(&self.follow_axis)?;
                stream.save(&self.data)?;
                stream.save(&self.percentage_data)?;
                Ok(())
            }
        }
    }
    mod niperparticledata {
        use crate::prelude::*;
        pub struct NiPerParticleData {
            pub velocity: Vec3,
            pub rotation_axis: Vec3,
            pub age: f32,
            pub lifespan: f32,
            pub last_update: f32,
            pub generation: u16,
            pub index: u16,
        }
        impl NiPerParticleData {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiPerParticleData"
            }
        }
        impl Visitor for NiPerParticleData {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.index).visitor(f);
                (&self.generation).visitor(f);
                (&self.last_update).visitor(f);
                (&self.lifespan).visitor(f);
                (&self.age).visitor(f);
                (&self.rotation_axis).visitor(f);
                (&self.velocity).visitor(f);
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiPerParticleData {
            #[inline]
            fn clone(&self) -> NiPerParticleData {
                NiPerParticleData {
                    velocity: ::core::clone::Clone::clone(&self.velocity),
                    rotation_axis: ::core::clone::Clone::clone(&self.rotation_axis),
                    age: ::core::clone::Clone::clone(&self.age),
                    lifespan: ::core::clone::Clone::clone(&self.lifespan),
                    last_update: ::core::clone::Clone::clone(&self.last_update),
                    generation: ::core::clone::Clone::clone(&self.generation),
                    index: ::core::clone::Clone::clone(&self.index),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiPerParticleData {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "velocity",
                    "rotation_axis",
                    "age",
                    "lifespan",
                    "last_update",
                    "generation",
                    "index",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.velocity,
                    &self.rotation_axis,
                    &self.age,
                    &self.lifespan,
                    &self.last_update,
                    &self.generation,
                    &&self.index,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "NiPerParticleData",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiPerParticleData {
            #[inline]
            fn default() -> NiPerParticleData {
                NiPerParticleData {
                    velocity: ::core::default::Default::default(),
                    rotation_axis: ::core::default::Default::default(),
                    age: ::core::default::Default::default(),
                    lifespan: ::core::default::Default::default(),
                    last_update: ::core::default::Default::default(),
                    generation: ::core::default::Default::default(),
                    index: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiPerParticleData {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiPerParticleData {
            #[inline]
            fn eq(&self, other: &NiPerParticleData) -> bool {
                self.age == other.age && self.lifespan == other.lifespan
                    && self.last_update == other.last_update
                    && self.generation == other.generation && self.index == other.index
                    && self.velocity == other.velocity
                    && self.rotation_axis == other.rotation_axis
            }
        }
        impl Load for NiPerParticleData {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let velocity = stream.load()?;
                let rotation_axis = stream.load()?;
                let age = stream.load()?;
                let lifespan = stream.load()?;
                let last_update = stream.load()?;
                let generation = stream.load()?;
                let index = stream.load()?;
                Ok(Self {
                    velocity,
                    rotation_axis,
                    age,
                    lifespan,
                    last_update,
                    generation,
                    index,
                })
            }
        }
        impl Save for NiPerParticleData {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.velocity)?;
                stream.save(&self.rotation_axis)?;
                stream.save(&self.age)?;
                stream.save(&self.lifespan)?;
                stream.save(&self.last_update)?;
                stream.save(&self.generation)?;
                stream.save(&self.index)?;
                Ok(())
            }
        }
    }
    mod nipixeldata {
        use crate::prelude::*;
        pub struct NiPixelData {
            pub base: NiObject,
            pub pixel_format: NiPixelFormat,
            pub palette: NiLink<NiPalette>,
            pub pixel_stride: u32,
            pub mipmaps: Vec<[u32; 3]>,
            pub pixel_data: Vec<u8>,
        }
        impl NiPixelData {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiPixelData"
            }
        }
        impl Visitor for NiPixelData {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.pixel_data).visitor(f);
                (&self.mipmaps).visitor(f);
                (&self.pixel_stride).visitor(f);
                (&self.palette).visitor(f);
                (&self.pixel_format).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiPixelData {
            type Target = NiObject;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiPixelData {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiPixelData {
            #[inline]
            fn clone(&self) -> NiPixelData {
                NiPixelData {
                    base: ::core::clone::Clone::clone(&self.base),
                    pixel_format: ::core::clone::Clone::clone(&self.pixel_format),
                    palette: ::core::clone::Clone::clone(&self.palette),
                    pixel_stride: ::core::clone::Clone::clone(&self.pixel_stride),
                    mipmaps: ::core::clone::Clone::clone(&self.mipmaps),
                    pixel_data: ::core::clone::Clone::clone(&self.pixel_data),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiPixelData {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "base",
                    "pixel_format",
                    "palette",
                    "pixel_stride",
                    "mipmaps",
                    "pixel_data",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.base,
                    &self.pixel_format,
                    &self.palette,
                    &self.pixel_stride,
                    &self.mipmaps,
                    &&self.pixel_data,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "NiPixelData",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for NiPixelData {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<NiObject>;
                let _: ::core::cmp::AssertParamIsEq<NiPixelFormat>;
                let _: ::core::cmp::AssertParamIsEq<NiLink<NiPalette>>;
                let _: ::core::cmp::AssertParamIsEq<u32>;
                let _: ::core::cmp::AssertParamIsEq<Vec<[u32; 3]>>;
                let _: ::core::cmp::AssertParamIsEq<Vec<u8>>;
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiPixelData {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiPixelData {
            #[inline]
            fn eq(&self, other: &NiPixelData) -> bool {
                self.pixel_stride == other.pixel_stride && self.base == other.base
                    && self.pixel_format == other.pixel_format
                    && self.palette == other.palette && self.mipmaps == other.mipmaps
                    && self.pixel_data == other.pixel_data
            }
        }
        #[automatically_derived]
        impl Default for NiPixelData {
            /**Return `NiPixelData {
    base: Default::default(),
    pixel_format: Default::default(),
    palette: Default::default(),
    pixel_stride: Default::default(),
    mipmaps: Default::default(),
    pixel_data: Default::default()
}`*/
            fn default() -> Self {
                NiPixelData {
                    base: Default::default(),
                    pixel_format: Default::default(),
                    palette: Default::default(),
                    pixel_stride: Default::default(),
                    mipmaps: Default::default(),
                    pixel_data: Default::default(),
                }
            }
        }
        impl Load for NiPixelData {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let pixel_format = stream.load()?;
                let palette = stream.load()?;
                let num_mipmap_levels: u32 = stream.load()?;
                let pixel_stride = stream.load()?;
                let mipmaps = stream.load_vec(num_mipmap_levels)?;
                let num_pixel_data: u32 = stream.load()?;
                let pixel_data = stream.load_vec(num_pixel_data)?;
                Ok(Self {
                    base,
                    pixel_format,
                    palette,
                    pixel_stride,
                    mipmaps,
                    pixel_data,
                })
            }
        }
        impl Save for NiPixelData {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save(&self.pixel_format)?;
                stream.save(&self.palette)?;
                stream.save_as::<u32>(self.mipmaps.len())?;
                stream.save(&self.pixel_stride)?;
                stream.save_vec(&self.mipmaps)?;
                stream.save_as::<u32>(self.pixel_data.len())?;
                stream.save_vec(&self.pixel_data)?;
                Ok(())
            }
        }
    }
    mod nipixelformat {
        use crate::prelude::*;
        pub struct NiPixelFormat {
            pub pixel_format: PixelFormat,
            pub color_masks: [u32; 4],
            pub bits_per_pixel: u32,
            pub compare_bits: [u8; 8],
        }
        impl NiPixelFormat {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiPixelFormat"
            }
        }
        impl Visitor for NiPixelFormat {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.compare_bits).visitor(f);
                (&self.bits_per_pixel).visitor(f);
                (&self.color_masks).visitor(f);
                (&self.pixel_format).visitor(f);
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiPixelFormat {
            #[inline]
            fn clone(&self) -> NiPixelFormat {
                NiPixelFormat {
                    pixel_format: ::core::clone::Clone::clone(&self.pixel_format),
                    color_masks: ::core::clone::Clone::clone(&self.color_masks),
                    bits_per_pixel: ::core::clone::Clone::clone(&self.bits_per_pixel),
                    compare_bits: ::core::clone::Clone::clone(&self.compare_bits),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiPixelFormat {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "NiPixelFormat",
                    "pixel_format",
                    &self.pixel_format,
                    "color_masks",
                    &self.color_masks,
                    "bits_per_pixel",
                    &self.bits_per_pixel,
                    "compare_bits",
                    &&self.compare_bits,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiPixelFormat {
            #[inline]
            fn default() -> NiPixelFormat {
                NiPixelFormat {
                    pixel_format: ::core::default::Default::default(),
                    color_masks: ::core::default::Default::default(),
                    bits_per_pixel: ::core::default::Default::default(),
                    compare_bits: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for NiPixelFormat {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<PixelFormat>;
                let _: ::core::cmp::AssertParamIsEq<[u32; 4]>;
                let _: ::core::cmp::AssertParamIsEq<u32>;
                let _: ::core::cmp::AssertParamIsEq<[u8; 8]>;
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiPixelFormat {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiPixelFormat {
            #[inline]
            fn eq(&self, other: &NiPixelFormat) -> bool {
                self.bits_per_pixel == other.bits_per_pixel
                    && self.pixel_format == other.pixel_format
                    && self.color_masks == other.color_masks
                    && self.compare_bits == other.compare_bits
            }
        }
        impl Load for NiPixelFormat {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let pixel_format = stream.load()?;
                let color_masks = stream.load()?;
                let bits_per_pixel = stream.load()?;
                let compare_bits = stream.load()?;
                Ok(Self {
                    pixel_format,
                    color_masks,
                    bits_per_pixel,
                    compare_bits,
                })
            }
        }
        impl Save for NiPixelFormat {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.pixel_format)?;
                stream.save(&self.color_masks)?;
                stream.save(&self.bits_per_pixel)?;
                stream.save(&self.compare_bits)?;
                Ok(())
            }
        }
    }
    mod niplanarcollider {
        use crate::prelude::*;
        pub struct NiPlanarCollider {
            pub base: NiParticleCollider,
            pub height: f32,
            pub width: f32,
            pub position: Vec3,
            pub x_axis: Vec3,
            pub y_axis: Vec3,
            pub normal: Vec3,
            pub constant: f32,
        }
        impl NiPlanarCollider {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiPlanarCollider"
            }
        }
        impl Visitor for NiPlanarCollider {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.constant).visitor(f);
                (&self.normal).visitor(f);
                (&self.y_axis).visitor(f);
                (&self.x_axis).visitor(f);
                (&self.position).visitor(f);
                (&self.width).visitor(f);
                (&self.height).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiPlanarCollider {
            type Target = NiParticleCollider;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiPlanarCollider {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiPlanarCollider {
            #[inline]
            fn clone(&self) -> NiPlanarCollider {
                NiPlanarCollider {
                    base: ::core::clone::Clone::clone(&self.base),
                    height: ::core::clone::Clone::clone(&self.height),
                    width: ::core::clone::Clone::clone(&self.width),
                    position: ::core::clone::Clone::clone(&self.position),
                    x_axis: ::core::clone::Clone::clone(&self.x_axis),
                    y_axis: ::core::clone::Clone::clone(&self.y_axis),
                    normal: ::core::clone::Clone::clone(&self.normal),
                    constant: ::core::clone::Clone::clone(&self.constant),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiPlanarCollider {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "base",
                    "height",
                    "width",
                    "position",
                    "x_axis",
                    "y_axis",
                    "normal",
                    "constant",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.base,
                    &self.height,
                    &self.width,
                    &self.position,
                    &self.x_axis,
                    &self.y_axis,
                    &self.normal,
                    &&self.constant,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "NiPlanarCollider",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiPlanarCollider {
            #[inline]
            fn default() -> NiPlanarCollider {
                NiPlanarCollider {
                    base: ::core::default::Default::default(),
                    height: ::core::default::Default::default(),
                    width: ::core::default::Default::default(),
                    position: ::core::default::Default::default(),
                    x_axis: ::core::default::Default::default(),
                    y_axis: ::core::default::Default::default(),
                    normal: ::core::default::Default::default(),
                    constant: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiPlanarCollider {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiPlanarCollider {
            #[inline]
            fn eq(&self, other: &NiPlanarCollider) -> bool {
                self.height == other.height && self.width == other.width
                    && self.constant == other.constant && self.base == other.base
                    && self.position == other.position && self.x_axis == other.x_axis
                    && self.y_axis == other.y_axis && self.normal == other.normal
            }
        }
        impl Load for NiPlanarCollider {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let height = stream.load()?;
                let width = stream.load()?;
                let position = stream.load()?;
                let x_axis = stream.load()?;
                let y_axis = stream.load()?;
                let normal = stream.load()?;
                let constant = stream.load()?;
                Ok(Self {
                    base,
                    height,
                    width,
                    position,
                    x_axis,
                    y_axis,
                    normal,
                    constant,
                })
            }
        }
        impl Save for NiPlanarCollider {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save(&self.height)?;
                stream.save(&self.width)?;
                stream.save(&self.position)?;
                stream.save(&self.x_axis)?;
                stream.save(&self.y_axis)?;
                stream.save(&self.normal)?;
                stream.save(&self.constant)?;
                Ok(())
            }
        }
    }
    mod nipointlight {
        use crate::prelude::*;
        pub struct NiPointLight {
            pub base: NiLight,
            pub constant_attenuation: f32,
            pub linear_attenuation: f32,
            pub quadratic_attenuation: f32,
        }
        impl NiPointLight {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiPointLight"
            }
        }
        impl Visitor for NiPointLight {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.quadratic_attenuation).visitor(f);
                (&self.linear_attenuation).visitor(f);
                (&self.constant_attenuation).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiPointLight {
            type Target = NiLight;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiPointLight {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiPointLight {
            #[inline]
            fn clone(&self) -> NiPointLight {
                NiPointLight {
                    base: ::core::clone::Clone::clone(&self.base),
                    constant_attenuation: ::core::clone::Clone::clone(
                        &self.constant_attenuation,
                    ),
                    linear_attenuation: ::core::clone::Clone::clone(
                        &self.linear_attenuation,
                    ),
                    quadratic_attenuation: ::core::clone::Clone::clone(
                        &self.quadratic_attenuation,
                    ),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiPointLight {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "NiPointLight",
                    "base",
                    &self.base,
                    "constant_attenuation",
                    &self.constant_attenuation,
                    "linear_attenuation",
                    &self.linear_attenuation,
                    "quadratic_attenuation",
                    &&self.quadratic_attenuation,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiPointLight {
            #[inline]
            fn default() -> NiPointLight {
                NiPointLight {
                    base: ::core::default::Default::default(),
                    constant_attenuation: ::core::default::Default::default(),
                    linear_attenuation: ::core::default::Default::default(),
                    quadratic_attenuation: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiPointLight {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiPointLight {
            #[inline]
            fn eq(&self, other: &NiPointLight) -> bool {
                self.constant_attenuation == other.constant_attenuation
                    && self.linear_attenuation == other.linear_attenuation
                    && self.quadratic_attenuation == other.quadratic_attenuation
                    && self.base == other.base
            }
        }
        impl Load for NiPointLight {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let constant_attenuation = stream.load()?;
                let linear_attenuation = stream.load()?;
                let quadratic_attenuation = stream.load()?;
                Ok(Self {
                    base,
                    constant_attenuation,
                    linear_attenuation,
                    quadratic_attenuation,
                })
            }
        }
        impl Save for NiPointLight {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save(&self.constant_attenuation)?;
                stream.save(&self.linear_attenuation)?;
                stream.save(&self.quadratic_attenuation)?;
                Ok(())
            }
        }
    }
    mod niposdata {
        use crate::prelude::*;
        pub struct NiPosData {
            pub base: NiObject,
            pub keys: NiPosKey,
        }
        impl NiPosData {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiPosData"
            }
        }
        impl Visitor for NiPosData {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.keys).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiPosData {
            type Target = NiObject;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiPosData {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiPosData {
            #[inline]
            fn clone(&self) -> NiPosData {
                NiPosData {
                    base: ::core::clone::Clone::clone(&self.base),
                    keys: ::core::clone::Clone::clone(&self.keys),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiPosData {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "NiPosData",
                    "base",
                    &self.base,
                    "keys",
                    &&self.keys,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiPosData {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiPosData {
            #[inline]
            fn eq(&self, other: &NiPosData) -> bool {
                self.base == other.base && self.keys == other.keys
            }
        }
        #[automatically_derived]
        impl Default for NiPosData {
            /**Return `NiPosData {
    base: Default::default(),
    keys: Default::default()
}`*/
            fn default() -> Self {
                NiPosData {
                    base: Default::default(),
                    keys: Default::default(),
                }
            }
        }
        impl Load for NiPosData {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let keys = stream.load()?;
                Ok(Self { base, keys })
            }
        }
        impl Save for NiPosData {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save(&self.keys)?;
                Ok(())
            }
        }
    }
    mod niposkey {
        use bytemuck::cast_slice;
        use crate::prelude::*;
        pub enum NiPosKey {
            #[default]
            LinKey(Vec<NiLinPosKey>),
            BezKey(Vec<NiBezPosKey>),
            TCBKey(Vec<NiTCBPosKey>),
        }
        impl NiPosKey {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiPosKey"
            }
        }
        impl Visitor for NiPosKey {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {}
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiPosKey {
            #[inline]
            fn clone(&self) -> NiPosKey {
                match self {
                    NiPosKey::LinKey(__self_0) => {
                        NiPosKey::LinKey(::core::clone::Clone::clone(__self_0))
                    }
                    NiPosKey::BezKey(__self_0) => {
                        NiPosKey::BezKey(::core::clone::Clone::clone(__self_0))
                    }
                    NiPosKey::TCBKey(__self_0) => {
                        NiPosKey::TCBKey(::core::clone::Clone::clone(__self_0))
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiPosKey {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    NiPosKey::LinKey(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "LinKey",
                            &__self_0,
                        )
                    }
                    NiPosKey::BezKey(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "BezKey",
                            &__self_0,
                        )
                    }
                    NiPosKey::TCBKey(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "TCBKey",
                            &__self_0,
                        )
                    }
                }
            }
        }
        #[allow(unreachable_code)]
        #[automatically_derived]
        impl derive_more::core::convert::From<(Vec<NiLinPosKey>)> for NiPosKey {
            #[inline]
            fn from(value: (Vec<NiLinPosKey>)) -> Self {
                NiPosKey::LinKey(value)
            }
        }
        #[allow(unreachable_code)]
        #[automatically_derived]
        impl derive_more::core::convert::From<(Vec<NiBezPosKey>)> for NiPosKey {
            #[inline]
            fn from(value: (Vec<NiBezPosKey>)) -> Self {
                NiPosKey::BezKey(value)
            }
        }
        #[allow(unreachable_code)]
        #[automatically_derived]
        impl derive_more::core::convert::From<(Vec<NiTCBPosKey>)> for NiPosKey {
            #[inline]
            fn from(value: (Vec<NiTCBPosKey>)) -> Self {
                NiPosKey::TCBKey(value)
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiPosKey {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiPosKey {
            #[inline]
            fn eq(&self, other: &NiPosKey) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
                    && match (self, other) {
                        (NiPosKey::LinKey(__self_0), NiPosKey::LinKey(__arg1_0)) => {
                            __self_0 == __arg1_0
                        }
                        (NiPosKey::BezKey(__self_0), NiPosKey::BezKey(__arg1_0)) => {
                            __self_0 == __arg1_0
                        }
                        (NiPosKey::TCBKey(__self_0), NiPosKey::TCBKey(__arg1_0)) => {
                            __self_0 == __arg1_0
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
            }
        }
        #[automatically_derived]
        impl Default for NiPosKey {
            ///Return `NiPosKey::LinKey(Default::default())`
            fn default() -> Self {
                NiPosKey::LinKey(Default::default())
            }
        }
        #[repr(C)]
        pub struct NiLinPosKey {
            pub time: f32,
            pub value: Vec3,
        }
        impl NiLinPosKey {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiLinPosKey"
            }
        }
        impl Visitor for NiLinPosKey {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.value).visitor(f);
                (&self.time).visitor(f);
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiLinPosKey {
            #[inline]
            fn clone(&self) -> NiLinPosKey {
                let _: ::core::clone::AssertParamIsClone<f32>;
                let _: ::core::clone::AssertParamIsClone<Vec3>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for NiLinPosKey {}
        #[automatically_derived]
        impl ::core::fmt::Debug for NiLinPosKey {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "NiLinPosKey",
                    "time",
                    &self.time,
                    "value",
                    &&self.value,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiLinPosKey {
            #[inline]
            fn default() -> NiLinPosKey {
                NiLinPosKey {
                    time: ::core::default::Default::default(),
                    value: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiLinPosKey {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiLinPosKey {
            #[inline]
            fn eq(&self, other: &NiLinPosKey) -> bool {
                self.time == other.time && self.value == other.value
            }
        }
        const _: () = {
            if !(::core::mem::size_of::<NiLinPosKey>()
                == (::core::mem::size_of::<f32>() + ::core::mem::size_of::<Vec3>()))
            {
                {
                    ::std::rt::begin_panic(
                        "derive(Pod) was applied to a type with padding",
                    );
                }
            }
        };
        const _: fn() = || {
            #[allow(clippy::missing_const_for_fn)]
            #[doc(hidden)]
            fn check() {
                fn assert_impl<T: ::bytemuck::Pod>() {}
                assert_impl::<f32>();
            }
        };
        const _: fn() = || {
            #[allow(clippy::missing_const_for_fn)]
            #[doc(hidden)]
            fn check() {
                fn assert_impl<T: ::bytemuck::Pod>() {}
                assert_impl::<Vec3>();
            }
        };
        unsafe impl ::bytemuck::Pod for NiLinPosKey {}
        const _: fn() = || {
            #[allow(clippy::missing_const_for_fn)]
            #[doc(hidden)]
            fn check() {
                fn assert_impl<T: ::bytemuck::Zeroable>() {}
                assert_impl::<f32>();
            }
        };
        const _: fn() = || {
            #[allow(clippy::missing_const_for_fn)]
            #[doc(hidden)]
            fn check() {
                fn assert_impl<T: ::bytemuck::Zeroable>() {}
                assert_impl::<Vec3>();
            }
        };
        unsafe impl ::bytemuck::Zeroable for NiLinPosKey {}
        #[repr(C)]
        pub struct NiBezPosKey {
            pub time: f32,
            pub value: Vec3,
            pub in_tan: Vec3,
            pub out_tan: Vec3,
        }
        impl NiBezPosKey {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiBezPosKey"
            }
        }
        impl Visitor for NiBezPosKey {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.out_tan).visitor(f);
                (&self.in_tan).visitor(f);
                (&self.value).visitor(f);
                (&self.time).visitor(f);
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiBezPosKey {
            #[inline]
            fn clone(&self) -> NiBezPosKey {
                let _: ::core::clone::AssertParamIsClone<f32>;
                let _: ::core::clone::AssertParamIsClone<Vec3>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for NiBezPosKey {}
        #[automatically_derived]
        impl ::core::fmt::Debug for NiBezPosKey {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "NiBezPosKey",
                    "time",
                    &self.time,
                    "value",
                    &self.value,
                    "in_tan",
                    &self.in_tan,
                    "out_tan",
                    &&self.out_tan,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiBezPosKey {
            #[inline]
            fn default() -> NiBezPosKey {
                NiBezPosKey {
                    time: ::core::default::Default::default(),
                    value: ::core::default::Default::default(),
                    in_tan: ::core::default::Default::default(),
                    out_tan: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiBezPosKey {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiBezPosKey {
            #[inline]
            fn eq(&self, other: &NiBezPosKey) -> bool {
                self.time == other.time && self.value == other.value
                    && self.in_tan == other.in_tan && self.out_tan == other.out_tan
            }
        }
        const _: () = {
            if !(::core::mem::size_of::<NiBezPosKey>()
                == (::core::mem::size_of::<f32>() + ::core::mem::size_of::<Vec3>()
                    + ::core::mem::size_of::<Vec3>() + ::core::mem::size_of::<Vec3>()))
            {
                {
                    ::std::rt::begin_panic(
                        "derive(Pod) was applied to a type with padding",
                    );
                }
            }
        };
        const _: fn() = || {
            #[allow(clippy::missing_const_for_fn)]
            #[doc(hidden)]
            fn check() {
                fn assert_impl<T: ::bytemuck::Pod>() {}
                assert_impl::<f32>();
            }
        };
        const _: fn() = || {
            #[allow(clippy::missing_const_for_fn)]
            #[doc(hidden)]
            fn check() {
                fn assert_impl<T: ::bytemuck::Pod>() {}
                assert_impl::<Vec3>();
            }
        };
        const _: fn() = || {
            #[allow(clippy::missing_const_for_fn)]
            #[doc(hidden)]
            fn check() {
                fn assert_impl<T: ::bytemuck::Pod>() {}
                assert_impl::<Vec3>();
            }
        };
        const _: fn() = || {
            #[allow(clippy::missing_const_for_fn)]
            #[doc(hidden)]
            fn check() {
                fn assert_impl<T: ::bytemuck::Pod>() {}
                assert_impl::<Vec3>();
            }
        };
        unsafe impl ::bytemuck::Pod for NiBezPosKey {}
        const _: fn() = || {
            #[allow(clippy::missing_const_for_fn)]
            #[doc(hidden)]
            fn check() {
                fn assert_impl<T: ::bytemuck::Zeroable>() {}
                assert_impl::<f32>();
            }
        };
        const _: fn() = || {
            #[allow(clippy::missing_const_for_fn)]
            #[doc(hidden)]
            fn check() {
                fn assert_impl<T: ::bytemuck::Zeroable>() {}
                assert_impl::<Vec3>();
            }
        };
        const _: fn() = || {
            #[allow(clippy::missing_const_for_fn)]
            #[doc(hidden)]
            fn check() {
                fn assert_impl<T: ::bytemuck::Zeroable>() {}
                assert_impl::<Vec3>();
            }
        };
        const _: fn() = || {
            #[allow(clippy::missing_const_for_fn)]
            #[doc(hidden)]
            fn check() {
                fn assert_impl<T: ::bytemuck::Zeroable>() {}
                assert_impl::<Vec3>();
            }
        };
        unsafe impl ::bytemuck::Zeroable for NiBezPosKey {}
        #[repr(C)]
        pub struct NiTCBPosKey {
            pub time: f32,
            pub value: Vec3,
            pub tension: f32,
            pub continuity: f32,
            pub bias: f32,
        }
        impl NiTCBPosKey {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiTCBPosKey"
            }
        }
        impl Visitor for NiTCBPosKey {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.bias).visitor(f);
                (&self.continuity).visitor(f);
                (&self.tension).visitor(f);
                (&self.value).visitor(f);
                (&self.time).visitor(f);
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiTCBPosKey {
            #[inline]
            fn clone(&self) -> NiTCBPosKey {
                let _: ::core::clone::AssertParamIsClone<f32>;
                let _: ::core::clone::AssertParamIsClone<Vec3>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for NiTCBPosKey {}
        #[automatically_derived]
        impl ::core::fmt::Debug for NiTCBPosKey {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field5_finish(
                    f,
                    "NiTCBPosKey",
                    "time",
                    &self.time,
                    "value",
                    &self.value,
                    "tension",
                    &self.tension,
                    "continuity",
                    &self.continuity,
                    "bias",
                    &&self.bias,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiTCBPosKey {
            #[inline]
            fn default() -> NiTCBPosKey {
                NiTCBPosKey {
                    time: ::core::default::Default::default(),
                    value: ::core::default::Default::default(),
                    tension: ::core::default::Default::default(),
                    continuity: ::core::default::Default::default(),
                    bias: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiTCBPosKey {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiTCBPosKey {
            #[inline]
            fn eq(&self, other: &NiTCBPosKey) -> bool {
                self.time == other.time && self.tension == other.tension
                    && self.continuity == other.continuity && self.bias == other.bias
                    && self.value == other.value
            }
        }
        const _: () = {
            if !(::core::mem::size_of::<NiTCBPosKey>()
                == (::core::mem::size_of::<f32>() + ::core::mem::size_of::<Vec3>()
                    + ::core::mem::size_of::<f32>() + ::core::mem::size_of::<f32>()
                    + ::core::mem::size_of::<f32>()))
            {
                {
                    ::std::rt::begin_panic(
                        "derive(Pod) was applied to a type with padding",
                    );
                }
            }
        };
        const _: fn() = || {
            #[allow(clippy::missing_const_for_fn)]
            #[doc(hidden)]
            fn check() {
                fn assert_impl<T: ::bytemuck::Pod>() {}
                assert_impl::<f32>();
            }
        };
        const _: fn() = || {
            #[allow(clippy::missing_const_for_fn)]
            #[doc(hidden)]
            fn check() {
                fn assert_impl<T: ::bytemuck::Pod>() {}
                assert_impl::<Vec3>();
            }
        };
        const _: fn() = || {
            #[allow(clippy::missing_const_for_fn)]
            #[doc(hidden)]
            fn check() {
                fn assert_impl<T: ::bytemuck::Pod>() {}
                assert_impl::<f32>();
            }
        };
        const _: fn() = || {
            #[allow(clippy::missing_const_for_fn)]
            #[doc(hidden)]
            fn check() {
                fn assert_impl<T: ::bytemuck::Pod>() {}
                assert_impl::<f32>();
            }
        };
        const _: fn() = || {
            #[allow(clippy::missing_const_for_fn)]
            #[doc(hidden)]
            fn check() {
                fn assert_impl<T: ::bytemuck::Pod>() {}
                assert_impl::<f32>();
            }
        };
        unsafe impl ::bytemuck::Pod for NiTCBPosKey {}
        const _: fn() = || {
            #[allow(clippy::missing_const_for_fn)]
            #[doc(hidden)]
            fn check() {
                fn assert_impl<T: ::bytemuck::Zeroable>() {}
                assert_impl::<f32>();
            }
        };
        const _: fn() = || {
            #[allow(clippy::missing_const_for_fn)]
            #[doc(hidden)]
            fn check() {
                fn assert_impl<T: ::bytemuck::Zeroable>() {}
                assert_impl::<Vec3>();
            }
        };
        const _: fn() = || {
            #[allow(clippy::missing_const_for_fn)]
            #[doc(hidden)]
            fn check() {
                fn assert_impl<T: ::bytemuck::Zeroable>() {}
                assert_impl::<f32>();
            }
        };
        const _: fn() = || {
            #[allow(clippy::missing_const_for_fn)]
            #[doc(hidden)]
            fn check() {
                fn assert_impl<T: ::bytemuck::Zeroable>() {}
                assert_impl::<f32>();
            }
        };
        const _: fn() = || {
            #[allow(clippy::missing_const_for_fn)]
            #[doc(hidden)]
            fn check() {
                fn assert_impl<T: ::bytemuck::Zeroable>() {}
                assert_impl::<f32>();
            }
        };
        unsafe impl ::bytemuck::Zeroable for NiTCBPosKey {}
        impl Load for NiPosKey {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let num_keys: u32 = stream.load()?;
                let key_type = if num_keys == 0 {
                    KeyType::LinKey
                } else {
                    stream.load()?
                };
                Ok(
                    match key_type {
                        KeyType::LinKey => NiPosKey::LinKey(stream.load_vec(num_keys)?),
                        KeyType::BezKey => NiPosKey::BezKey(stream.load_vec(num_keys)?),
                        KeyType::TCBKey => NiPosKey::TCBKey(stream.load_vec(num_keys)?),
                        _ => {
                            Reader::error(
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!("Invalid KeyType: {0:?}", key_type),
                                    )
                                }),
                            )?
                        }
                    },
                )
            }
        }
        impl Save for NiPosKey {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                let (len, key_type, bytes) = match self {
                    NiPosKey::LinKey(keys) => {
                        (keys.len(), KeyType::LinKey, cast_slice(keys))
                    }
                    NiPosKey::BezKey(keys) => {
                        (keys.len(), KeyType::BezKey, cast_slice(keys))
                    }
                    NiPosKey::TCBKey(keys) => {
                        (keys.len(), KeyType::TCBKey, cast_slice(keys))
                    }
                };
                stream.save_as::<u32>(len)?;
                if !bytes.is_empty() {
                    stream.save(&key_type)?;
                    stream.save_bytes(bytes)?;
                }
                Ok(())
            }
        }
    }
    mod niproperty {
        use crate::prelude::*;
        pub struct NiProperty {
            pub base: NiObjectNET,
            pub flags: u16,
        }
        impl NiProperty {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiProperty"
            }
        }
        impl Visitor for NiProperty {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.flags).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiProperty {
            type Target = NiObjectNET;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiProperty {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiProperty {
            #[inline]
            fn clone(&self) -> NiProperty {
                NiProperty {
                    base: ::core::clone::Clone::clone(&self.base),
                    flags: ::core::clone::Clone::clone(&self.flags),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiProperty {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "NiProperty",
                    "base",
                    &self.base,
                    "flags",
                    &&self.flags,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiProperty {
            #[inline]
            fn default() -> NiProperty {
                NiProperty {
                    base: ::core::default::Default::default(),
                    flags: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiProperty {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiProperty {
            #[inline]
            fn eq(&self, other: &NiProperty) -> bool {
                self.flags == other.flags && self.base == other.base
            }
        }
        impl Load for NiProperty {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let flags = stream.load()?;
                Ok(Self { base, flags })
            }
        }
        impl Save for NiProperty {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save(&self.flags)?;
                Ok(())
            }
        }
    }
    mod nirenderedcubemap {
        use crate::prelude::*;
        pub struct NiRenderedCubeMap {
            pub base: NiRenderedTexture,
        }
        impl NiRenderedCubeMap {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiRenderedCubeMap"
            }
        }
        impl Visitor for NiRenderedCubeMap {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiRenderedCubeMap {
            type Target = NiRenderedTexture;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiRenderedCubeMap {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiRenderedCubeMap {
            #[inline]
            fn clone(&self) -> NiRenderedCubeMap {
                NiRenderedCubeMap {
                    base: ::core::clone::Clone::clone(&self.base),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiRenderedCubeMap {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "NiRenderedCubeMap",
                    "base",
                    &&self.base,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiRenderedCubeMap {
            #[inline]
            fn default() -> NiRenderedCubeMap {
                NiRenderedCubeMap {
                    base: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiRenderedCubeMap {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiRenderedCubeMap {
            #[inline]
            fn eq(&self, other: &NiRenderedCubeMap) -> bool {
                self.base == other.base
            }
        }
        impl Load for NiRenderedCubeMap {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                Ok(Self { base })
            }
        }
        impl Save for NiRenderedCubeMap {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                Ok(())
            }
        }
    }
    mod nirenderedtexture {
        use crate::prelude::*;
        pub struct NiRenderedTexture {
            pub base: NiTexture,
        }
        impl NiRenderedTexture {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiRenderedTexture"
            }
        }
        impl Visitor for NiRenderedTexture {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiRenderedTexture {
            type Target = NiTexture;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiRenderedTexture {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiRenderedTexture {
            #[inline]
            fn clone(&self) -> NiRenderedTexture {
                NiRenderedTexture {
                    base: ::core::clone::Clone::clone(&self.base),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiRenderedTexture {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "NiRenderedTexture",
                    "base",
                    &&self.base,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiRenderedTexture {
            #[inline]
            fn default() -> NiRenderedTexture {
                NiRenderedTexture {
                    base: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiRenderedTexture {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiRenderedTexture {
            #[inline]
            fn eq(&self, other: &NiRenderedTexture) -> bool {
                self.base == other.base
            }
        }
        impl Load for NiRenderedTexture {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                Ok(Self { base })
            }
        }
        impl Save for NiRenderedTexture {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                Ok(())
            }
        }
    }
    mod nirenderer {
        use crate::prelude::*;
        pub struct NiRenderer {
            pub base: NiObject,
        }
        impl NiRenderer {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiRenderer"
            }
        }
        impl Visitor for NiRenderer {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiRenderer {
            type Target = NiObject;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiRenderer {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiRenderer {
            #[inline]
            fn clone(&self) -> NiRenderer {
                NiRenderer {
                    base: ::core::clone::Clone::clone(&self.base),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiRenderer {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "NiRenderer",
                    "base",
                    &&self.base,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiRenderer {
            #[inline]
            fn default() -> NiRenderer {
                NiRenderer {
                    base: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for NiRenderer {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<NiObject>;
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiRenderer {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiRenderer {
            #[inline]
            fn eq(&self, other: &NiRenderer) -> bool {
                self.base == other.base
            }
        }
        impl Load for NiRenderer {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                Ok(Self { base })
            }
        }
        impl Save for NiRenderer {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                Ok(())
            }
        }
    }
    mod nirollcontroller {
        use crate::prelude::*;
        pub struct NiRollController {
            pub base: NiFloatController,
        }
        impl NiRollController {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiRollController"
            }
        }
        impl Visitor for NiRollController {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiRollController {
            type Target = NiFloatController;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiRollController {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiRollController {
            #[inline]
            fn clone(&self) -> NiRollController {
                NiRollController {
                    base: ::core::clone::Clone::clone(&self.base),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiRollController {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "NiRollController",
                    "base",
                    &&self.base,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiRollController {
            #[inline]
            fn default() -> NiRollController {
                NiRollController {
                    base: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiRollController {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiRollController {
            #[inline]
            fn eq(&self, other: &NiRollController) -> bool {
                self.base == other.base
            }
        }
        impl Load for NiRollController {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                Ok(Self { base })
            }
        }
        impl Save for NiRollController {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                Ok(())
            }
        }
    }
    mod nirotatingparticles {
        use crate::prelude::*;
        pub struct NiRotatingParticles {
            pub base: NiParticles,
        }
        impl NiRotatingParticles {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiRotatingParticles"
            }
        }
        impl Visitor for NiRotatingParticles {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiRotatingParticles {
            type Target = NiParticles;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiRotatingParticles {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiRotatingParticles {
            #[inline]
            fn clone(&self) -> NiRotatingParticles {
                NiRotatingParticles {
                    base: ::core::clone::Clone::clone(&self.base),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiRotatingParticles {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "NiRotatingParticles",
                    "base",
                    &&self.base,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiRotatingParticles {
            #[inline]
            fn default() -> NiRotatingParticles {
                NiRotatingParticles {
                    base: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiRotatingParticles {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiRotatingParticles {
            #[inline]
            fn eq(&self, other: &NiRotatingParticles) -> bool {
                self.base == other.base
            }
        }
        impl Load for NiRotatingParticles {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                Ok(Self { base })
            }
        }
        impl Save for NiRotatingParticles {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                Ok(())
            }
        }
    }
    mod nirotatingparticlesdata {
        use crate::prelude::*;
        pub struct NiRotatingParticlesData {
            pub base: NiParticlesData,
            pub rotations: Vec<Quat>,
        }
        impl NiRotatingParticlesData {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiRotatingParticlesData"
            }
        }
        impl Visitor for NiRotatingParticlesData {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.rotations).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiRotatingParticlesData {
            type Target = NiParticlesData;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiRotatingParticlesData {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiRotatingParticlesData {
            #[inline]
            fn clone(&self) -> NiRotatingParticlesData {
                NiRotatingParticlesData {
                    base: ::core::clone::Clone::clone(&self.base),
                    rotations: ::core::clone::Clone::clone(&self.rotations),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiRotatingParticlesData {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "NiRotatingParticlesData",
                    "base",
                    &self.base,
                    "rotations",
                    &&self.rotations,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiRotatingParticlesData {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiRotatingParticlesData {
            #[inline]
            fn eq(&self, other: &NiRotatingParticlesData) -> bool {
                self.base == other.base && self.rotations == other.rotations
            }
        }
        #[automatically_derived]
        impl Default for NiRotatingParticlesData {
            /**Return `NiRotatingParticlesData {
    base: Default::default(),
    rotations: Default::default()
}`*/
            fn default() -> Self {
                NiRotatingParticlesData {
                    base: Default::default(),
                    rotations: Default::default(),
                }
            }
        }
        impl Load for NiRotatingParticlesData {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base: NiParticlesData = stream.load()?;
                let has_rotations = stream.load::<u32>()? != 0;
                let num_rotations = if has_rotations { base.vertices.len() } else { 0 };
                let rotations = stream.load_seq(num_rotations)?;
                Ok(Self { base, rotations })
            }
        }
        impl Save for NiRotatingParticlesData {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save_as::<u32>(!self.rotations.is_empty())?;
                stream.save_seq(&self.rotations)?;
                Ok(())
            }
        }
    }
    mod nirotdata {
        use crate::prelude::*;
        pub struct NiRotData {
            pub base: NiObject,
            pub keys: NiRotKey,
        }
        impl NiRotData {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiRotData"
            }
        }
        impl Visitor for NiRotData {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.keys).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiRotData {
            type Target = NiObject;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiRotData {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiRotData {
            #[inline]
            fn clone(&self) -> NiRotData {
                NiRotData {
                    base: ::core::clone::Clone::clone(&self.base),
                    keys: ::core::clone::Clone::clone(&self.keys),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiRotData {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "NiRotData",
                    "base",
                    &self.base,
                    "keys",
                    &&self.keys,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiRotData {
            #[inline]
            fn default() -> NiRotData {
                NiRotData {
                    base: ::core::default::Default::default(),
                    keys: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiRotData {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiRotData {
            #[inline]
            fn eq(&self, other: &NiRotData) -> bool {
                self.base == other.base && self.keys == other.keys
            }
        }
        impl Load for NiRotData {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let keys = stream.load()?;
                Ok(Self { base, keys })
            }
        }
        impl Save for NiRotData {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save(&self.keys)?;
                Ok(())
            }
        }
    }
    mod nirotkey {
        use crate::prelude::*;
        pub enum NiRotKey {
            #[default]
            LinKey(Vec<NiLinRotKey>),
            BezKey(Vec<NiBezRotKey>),
            TCBKey(Vec<NiTCBRotKey>),
            EulerKey(NiEulerRotKeys),
        }
        impl NiRotKey {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiRotKey"
            }
        }
        impl Visitor for NiRotKey {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {}
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiRotKey {
            #[inline]
            fn clone(&self) -> NiRotKey {
                match self {
                    NiRotKey::LinKey(__self_0) => {
                        NiRotKey::LinKey(::core::clone::Clone::clone(__self_0))
                    }
                    NiRotKey::BezKey(__self_0) => {
                        NiRotKey::BezKey(::core::clone::Clone::clone(__self_0))
                    }
                    NiRotKey::TCBKey(__self_0) => {
                        NiRotKey::TCBKey(::core::clone::Clone::clone(__self_0))
                    }
                    NiRotKey::EulerKey(__self_0) => {
                        NiRotKey::EulerKey(::core::clone::Clone::clone(__self_0))
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiRotKey {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    NiRotKey::LinKey(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "LinKey",
                            &__self_0,
                        )
                    }
                    NiRotKey::BezKey(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "BezKey",
                            &__self_0,
                        )
                    }
                    NiRotKey::TCBKey(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "TCBKey",
                            &__self_0,
                        )
                    }
                    NiRotKey::EulerKey(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "EulerKey",
                            &__self_0,
                        )
                    }
                }
            }
        }
        #[allow(unreachable_code)]
        #[automatically_derived]
        impl derive_more::core::convert::From<(Vec<NiLinRotKey>)> for NiRotKey {
            #[inline]
            fn from(value: (Vec<NiLinRotKey>)) -> Self {
                NiRotKey::LinKey(value)
            }
        }
        #[allow(unreachable_code)]
        #[automatically_derived]
        impl derive_more::core::convert::From<(Vec<NiBezRotKey>)> for NiRotKey {
            #[inline]
            fn from(value: (Vec<NiBezRotKey>)) -> Self {
                NiRotKey::BezKey(value)
            }
        }
        #[allow(unreachable_code)]
        #[automatically_derived]
        impl derive_more::core::convert::From<(Vec<NiTCBRotKey>)> for NiRotKey {
            #[inline]
            fn from(value: (Vec<NiTCBRotKey>)) -> Self {
                NiRotKey::TCBKey(value)
            }
        }
        #[allow(unreachable_code)]
        #[automatically_derived]
        impl derive_more::core::convert::From<(NiEulerRotKeys)> for NiRotKey {
            #[inline]
            fn from(value: (NiEulerRotKeys)) -> Self {
                NiRotKey::EulerKey(value)
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiRotKey {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiRotKey {
            #[inline]
            fn eq(&self, other: &NiRotKey) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
                    && match (self, other) {
                        (NiRotKey::LinKey(__self_0), NiRotKey::LinKey(__arg1_0)) => {
                            __self_0 == __arg1_0
                        }
                        (NiRotKey::BezKey(__self_0), NiRotKey::BezKey(__arg1_0)) => {
                            __self_0 == __arg1_0
                        }
                        (NiRotKey::TCBKey(__self_0), NiRotKey::TCBKey(__arg1_0)) => {
                            __self_0 == __arg1_0
                        }
                        (NiRotKey::EulerKey(__self_0), NiRotKey::EulerKey(__arg1_0)) => {
                            __self_0 == __arg1_0
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
            }
        }
        #[automatically_derived]
        impl Default for NiRotKey {
            ///Return `NiRotKey::LinKey(Default::default())`
            fn default() -> Self {
                NiRotKey::LinKey(Default::default())
            }
        }
        pub struct NiLinRotKey {
            pub time: f32,
            #[default(Quat::IDENTITY)]
            pub value: Quat,
        }
        impl NiLinRotKey {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiLinRotKey"
            }
        }
        impl Visitor for NiLinRotKey {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.value).visitor(f);
                (&self.time).visitor(f);
            }
        }
        const _: () = {
            use crate::prelude::*;
            impl Load for NiLinRotKey {
                fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                    Ok(Self {
                        time: stream.load()?,
                        value: stream.load()?,
                    })
                }
            }
            impl Save for NiLinRotKey {
                fn save(&self, stream: &mut Writer) -> io::Result<()> {
                    stream.save(&self.time)?;
                    stream.save(&self.value)?;
                    Ok(())
                }
            }
        };
        #[automatically_derived]
        impl ::core::clone::Clone for NiLinRotKey {
            #[inline]
            fn clone(&self) -> NiLinRotKey {
                let _: ::core::clone::AssertParamIsClone<f32>;
                let _: ::core::clone::AssertParamIsClone<Quat>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for NiLinRotKey {}
        #[automatically_derived]
        impl ::core::fmt::Debug for NiLinRotKey {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "NiLinRotKey",
                    "time",
                    &self.time,
                    "value",
                    &&self.value,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiLinRotKey {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiLinRotKey {
            #[inline]
            fn eq(&self, other: &NiLinRotKey) -> bool {
                self.time == other.time && self.value == other.value
            }
        }
        #[automatically_derived]
        impl Default for NiLinRotKey {
            /**Return `NiLinRotKey {
    time: Default::default(),
    value: Quat::IDENTITY
}`*/
            fn default() -> Self {
                NiLinRotKey {
                    time: Default::default(),
                    value: Quat::IDENTITY,
                }
            }
        }
        const _: fn() = || {
            #[allow(clippy::missing_const_for_fn)]
            #[doc(hidden)]
            fn check() {
                fn assert_impl<T: ::bytemuck::Zeroable>() {}
                assert_impl::<f32>();
            }
        };
        const _: fn() = || {
            #[allow(clippy::missing_const_for_fn)]
            #[doc(hidden)]
            fn check() {
                fn assert_impl<T: ::bytemuck::Zeroable>() {}
                assert_impl::<Quat>();
            }
        };
        unsafe impl ::bytemuck::Zeroable for NiLinRotKey {}
        pub struct NiBezRotKey {
            pub time: f32,
            #[default(Quat::IDENTITY)]
            pub value: Quat,
        }
        impl NiBezRotKey {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiBezRotKey"
            }
        }
        impl Visitor for NiBezRotKey {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.value).visitor(f);
                (&self.time).visitor(f);
            }
        }
        const _: () = {
            use crate::prelude::*;
            impl Load for NiBezRotKey {
                fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                    Ok(Self {
                        time: stream.load()?,
                        value: stream.load()?,
                    })
                }
            }
            impl Save for NiBezRotKey {
                fn save(&self, stream: &mut Writer) -> io::Result<()> {
                    stream.save(&self.time)?;
                    stream.save(&self.value)?;
                    Ok(())
                }
            }
        };
        #[automatically_derived]
        impl ::core::clone::Clone for NiBezRotKey {
            #[inline]
            fn clone(&self) -> NiBezRotKey {
                let _: ::core::clone::AssertParamIsClone<f32>;
                let _: ::core::clone::AssertParamIsClone<Quat>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for NiBezRotKey {}
        #[automatically_derived]
        impl ::core::fmt::Debug for NiBezRotKey {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "NiBezRotKey",
                    "time",
                    &self.time,
                    "value",
                    &&self.value,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiBezRotKey {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiBezRotKey {
            #[inline]
            fn eq(&self, other: &NiBezRotKey) -> bool {
                self.time == other.time && self.value == other.value
            }
        }
        #[automatically_derived]
        impl Default for NiBezRotKey {
            /**Return `NiBezRotKey {
    time: Default::default(),
    value: Quat::IDENTITY
}`*/
            fn default() -> Self {
                NiBezRotKey {
                    time: Default::default(),
                    value: Quat::IDENTITY,
                }
            }
        }
        const _: fn() = || {
            #[allow(clippy::missing_const_for_fn)]
            #[doc(hidden)]
            fn check() {
                fn assert_impl<T: ::bytemuck::Zeroable>() {}
                assert_impl::<f32>();
            }
        };
        const _: fn() = || {
            #[allow(clippy::missing_const_for_fn)]
            #[doc(hidden)]
            fn check() {
                fn assert_impl<T: ::bytemuck::Zeroable>() {}
                assert_impl::<Quat>();
            }
        };
        unsafe impl ::bytemuck::Zeroable for NiBezRotKey {}
        pub struct NiTCBRotKey {
            pub time: f32,
            #[default(Quat::IDENTITY)]
            pub value: Quat,
            pub tension: f32,
            pub continuity: f32,
            pub bias: f32,
        }
        impl NiTCBRotKey {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiTCBRotKey"
            }
        }
        impl Visitor for NiTCBRotKey {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.bias).visitor(f);
                (&self.continuity).visitor(f);
                (&self.tension).visitor(f);
                (&self.value).visitor(f);
                (&self.time).visitor(f);
            }
        }
        const _: () = {
            use crate::prelude::*;
            impl Load for NiTCBRotKey {
                fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                    Ok(Self {
                        time: stream.load()?,
                        value: stream.load()?,
                        tension: stream.load()?,
                        continuity: stream.load()?,
                        bias: stream.load()?,
                    })
                }
            }
            impl Save for NiTCBRotKey {
                fn save(&self, stream: &mut Writer) -> io::Result<()> {
                    stream.save(&self.time)?;
                    stream.save(&self.value)?;
                    stream.save(&self.tension)?;
                    stream.save(&self.continuity)?;
                    stream.save(&self.bias)?;
                    Ok(())
                }
            }
        };
        #[automatically_derived]
        impl ::core::clone::Clone for NiTCBRotKey {
            #[inline]
            fn clone(&self) -> NiTCBRotKey {
                let _: ::core::clone::AssertParamIsClone<f32>;
                let _: ::core::clone::AssertParamIsClone<Quat>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for NiTCBRotKey {}
        #[automatically_derived]
        impl ::core::fmt::Debug for NiTCBRotKey {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field5_finish(
                    f,
                    "NiTCBRotKey",
                    "time",
                    &self.time,
                    "value",
                    &self.value,
                    "tension",
                    &self.tension,
                    "continuity",
                    &self.continuity,
                    "bias",
                    &&self.bias,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiTCBRotKey {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiTCBRotKey {
            #[inline]
            fn eq(&self, other: &NiTCBRotKey) -> bool {
                self.time == other.time && self.tension == other.tension
                    && self.continuity == other.continuity && self.bias == other.bias
                    && self.value == other.value
            }
        }
        #[automatically_derived]
        impl Default for NiTCBRotKey {
            /**Return `NiTCBRotKey {
    time: Default::default(),
    value: Quat::IDENTITY,
    tension: Default::default(),
    continuity: Default::default(),
    bias: Default::default()
}`*/
            fn default() -> Self {
                NiTCBRotKey {
                    time: Default::default(),
                    value: Quat::IDENTITY,
                    tension: Default::default(),
                    continuity: Default::default(),
                    bias: Default::default(),
                }
            }
        }
        const _: fn() = || {
            #[allow(clippy::missing_const_for_fn)]
            #[doc(hidden)]
            fn check() {
                fn assert_impl<T: ::bytemuck::Zeroable>() {}
                assert_impl::<f32>();
            }
        };
        const _: fn() = || {
            #[allow(clippy::missing_const_for_fn)]
            #[doc(hidden)]
            fn check() {
                fn assert_impl<T: ::bytemuck::Zeroable>() {}
                assert_impl::<Quat>();
            }
        };
        const _: fn() = || {
            #[allow(clippy::missing_const_for_fn)]
            #[doc(hidden)]
            fn check() {
                fn assert_impl<T: ::bytemuck::Zeroable>() {}
                assert_impl::<f32>();
            }
        };
        const _: fn() = || {
            #[allow(clippy::missing_const_for_fn)]
            #[doc(hidden)]
            fn check() {
                fn assert_impl<T: ::bytemuck::Zeroable>() {}
                assert_impl::<f32>();
            }
        };
        const _: fn() = || {
            #[allow(clippy::missing_const_for_fn)]
            #[doc(hidden)]
            fn check() {
                fn assert_impl<T: ::bytemuck::Zeroable>() {}
                assert_impl::<f32>();
            }
        };
        unsafe impl ::bytemuck::Zeroable for NiTCBRotKey {}
        pub struct NiEulerRotKeys {
            pub axis_order: AxisOrder,
            pub axes: [NiFloatData; 3],
        }
        impl NiEulerRotKeys {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiEulerRotKeys"
            }
        }
        impl Visitor for NiEulerRotKeys {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.axes).visitor(f);
                (&self.axis_order).visitor(f);
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiEulerRotKeys {
            #[inline]
            fn clone(&self) -> NiEulerRotKeys {
                NiEulerRotKeys {
                    axis_order: ::core::clone::Clone::clone(&self.axis_order),
                    axes: ::core::clone::Clone::clone(&self.axes),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiEulerRotKeys {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "NiEulerRotKeys",
                    "axis_order",
                    &self.axis_order,
                    "axes",
                    &&self.axes,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiEulerRotKeys {
            #[inline]
            fn default() -> NiEulerRotKeys {
                NiEulerRotKeys {
                    axis_order: ::core::default::Default::default(),
                    axes: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiEulerRotKeys {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiEulerRotKeys {
            #[inline]
            fn eq(&self, other: &NiEulerRotKeys) -> bool {
                self.axis_order == other.axis_order && self.axes == other.axes
            }
        }
        impl Load for NiRotKey {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let num_keys: u32 = stream.load()?;
                let key_type = if num_keys == 0 {
                    KeyType::LinKey
                } else {
                    stream.load()?
                };
                Ok(
                    match key_type {
                        KeyType::LinKey => NiRotKey::LinKey(stream.load_seq(num_keys)?),
                        KeyType::BezKey => NiRotKey::BezKey(stream.load_seq(num_keys)?),
                        KeyType::TCBKey => NiRotKey::TCBKey(stream.load_seq(num_keys)?),
                        KeyType::EulerKey => NiRotKey::EulerKey(stream.load()?),
                        _ => {
                            Reader::error(
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!("Invalid KeyType: {0:?}", key_type),
                                    )
                                }),
                            )?
                        }
                    },
                )
            }
        }
        impl Save for NiRotKey {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                /// Helper function to reduce code duplication in the match statement below.
                #[inline]
                fn save<'a, I, S>(
                    stream: &mut Writer,
                    len: usize,
                    key_type: KeyType,
                    keys: I,
                ) -> io::Result<()>
                where
                    I: IntoIterator<Item = &'a S>,
                    S: Save + 'a,
                {
                    stream.save_as::<u32>(len)?;
                    if len != 0 {
                        stream.save(&key_type)?;
                        stream.save_seq(keys)?;
                    }
                    Ok(())
                }
                match self {
                    NiRotKey::LinKey(keys) => {
                        save(stream, keys.len(), KeyType::LinKey, keys)
                    }
                    NiRotKey::BezKey(keys) => {
                        save(stream, keys.len(), KeyType::BezKey, keys)
                    }
                    NiRotKey::TCBKey(keys) => {
                        save(stream, keys.len(), KeyType::TCBKey, keys)
                    }
                    NiRotKey::EulerKey(keys) => {
                        save(stream, keys.len().min(1), KeyType::EulerKey, [keys])
                    }
                }
            }
        }
        impl NiEulerRotKeys {
            #[allow(clippy::len_without_is_empty)]
            pub fn len(&self) -> usize {
                self.axes
                    .iter()
                    .map(|axis| match &axis.keys {
                        NiFloatKey::LinKey(keys) => keys.len(),
                        NiFloatKey::BezKey(keys) => keys.len(),
                        NiFloatKey::TCBKey(keys) => keys.len(),
                    })
                    .max()
                    .unwrap_or(0)
            }
        }
        impl Load for NiEulerRotKeys {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let axis_order = stream.load()?;
                let axes = [stream.load()?, stream.load()?, stream.load()?];
                Ok(Self { axis_order, axes })
            }
        }
        impl Save for NiEulerRotKeys {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.axis_order)?;
                stream.save_seq(&self.axes)?;
                Ok(())
            }
        }
    }
    mod niscreenpolygon {
        use crate::prelude::*;
        pub struct NiScreenPolygon {
            pub base: NiObject,
            pub vertices: Vec<Vec3>,
            pub uv_coords: Vec<Vec2>,
            pub vertex_colors: Vec<ColorA>,
            pub property_states: Vec<i32>,
        }
        impl NiScreenPolygon {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiScreenPolygon"
            }
        }
        impl Visitor for NiScreenPolygon {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.property_states).visitor(f);
                (&self.vertex_colors).visitor(f);
                (&self.uv_coords).visitor(f);
                (&self.vertices).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiScreenPolygon {
            type Target = NiObject;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiScreenPolygon {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiScreenPolygon {
            #[inline]
            fn clone(&self) -> NiScreenPolygon {
                NiScreenPolygon {
                    base: ::core::clone::Clone::clone(&self.base),
                    vertices: ::core::clone::Clone::clone(&self.vertices),
                    uv_coords: ::core::clone::Clone::clone(&self.uv_coords),
                    vertex_colors: ::core::clone::Clone::clone(&self.vertex_colors),
                    property_states: ::core::clone::Clone::clone(&self.property_states),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiScreenPolygon {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field5_finish(
                    f,
                    "NiScreenPolygon",
                    "base",
                    &self.base,
                    "vertices",
                    &self.vertices,
                    "uv_coords",
                    &self.uv_coords,
                    "vertex_colors",
                    &self.vertex_colors,
                    "property_states",
                    &&self.property_states,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiScreenPolygon {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiScreenPolygon {
            #[inline]
            fn eq(&self, other: &NiScreenPolygon) -> bool {
                self.base == other.base && self.vertices == other.vertices
                    && self.uv_coords == other.uv_coords
                    && self.vertex_colors == other.vertex_colors
                    && self.property_states == other.property_states
            }
        }
        #[automatically_derived]
        impl Default for NiScreenPolygon {
            /**Return `NiScreenPolygon {
    base: Default::default(),
    vertices: Default::default(),
    uv_coords: Default::default(),
    vertex_colors: Default::default(),
    property_states: Default::default()
}`*/
            fn default() -> Self {
                NiScreenPolygon {
                    base: Default::default(),
                    vertices: Default::default(),
                    uv_coords: Default::default(),
                    vertex_colors: Default::default(),
                    property_states: Default::default(),
                }
            }
        }
        impl Load for NiScreenPolygon {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let num_vertices: u16 = stream.load()?;
                let vertices = stream.load_vec(num_vertices)?;
                let has_uv_coords = stream.load::<u32>()? != 0;
                let num_uv_coords = if has_uv_coords { num_vertices } else { 0 };
                let uv_coords = stream.load_vec(num_uv_coords)?;
                let has_vertex_colors = stream.load::<u32>()? != 0;
                let num_vertex_colors = if has_vertex_colors { num_vertices } else { 0 };
                let vertex_colors = stream.load_vec(num_vertex_colors)?;
                let property_states = stream.load()?;
                Ok(Self {
                    base,
                    vertices,
                    uv_coords,
                    vertex_colors,
                    property_states,
                })
            }
        }
        impl Save for NiScreenPolygon {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save_as::<u16>(self.vertices.len())?;
                stream.save_vec(&self.vertices)?;
                stream.save_as::<u32>(!self.uv_coords.is_empty())?;
                stream.save_vec(&self.uv_coords)?;
                stream.save_as::<u32>(!self.vertex_colors.is_empty())?;
                stream.save_vec(&self.vertex_colors)?;
                stream.save(&self.property_states)?;
                Ok(())
            }
        }
    }
    mod nisequence {
        use crate::prelude::*;
        pub struct NiSequence {
            pub base: NiObject,
            pub sequence_name: String,
            #[default(SequenceTarget::Internal(0, 0))]
            pub sequence_target: SequenceTarget,
            pub name_controller_pairs: Vec<(String, i32)>,
        }
        impl NiSequence {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiSequence"
            }
        }
        impl Visitor for NiSequence {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.name_controller_pairs).visitor(f);
                (&self.sequence_target).visitor(f);
                (&self.sequence_name).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiSequence {
            type Target = NiObject;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiSequence {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiSequence {
            #[inline]
            fn clone(&self) -> NiSequence {
                NiSequence {
                    base: ::core::clone::Clone::clone(&self.base),
                    sequence_name: ::core::clone::Clone::clone(&self.sequence_name),
                    sequence_target: ::core::clone::Clone::clone(&self.sequence_target),
                    name_controller_pairs: ::core::clone::Clone::clone(
                        &self.name_controller_pairs,
                    ),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiSequence {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "NiSequence",
                    "base",
                    &self.base,
                    "sequence_name",
                    &self.sequence_name,
                    "sequence_target",
                    &self.sequence_target,
                    "name_controller_pairs",
                    &&self.name_controller_pairs,
                )
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for NiSequence {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<NiObject>;
                let _: ::core::cmp::AssertParamIsEq<String>;
                let _: ::core::cmp::AssertParamIsEq<SequenceTarget>;
                let _: ::core::cmp::AssertParamIsEq<Vec<(String, i32)>>;
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiSequence {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiSequence {
            #[inline]
            fn eq(&self, other: &NiSequence) -> bool {
                self.base == other.base && self.sequence_name == other.sequence_name
                    && self.sequence_target == other.sequence_target
                    && self.name_controller_pairs == other.name_controller_pairs
            }
        }
        #[automatically_derived]
        impl Default for NiSequence {
            /**Return `NiSequence {
    base: Default::default(),
    sequence_name: Default::default(),
    sequence_target: SequenceTarget::Internal(0, 0),
    name_controller_pairs: Default::default()
}`*/
            fn default() -> Self {
                NiSequence {
                    base: Default::default(),
                    sequence_name: Default::default(),
                    sequence_target: SequenceTarget::Internal(0, 0),
                    name_controller_pairs: Default::default(),
                }
            }
        }
        impl Load for NiSequence {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let sequence_name = stream.load()?;
                let sequence_target = stream.load()?;
                let num_name_controller_pairs: u32 = stream.load()?;
                let name_controller_pairs = stream.load_seq(num_name_controller_pairs)?;
                Ok(Self {
                    base,
                    sequence_name,
                    sequence_target,
                    name_controller_pairs,
                })
            }
        }
        impl Save for NiSequence {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save_string_without_null_terminator(&self.sequence_name)?;
                stream.save(&self.sequence_target)?;
                stream.save_as::<u32>(self.name_controller_pairs.len())?;
                for (name, controller) in &self.name_controller_pairs {
                    stream.save_string_without_null_terminator(name)?;
                    stream.save(controller)?;
                }
                Ok(())
            }
        }
        pub enum SequenceTarget {
            #[default]
            External(String),
            Internal(i32, i32),
        }
        impl SequenceTarget {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"SequenceTarget"
            }
        }
        impl Visitor for SequenceTarget {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {}
        }
        #[automatically_derived]
        impl ::core::clone::Clone for SequenceTarget {
            #[inline]
            fn clone(&self) -> SequenceTarget {
                match self {
                    SequenceTarget::External(__self_0) => {
                        SequenceTarget::External(::core::clone::Clone::clone(__self_0))
                    }
                    SequenceTarget::Internal(__self_0, __self_1) => {
                        SequenceTarget::Internal(
                            ::core::clone::Clone::clone(__self_0),
                            ::core::clone::Clone::clone(__self_1),
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for SequenceTarget {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    SequenceTarget::External(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "External",
                            &__self_0,
                        )
                    }
                    SequenceTarget::Internal(__self_0, __self_1) => {
                        ::core::fmt::Formatter::debug_tuple_field2_finish(
                            f,
                            "Internal",
                            __self_0,
                            &__self_1,
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for SequenceTarget {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<String>;
                let _: ::core::cmp::AssertParamIsEq<i32>;
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for SequenceTarget {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for SequenceTarget {
            #[inline]
            fn eq(&self, other: &SequenceTarget) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
                    && match (self, other) {
                        (
                            SequenceTarget::External(__self_0),
                            SequenceTarget::External(__arg1_0),
                        ) => __self_0 == __arg1_0,
                        (
                            SequenceTarget::Internal(__self_0, __self_1),
                            SequenceTarget::Internal(__arg1_0, __arg1_1),
                        ) => __self_0 == __arg1_0 && __self_1 == __arg1_1,
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
            }
        }
        #[automatically_derived]
        impl Default for SequenceTarget {
            ///Return `SequenceTarget::External(Default::default())`
            fn default() -> Self {
                SequenceTarget::External(Default::default())
            }
        }
        impl Load for SequenceTarget {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let has_external = stream.load::<u8>()? != 0;
                if has_external {
                    Ok(SequenceTarget::External(stream.load()?))
                } else {
                    Ok(SequenceTarget::Internal(stream.load()?, stream.load()?))
                }
            }
        }
        impl Save for SequenceTarget {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                match self {
                    SequenceTarget::External(file_name) => {
                        stream.save(&1u8)?;
                        stream.save_string_without_null_terminator(file_name)?;
                    }
                    SequenceTarget::Internal(unknown1, unknown2) => {
                        stream.save(&0u8)?;
                        stream.save(unknown1)?;
                        stream.save(unknown2)?;
                    }
                }
                Ok(())
            }
        }
    }
    mod nisequencestreamhelper {
        use crate::prelude::*;
        pub struct NiSequenceStreamHelper {
            pub base: NiObjectNET,
        }
        impl NiSequenceStreamHelper {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiSequenceStreamHelper"
            }
        }
        impl Visitor for NiSequenceStreamHelper {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiSequenceStreamHelper {
            type Target = NiObjectNET;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiSequenceStreamHelper {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiSequenceStreamHelper {
            #[inline]
            fn clone(&self) -> NiSequenceStreamHelper {
                NiSequenceStreamHelper {
                    base: ::core::clone::Clone::clone(&self.base),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiSequenceStreamHelper {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "NiSequenceStreamHelper",
                    "base",
                    &&self.base,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiSequenceStreamHelper {
            #[inline]
            fn default() -> NiSequenceStreamHelper {
                NiSequenceStreamHelper {
                    base: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiSequenceStreamHelper {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiSequenceStreamHelper {
            #[inline]
            fn eq(&self, other: &NiSequenceStreamHelper) -> bool {
                self.base == other.base
            }
        }
        impl Load for NiSequenceStreamHelper {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                Ok(Self { base })
            }
        }
        impl Save for NiSequenceStreamHelper {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                Ok(())
            }
        }
    }
    mod nishadeproperty {
        use crate::prelude::*;
        pub struct NiShadeProperty {
            pub base: NiProperty,
        }
        impl NiShadeProperty {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiShadeProperty"
            }
        }
        impl Visitor for NiShadeProperty {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiShadeProperty {
            type Target = NiProperty;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiShadeProperty {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiShadeProperty {
            #[inline]
            fn clone(&self) -> NiShadeProperty {
                NiShadeProperty {
                    base: ::core::clone::Clone::clone(&self.base),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiShadeProperty {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "NiShadeProperty",
                    "base",
                    &&self.base,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiShadeProperty {
            #[inline]
            fn default() -> NiShadeProperty {
                NiShadeProperty {
                    base: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiShadeProperty {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiShadeProperty {
            #[inline]
            fn eq(&self, other: &NiShadeProperty) -> bool {
                self.base == other.base
            }
        }
        impl Load for NiShadeProperty {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                Ok(Self { base })
            }
        }
        impl Save for NiShadeProperty {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                Ok(())
            }
        }
    }
    mod niskindata {
        use crate::prelude::*;
        pub struct NiSkinData {
            pub base: NiObject,
            #[default(Mat3::IDENTITY)]
            pub rotation: Mat3,
            pub translation: Vec3,
            #[default(1.0)]
            pub scale: f32,
            pub skin_partition: NiLink<NiSkinPartition>,
            pub bone_data: Vec<BoneData>,
        }
        impl NiSkinData {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiSkinData"
            }
        }
        impl Visitor for NiSkinData {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.bone_data).visitor(f);
                (&self.skin_partition).visitor(f);
                (&self.scale).visitor(f);
                (&self.translation).visitor(f);
                (&self.rotation).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiSkinData {
            type Target = NiObject;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiSkinData {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiSkinData {
            #[inline]
            fn clone(&self) -> NiSkinData {
                NiSkinData {
                    base: ::core::clone::Clone::clone(&self.base),
                    rotation: ::core::clone::Clone::clone(&self.rotation),
                    translation: ::core::clone::Clone::clone(&self.translation),
                    scale: ::core::clone::Clone::clone(&self.scale),
                    skin_partition: ::core::clone::Clone::clone(&self.skin_partition),
                    bone_data: ::core::clone::Clone::clone(&self.bone_data),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiSkinData {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "base",
                    "rotation",
                    "translation",
                    "scale",
                    "skin_partition",
                    "bone_data",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.base,
                    &self.rotation,
                    &self.translation,
                    &self.scale,
                    &self.skin_partition,
                    &&self.bone_data,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "NiSkinData",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiSkinData {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiSkinData {
            #[inline]
            fn eq(&self, other: &NiSkinData) -> bool {
                self.scale == other.scale && self.base == other.base
                    && self.rotation == other.rotation
                    && self.translation == other.translation
                    && self.skin_partition == other.skin_partition
                    && self.bone_data == other.bone_data
            }
        }
        #[automatically_derived]
        impl Default for NiSkinData {
            /**Return `NiSkinData {
    base: Default::default(),
    rotation: Mat3::IDENTITY,
    translation: Default::default(),
    scale: 1.0,
    skin_partition: Default::default(),
    bone_data: Default::default()
}`*/
            fn default() -> Self {
                NiSkinData {
                    base: Default::default(),
                    rotation: Mat3::IDENTITY,
                    translation: Default::default(),
                    scale: 1.0,
                    skin_partition: Default::default(),
                    bone_data: Default::default(),
                }
            }
        }
        impl Load for NiSkinData {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let rotation = stream.load()?;
                let translation = stream.load()?;
                let scale = stream.load()?;
                let num_bone_data: u32 = stream.load()?;
                let skin_partition = stream.load()?;
                let bone_data = stream.load_seq(num_bone_data)?;
                Ok(Self {
                    base,
                    rotation,
                    translation,
                    scale,
                    skin_partition,
                    bone_data,
                })
            }
        }
        impl Save for NiSkinData {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save(&self.rotation)?;
                stream.save(&self.translation)?;
                stream.save(&self.scale)?;
                stream.save_as::<u32>(self.bone_data.len())?;
                stream.save(&self.skin_partition)?;
                stream.save_seq(&self.bone_data)?;
                Ok(())
            }
        }
        pub struct BoneData {
            #[default(Mat3::IDENTITY)]
            pub rotation: Mat3,
            pub translation: Vec3,
            #[default(1.0)]
            pub scale: f32,
            pub bound: NiBound,
            pub vertex_weights: Vec<(u16, f32)>,
        }
        impl BoneData {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"BoneData"
            }
        }
        impl Visitor for BoneData {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.vertex_weights).visitor(f);
                (&self.bound).visitor(f);
                (&self.scale).visitor(f);
                (&self.translation).visitor(f);
                (&self.rotation).visitor(f);
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for BoneData {
            #[inline]
            fn clone(&self) -> BoneData {
                BoneData {
                    rotation: ::core::clone::Clone::clone(&self.rotation),
                    translation: ::core::clone::Clone::clone(&self.translation),
                    scale: ::core::clone::Clone::clone(&self.scale),
                    bound: ::core::clone::Clone::clone(&self.bound),
                    vertex_weights: ::core::clone::Clone::clone(&self.vertex_weights),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for BoneData {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field5_finish(
                    f,
                    "BoneData",
                    "rotation",
                    &self.rotation,
                    "translation",
                    &self.translation,
                    "scale",
                    &self.scale,
                    "bound",
                    &self.bound,
                    "vertex_weights",
                    &&self.vertex_weights,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for BoneData {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for BoneData {
            #[inline]
            fn eq(&self, other: &BoneData) -> bool {
                self.scale == other.scale && self.rotation == other.rotation
                    && self.translation == other.translation && self.bound == other.bound
                    && self.vertex_weights == other.vertex_weights
            }
        }
        #[automatically_derived]
        impl Default for BoneData {
            /**Return `BoneData {
    rotation: Mat3::IDENTITY,
    translation: Default::default(),
    scale: 1.0,
    bound: Default::default(),
    vertex_weights: Default::default()
}`*/
            fn default() -> Self {
                BoneData {
                    rotation: Mat3::IDENTITY,
                    translation: Default::default(),
                    scale: 1.0,
                    bound: Default::default(),
                    vertex_weights: Default::default(),
                }
            }
        }
        impl Load for BoneData {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let rotation = stream.load()?;
                let translation = stream.load()?;
                let scale = stream.load()?;
                let bound = stream.load()?;
                let num_vertex_weights: u16 = stream.load()?;
                let vertex_weights = stream.load_seq(num_vertex_weights)?;
                Ok(Self {
                    rotation,
                    translation,
                    scale,
                    bound,
                    vertex_weights,
                })
            }
        }
        impl Save for BoneData {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.rotation)?;
                stream.save(&self.translation)?;
                stream.save(&self.scale)?;
                stream.save(&self.bound)?;
                stream.save_as::<u16>(self.vertex_weights.len())?;
                stream.save_seq(&self.vertex_weights)?;
                Ok(())
            }
        }
    }
    mod niskininstance {
        use crate::prelude::*;
        pub struct NiSkinInstance {
            pub base: NiObject,
            pub data: NiLink<NiSkinData>,
            pub root: NiLink<NiAVObject>,
            pub bones: Vec<NiLink<NiAVObject>>,
        }
        impl NiSkinInstance {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiSkinInstance"
            }
        }
        impl Visitor for NiSkinInstance {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.bones).visitor(f);
                (&self.root).visitor(f);
                (&self.data).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiSkinInstance {
            type Target = NiObject;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiSkinInstance {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiSkinInstance {
            #[inline]
            fn clone(&self) -> NiSkinInstance {
                NiSkinInstance {
                    base: ::core::clone::Clone::clone(&self.base),
                    data: ::core::clone::Clone::clone(&self.data),
                    root: ::core::clone::Clone::clone(&self.root),
                    bones: ::core::clone::Clone::clone(&self.bones),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiSkinInstance {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "NiSkinInstance",
                    "base",
                    &self.base,
                    "data",
                    &self.data,
                    "root",
                    &self.root,
                    "bones",
                    &&self.bones,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiSkinInstance {
            #[inline]
            fn default() -> NiSkinInstance {
                NiSkinInstance {
                    base: ::core::default::Default::default(),
                    data: ::core::default::Default::default(),
                    root: ::core::default::Default::default(),
                    bones: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiSkinInstance {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiSkinInstance {
            #[inline]
            fn eq(&self, other: &NiSkinInstance) -> bool {
                self.base == other.base && self.data == other.data
                    && self.root == other.root && self.bones == other.bones
            }
        }
        impl Load for NiSkinInstance {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let data = stream.load()?;
                let root = stream.load()?;
                let bones = stream.load()?;
                Ok(Self { base, data, root, bones })
            }
        }
        impl Save for NiSkinInstance {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save(&self.data)?;
                stream.save(&self.root)?;
                stream.save(&self.bones)?;
                Ok(())
            }
        }
    }
    mod niskinpartition {
        use crate::prelude::*;
        pub struct NiSkinPartition {
            pub base: NiObject,
            pub partitions: Vec<Partition>,
        }
        impl NiSkinPartition {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiSkinPartition"
            }
        }
        impl Visitor for NiSkinPartition {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.partitions).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiSkinPartition {
            type Target = NiObject;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiSkinPartition {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiSkinPartition {
            #[inline]
            fn clone(&self) -> NiSkinPartition {
                NiSkinPartition {
                    base: ::core::clone::Clone::clone(&self.base),
                    partitions: ::core::clone::Clone::clone(&self.partitions),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiSkinPartition {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "NiSkinPartition",
                    "base",
                    &self.base,
                    "partitions",
                    &&self.partitions,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiSkinPartition {
            #[inline]
            fn default() -> NiSkinPartition {
                NiSkinPartition {
                    base: ::core::default::Default::default(),
                    partitions: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiSkinPartition {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiSkinPartition {
            #[inline]
            fn eq(&self, other: &NiSkinPartition) -> bool {
                self.base == other.base && self.partitions == other.partitions
            }
        }
        impl Load for NiSkinPartition {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let partitions = stream.load()?;
                Ok(Self { base, partitions })
            }
        }
        impl Save for NiSkinPartition {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save(&self.partitions)?;
                Ok(())
            }
        }
        pub struct Partition {
            pub num_bones_per_vertex: u16,
            pub bones: Vec<u16>,
            pub vertex_indices: Vec<u16>,
            pub weights: Vec<f32>,
            pub triangles: Vec<[u16; 3]>,
            pub strip_lengths: Vec<u16>,
            pub strips: Vec<u16>,
            pub bone_palette: Option<Vec<u8>>,
        }
        impl Partition {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"Partition"
            }
        }
        impl Visitor for Partition {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.bone_palette).visitor(f);
                (&self.strips).visitor(f);
                (&self.strip_lengths).visitor(f);
                (&self.triangles).visitor(f);
                (&self.weights).visitor(f);
                (&self.vertex_indices).visitor(f);
                (&self.bones).visitor(f);
                (&self.num_bones_per_vertex).visitor(f);
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Partition {
            #[inline]
            fn clone(&self) -> Partition {
                Partition {
                    num_bones_per_vertex: ::core::clone::Clone::clone(
                        &self.num_bones_per_vertex,
                    ),
                    bones: ::core::clone::Clone::clone(&self.bones),
                    vertex_indices: ::core::clone::Clone::clone(&self.vertex_indices),
                    weights: ::core::clone::Clone::clone(&self.weights),
                    triangles: ::core::clone::Clone::clone(&self.triangles),
                    strip_lengths: ::core::clone::Clone::clone(&self.strip_lengths),
                    strips: ::core::clone::Clone::clone(&self.strips),
                    bone_palette: ::core::clone::Clone::clone(&self.bone_palette),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Partition {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "num_bones_per_vertex",
                    "bones",
                    "vertex_indices",
                    "weights",
                    "triangles",
                    "strip_lengths",
                    "strips",
                    "bone_palette",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.num_bones_per_vertex,
                    &self.bones,
                    &self.vertex_indices,
                    &self.weights,
                    &self.triangles,
                    &self.strip_lengths,
                    &self.strips,
                    &&self.bone_palette,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "Partition",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Partition {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Partition {
            #[inline]
            fn eq(&self, other: &Partition) -> bool {
                self.num_bones_per_vertex == other.num_bones_per_vertex
                    && self.bones == other.bones
                    && self.vertex_indices == other.vertex_indices
                    && self.weights == other.weights && self.triangles == other.triangles
                    && self.strip_lengths == other.strip_lengths
                    && self.strips == other.strips
                    && self.bone_palette == other.bone_palette
            }
        }
        #[automatically_derived]
        impl Default for Partition {
            /**Return `Partition {
    num_bones_per_vertex: Default::default(),
    bones: Default::default(),
    vertex_indices: Default::default(),
    weights: Default::default(),
    triangles: Default::default(),
    strip_lengths: Default::default(),
    strips: Default::default(),
    bone_palette: Default::default()
}`*/
            fn default() -> Self {
                Partition {
                    num_bones_per_vertex: Default::default(),
                    bones: Default::default(),
                    vertex_indices: Default::default(),
                    weights: Default::default(),
                    triangles: Default::default(),
                    strip_lengths: Default::default(),
                    strips: Default::default(),
                    bone_palette: Default::default(),
                }
            }
        }
        impl Load for Partition {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let num_vertices: u16 = stream.load()?;
                let num_triangles: u16 = stream.load()?;
                let num_bones: u16 = stream.load()?;
                let num_strip_lengths: u16 = stream.load()?;
                let num_bones_per_vertex: u16 = stream.load()?;
                let num_weights = num_vertices * num_bones_per_vertex;
                let bones = stream.load_vec(num_bones)?;
                let vertex_indices = stream.load_vec(num_vertices)?;
                let weights = stream.load_vec(num_weights)?;
                let triangles = stream.load_vec(num_triangles)?;
                let strip_lengths: Vec<u16> = stream.load_vec(num_strip_lengths)?;
                let strip_lengths_sum: usize = strip_lengths
                    .iter()
                    .map(|n| *n as usize)
                    .sum();
                let strips = stream.load_vec(strip_lengths_sum)?;
                let has_bone_palette: u8 = stream.load()?;
                let bone_palette = match has_bone_palette {
                    0 => None,
                    _ => Some(stream.load_vec(num_weights)?),
                };
                Ok(Self {
                    num_bones_per_vertex,
                    bones,
                    vertex_indices,
                    weights,
                    triangles,
                    strip_lengths,
                    strips,
                    bone_palette,
                })
            }
        }
        impl Save for Partition {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save_as::<u16>(self.vertex_indices.len())?;
                stream.save_as::<u16>(self.triangles.len())?;
                stream.save_as::<u16>(self.bones.len())?;
                stream.save_as::<u16>(self.strip_lengths.len())?;
                stream.save_as::<u16>(self.num_bones_per_vertex)?;
                stream.save_vec(&self.bones)?;
                stream.save_vec(&self.vertex_indices)?;
                stream.save_vec(&self.weights)?;
                stream.save_vec(&self.triangles)?;
                stream.save_vec(&self.strip_lengths)?;
                stream.save_vec(&self.strips)?;
                stream.save_as::<u8>(self.bone_palette.is_some())?;
                if let Some(bone_palette) = &self.bone_palette {
                    stream.save_vec(bone_palette)?;
                }
                Ok(())
            }
        }
    }
    mod nisortadjustnode {
        use crate::prelude::*;
        pub struct NiSortAdjustNode {
            pub base: NiNode,
            pub sorting_mode: SortingMode,
            pub sub_sorter: NiLink<NiAccumulator>,
        }
        impl NiSortAdjustNode {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiSortAdjustNode"
            }
        }
        impl Visitor for NiSortAdjustNode {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.sub_sorter).visitor(f);
                (&self.sorting_mode).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiSortAdjustNode {
            type Target = NiNode;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiSortAdjustNode {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiSortAdjustNode {
            #[inline]
            fn clone(&self) -> NiSortAdjustNode {
                NiSortAdjustNode {
                    base: ::core::clone::Clone::clone(&self.base),
                    sorting_mode: ::core::clone::Clone::clone(&self.sorting_mode),
                    sub_sorter: ::core::clone::Clone::clone(&self.sub_sorter),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiSortAdjustNode {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "NiSortAdjustNode",
                    "base",
                    &self.base,
                    "sorting_mode",
                    &self.sorting_mode,
                    "sub_sorter",
                    &&self.sub_sorter,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiSortAdjustNode {
            #[inline]
            fn default() -> NiSortAdjustNode {
                NiSortAdjustNode {
                    base: ::core::default::Default::default(),
                    sorting_mode: ::core::default::Default::default(),
                    sub_sorter: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiSortAdjustNode {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiSortAdjustNode {
            #[inline]
            fn eq(&self, other: &NiSortAdjustNode) -> bool {
                self.base == other.base && self.sorting_mode == other.sorting_mode
                    && self.sub_sorter == other.sub_sorter
            }
        }
        impl Load for NiSortAdjustNode {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let sorting_mode = stream.load()?;
                let sub_sorter = stream.load()?;
                Ok(Self {
                    base,
                    sorting_mode,
                    sub_sorter,
                })
            }
        }
        impl Save for NiSortAdjustNode {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save(&self.sorting_mode)?;
                stream.save(&self.sub_sorter)?;
                Ok(())
            }
        }
    }
    mod nisourcetexture {
        use crate::prelude::*;
        pub struct NiSourceTexture {
            pub base: NiTexture,
            pub source: TextureSource,
            pub pixel_layout: PixelLayout,
            pub use_mipmaps: UseMipMaps,
            pub alpha_format: AlphaFormat,
            #[default(true)]
            pub is_static: bool,
        }
        impl NiSourceTexture {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiSourceTexture"
            }
        }
        impl Visitor for NiSourceTexture {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.is_static).visitor(f);
                (&self.alpha_format).visitor(f);
                (&self.use_mipmaps).visitor(f);
                (&self.pixel_layout).visitor(f);
                (&self.source).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiSourceTexture {
            type Target = NiTexture;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiSourceTexture {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiSourceTexture {
            #[inline]
            fn clone(&self) -> NiSourceTexture {
                NiSourceTexture {
                    base: ::core::clone::Clone::clone(&self.base),
                    source: ::core::clone::Clone::clone(&self.source),
                    pixel_layout: ::core::clone::Clone::clone(&self.pixel_layout),
                    use_mipmaps: ::core::clone::Clone::clone(&self.use_mipmaps),
                    alpha_format: ::core::clone::Clone::clone(&self.alpha_format),
                    is_static: ::core::clone::Clone::clone(&self.is_static),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiSourceTexture {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "base",
                    "source",
                    "pixel_layout",
                    "use_mipmaps",
                    "alpha_format",
                    "is_static",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.base,
                    &self.source,
                    &self.pixel_layout,
                    &self.use_mipmaps,
                    &self.alpha_format,
                    &&self.is_static,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "NiSourceTexture",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiSourceTexture {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiSourceTexture {
            #[inline]
            fn eq(&self, other: &NiSourceTexture) -> bool {
                self.is_static == other.is_static && self.base == other.base
                    && self.source == other.source
                    && self.pixel_layout == other.pixel_layout
                    && self.use_mipmaps == other.use_mipmaps
                    && self.alpha_format == other.alpha_format
            }
        }
        #[automatically_derived]
        impl Default for NiSourceTexture {
            /**Return `NiSourceTexture {
    base: Default::default(),
    source: Default::default(),
    pixel_layout: Default::default(),
    use_mipmaps: Default::default(),
    alpha_format: Default::default(),
    is_static: true
}`*/
            fn default() -> Self {
                NiSourceTexture {
                    base: Default::default(),
                    source: Default::default(),
                    pixel_layout: Default::default(),
                    use_mipmaps: Default::default(),
                    alpha_format: Default::default(),
                    is_static: true,
                }
            }
        }
        impl Load for NiSourceTexture {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let source = stream.load()?;
                let pixel_layout = stream.load()?;
                let use_mipmaps = stream.load()?;
                let alpha_format = stream.load()?;
                let is_static = stream.load::<u8>()? != 0;
                Ok(Self {
                    base,
                    source,
                    pixel_layout,
                    use_mipmaps,
                    alpha_format,
                    is_static,
                })
            }
        }
        impl Save for NiSourceTexture {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save(&self.source)?;
                stream.save(&self.pixel_layout)?;
                stream.save(&self.use_mipmaps)?;
                stream.save(&self.alpha_format)?;
                stream.save_as::<u8>(self.is_static)?;
                Ok(())
            }
        }
        pub enum TextureSource {
            External(String),
            #[default]
            Internal(NiLink<NiPixelData>),
        }
        #[automatically_derived]
        impl ::core::clone::Clone for TextureSource {
            #[inline]
            fn clone(&self) -> TextureSource {
                match self {
                    TextureSource::External(__self_0) => {
                        TextureSource::External(::core::clone::Clone::clone(__self_0))
                    }
                    TextureSource::Internal(__self_0) => {
                        TextureSource::Internal(::core::clone::Clone::clone(__self_0))
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for TextureSource {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    TextureSource::External(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "External",
                            &__self_0,
                        )
                    }
                    TextureSource::Internal(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Internal",
                            &__self_0,
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for TextureSource {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<String>;
                let _: ::core::cmp::AssertParamIsEq<NiLink<NiPixelData>>;
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for TextureSource {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for TextureSource {
            #[inline]
            fn eq(&self, other: &TextureSource) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
                    && match (self, other) {
                        (
                            TextureSource::External(__self_0),
                            TextureSource::External(__arg1_0),
                        ) => __self_0 == __arg1_0,
                        (
                            TextureSource::Internal(__self_0),
                            TextureSource::Internal(__arg1_0),
                        ) => __self_0 == __arg1_0,
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
            }
        }
        #[automatically_derived]
        impl Default for TextureSource {
            ///Return `TextureSource::Internal(Default::default())`
            fn default() -> Self {
                TextureSource::Internal(Default::default())
            }
        }
        impl Load for TextureSource {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let has_external = stream.load::<u8>()? != 0;
                if has_external {
                    return Ok(TextureSource::External(stream.load()?));
                }
                let has_internal = stream.load::<u8>()? != 0;
                if has_internal {
                    return Ok(TextureSource::Internal(stream.load()?));
                }
                Ok(TextureSource::Internal(NiLink::null()))
            }
        }
        impl Save for TextureSource {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                match self {
                    TextureSource::External(file_name) => {
                        stream.save(&1u8)?;
                        stream.save_string_without_null_terminator(file_name)?;
                    }
                    TextureSource::Internal(pixel_data) => {
                        stream.save(&0u8)?;
                        if pixel_data.is_null() {
                            stream.save(&0u8)?;
                        } else {
                            stream.save(&1u8)?;
                            stream.save(pixel_data)?;
                        }
                    }
                }
                Ok(())
            }
        }
    }
    mod nispecularproperty {
        use crate::prelude::*;
        pub struct NiSpecularProperty {
            pub base: NiProperty,
        }
        impl NiSpecularProperty {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiSpecularProperty"
            }
        }
        impl Visitor for NiSpecularProperty {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiSpecularProperty {
            type Target = NiProperty;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiSpecularProperty {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiSpecularProperty {
            #[inline]
            fn clone(&self) -> NiSpecularProperty {
                NiSpecularProperty {
                    base: ::core::clone::Clone::clone(&self.base),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiSpecularProperty {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "NiSpecularProperty",
                    "base",
                    &&self.base,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiSpecularProperty {
            #[inline]
            fn default() -> NiSpecularProperty {
                NiSpecularProperty {
                    base: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiSpecularProperty {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiSpecularProperty {
            #[inline]
            fn eq(&self, other: &NiSpecularProperty) -> bool {
                self.base == other.base
            }
        }
        impl Load for NiSpecularProperty {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                Ok(Self { base })
            }
        }
        impl Save for NiSpecularProperty {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                Ok(())
            }
        }
    }
    mod nispherebv {
        use crate::prelude::*;
        pub struct NiSphereBV {
            pub bound: NiBound,
        }
        impl NiSphereBV {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiSphereBV"
            }
        }
        impl Visitor for NiSphereBV {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.bound).visitor(f);
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiSphereBV {
            #[inline]
            fn clone(&self) -> NiSphereBV {
                NiSphereBV {
                    bound: ::core::clone::Clone::clone(&self.bound),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiSphereBV {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "NiSphereBV",
                    "bound",
                    &&self.bound,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiSphereBV {
            #[inline]
            fn default() -> NiSphereBV {
                NiSphereBV {
                    bound: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiSphereBV {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiSphereBV {
            #[inline]
            fn eq(&self, other: &NiSphereBV) -> bool {
                self.bound == other.bound
            }
        }
        impl Load for NiSphereBV {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let bound = stream.load()?;
                Ok(Self { bound })
            }
        }
        impl Save for NiSphereBV {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.bound)?;
                Ok(())
            }
        }
    }
    mod nisphericalcollider {
        use crate::prelude::*;
        pub struct NiSphericalCollider {
            pub base: NiParticleCollider,
            pub radius: f32,
            pub position: Vec3,
        }
        impl NiSphericalCollider {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiSphericalCollider"
            }
        }
        impl Visitor for NiSphericalCollider {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.position).visitor(f);
                (&self.radius).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiSphericalCollider {
            type Target = NiParticleCollider;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiSphericalCollider {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiSphericalCollider {
            #[inline]
            fn clone(&self) -> NiSphericalCollider {
                NiSphericalCollider {
                    base: ::core::clone::Clone::clone(&self.base),
                    radius: ::core::clone::Clone::clone(&self.radius),
                    position: ::core::clone::Clone::clone(&self.position),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiSphericalCollider {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "NiSphericalCollider",
                    "base",
                    &self.base,
                    "radius",
                    &self.radius,
                    "position",
                    &&self.position,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiSphericalCollider {
            #[inline]
            fn default() -> NiSphericalCollider {
                NiSphericalCollider {
                    base: ::core::default::Default::default(),
                    radius: ::core::default::Default::default(),
                    position: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiSphericalCollider {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiSphericalCollider {
            #[inline]
            fn eq(&self, other: &NiSphericalCollider) -> bool {
                self.radius == other.radius && self.base == other.base
                    && self.position == other.position
            }
        }
        impl Load for NiSphericalCollider {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let radius = stream.load()?;
                let position = stream.load()?;
                Ok(Self { base, radius, position })
            }
        }
        impl Save for NiSphericalCollider {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save(&self.radius)?;
                stream.save(&self.position)?;
                Ok(())
            }
        }
    }
    mod nispotlight {
        use crate::prelude::*;
        pub struct NiSpotLight {
            pub base: NiPointLight,
            pub outer_spot_angle: f32,
            pub exponent: f32,
        }
        impl NiSpotLight {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiSpotLight"
            }
        }
        impl Visitor for NiSpotLight {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.exponent).visitor(f);
                (&self.outer_spot_angle).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiSpotLight {
            type Target = NiPointLight;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiSpotLight {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiSpotLight {
            #[inline]
            fn clone(&self) -> NiSpotLight {
                NiSpotLight {
                    base: ::core::clone::Clone::clone(&self.base),
                    outer_spot_angle: ::core::clone::Clone::clone(
                        &self.outer_spot_angle,
                    ),
                    exponent: ::core::clone::Clone::clone(&self.exponent),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiSpotLight {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "NiSpotLight",
                    "base",
                    &self.base,
                    "outer_spot_angle",
                    &self.outer_spot_angle,
                    "exponent",
                    &&self.exponent,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiSpotLight {
            #[inline]
            fn default() -> NiSpotLight {
                NiSpotLight {
                    base: ::core::default::Default::default(),
                    outer_spot_angle: ::core::default::Default::default(),
                    exponent: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiSpotLight {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiSpotLight {
            #[inline]
            fn eq(&self, other: &NiSpotLight) -> bool {
                self.outer_spot_angle == other.outer_spot_angle
                    && self.exponent == other.exponent && self.base == other.base
            }
        }
        impl Load for NiSpotLight {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let outer_spot_angle = stream.load()?;
                let exponent = stream.load()?;
                Ok(Self {
                    base,
                    outer_spot_angle,
                    exponent,
                })
            }
        }
        impl Save for NiSpotLight {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save(&self.outer_spot_angle)?;
                stream.save(&self.exponent)?;
                Ok(())
            }
        }
    }
    mod nistencilproperty {
        use crate::prelude::*;
        pub struct NiStencilProperty {
            pub base: NiProperty,
            pub stencil_enabled: bool,
            pub stencil_function: StencilTestFunction,
            pub stencil_ref: u32,
            #[default(0xFFFFFFFF)]
            pub stencil_mask: u32,
            pub fail_action: Action,
            pub pass_z_fail_action: Action,
            pub pass_action: Action,
            pub draw_mode: DrawMode,
        }
        impl NiStencilProperty {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiStencilProperty"
            }
        }
        impl Visitor for NiStencilProperty {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.draw_mode).visitor(f);
                (&self.pass_action).visitor(f);
                (&self.pass_z_fail_action).visitor(f);
                (&self.fail_action).visitor(f);
                (&self.stencil_mask).visitor(f);
                (&self.stencil_ref).visitor(f);
                (&self.stencil_function).visitor(f);
                (&self.stencil_enabled).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiStencilProperty {
            type Target = NiProperty;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiStencilProperty {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiStencilProperty {
            #[inline]
            fn clone(&self) -> NiStencilProperty {
                NiStencilProperty {
                    base: ::core::clone::Clone::clone(&self.base),
                    stencil_enabled: ::core::clone::Clone::clone(&self.stencil_enabled),
                    stencil_function: ::core::clone::Clone::clone(
                        &self.stencil_function,
                    ),
                    stencil_ref: ::core::clone::Clone::clone(&self.stencil_ref),
                    stencil_mask: ::core::clone::Clone::clone(&self.stencil_mask),
                    fail_action: ::core::clone::Clone::clone(&self.fail_action),
                    pass_z_fail_action: ::core::clone::Clone::clone(
                        &self.pass_z_fail_action,
                    ),
                    pass_action: ::core::clone::Clone::clone(&self.pass_action),
                    draw_mode: ::core::clone::Clone::clone(&self.draw_mode),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiStencilProperty {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "base",
                    "stencil_enabled",
                    "stencil_function",
                    "stencil_ref",
                    "stencil_mask",
                    "fail_action",
                    "pass_z_fail_action",
                    "pass_action",
                    "draw_mode",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.base,
                    &self.stencil_enabled,
                    &self.stencil_function,
                    &self.stencil_ref,
                    &self.stencil_mask,
                    &self.fail_action,
                    &self.pass_z_fail_action,
                    &self.pass_action,
                    &&self.draw_mode,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "NiStencilProperty",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiStencilProperty {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiStencilProperty {
            #[inline]
            fn eq(&self, other: &NiStencilProperty) -> bool {
                self.stencil_enabled == other.stencil_enabled
                    && self.stencil_ref == other.stencil_ref
                    && self.stencil_mask == other.stencil_mask && self.base == other.base
                    && self.stencil_function == other.stencil_function
                    && self.fail_action == other.fail_action
                    && self.pass_z_fail_action == other.pass_z_fail_action
                    && self.pass_action == other.pass_action
                    && self.draw_mode == other.draw_mode
            }
        }
        #[automatically_derived]
        impl Default for NiStencilProperty {
            /**Return `NiStencilProperty {
    base: Default::default(),
    stencil_enabled: Default::default(),
    stencil_function: Default::default(),
    stencil_ref: Default::default(),
    stencil_mask: 0xFFFFFFFF,
    fail_action: Default::default(),
    pass_z_fail_action: Default::default(),
    pass_action: Default::default(),
    draw_mode: Default::default()
}`*/
            fn default() -> Self {
                NiStencilProperty {
                    base: Default::default(),
                    stencil_enabled: Default::default(),
                    stencil_function: Default::default(),
                    stencil_ref: Default::default(),
                    stencil_mask: 0xFFFFFFFF,
                    fail_action: Default::default(),
                    pass_z_fail_action: Default::default(),
                    pass_action: Default::default(),
                    draw_mode: Default::default(),
                }
            }
        }
        impl Load for NiStencilProperty {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let stencil_enabled = stream.load::<u8>()? != 0;
                let stencil_function = stream.load()?;
                let stencil_ref = stream.load()?;
                let stencil_mask = stream.load()?;
                let fail_action = stream.load()?;
                let pass_z_fail_action = stream.load()?;
                let pass_action = stream.load()?;
                let draw_mode = stream.load()?;
                Ok(Self {
                    base,
                    stencil_enabled,
                    stencil_function,
                    stencil_ref,
                    stencil_mask,
                    fail_action,
                    pass_z_fail_action,
                    pass_action,
                    draw_mode,
                })
            }
        }
        impl Save for NiStencilProperty {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save_as::<u8>(self.stencil_enabled)?;
                stream.save(&self.stencil_function)?;
                stream.save(&self.stencil_ref)?;
                stream.save(&self.stencil_mask)?;
                stream.save(&self.fail_action)?;
                stream.save(&self.pass_z_fail_action)?;
                stream.save(&self.pass_action)?;
                stream.save(&self.draw_mode)?;
                Ok(())
            }
        }
    }
    mod nistream {
        use std::collections::VecDeque;
        use std::io::{Read, Seek, Write};
        use std::path::Path;
        use bevy::asset::{Handle, LoadContext, RenderAssetUsages};
        use bevy::color::{Color, LinearRgba};
        use bevy::log::{error, info, warn};
        use bevy::pbr::StandardMaterial;
        use bevy::render::alpha::AlphaMode;
        use bevy::render::mesh::{Indices, Mesh, PrimitiveTopology};
        use slotmap::{new_key_type, DenseSlotMap, Key};
        use crate::prelude::*;
        #[repr(transparent)]
        pub struct NiKey(::slotmap::KeyData);
        #[automatically_derived]
        impl ::core::marker::Copy for NiKey {}
        #[automatically_derived]
        impl ::core::clone::Clone for NiKey {
            #[inline]
            fn clone(&self) -> NiKey {
                let _: ::core::clone::AssertParamIsClone<::slotmap::KeyData>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiKey {
            #[inline]
            fn default() -> NiKey {
                NiKey(::core::default::Default::default())
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for NiKey {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<::slotmap::KeyData>;
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiKey {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiKey {
            #[inline]
            fn eq(&self, other: &NiKey) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Ord for NiKey {
            #[inline]
            fn cmp(&self, other: &NiKey) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl ::core::cmp::PartialOrd for NiKey {
            #[inline]
            fn partial_cmp(
                &self,
                other: &NiKey,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for NiKey {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiKey {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "NiKey", &&self.0)
            }
        }
        impl ::slotmap::__impl::From<::slotmap::KeyData> for NiKey {
            fn from(k: ::slotmap::KeyData) -> Self {
                NiKey(k)
            }
        }
        unsafe impl ::slotmap::Key for NiKey {
            fn data(&self) -> ::slotmap::KeyData {
                self.0
            }
        }
        pub enum ConsumedNiType {
            NiTriShapeData(Handle<Mesh>),
            NiMaterialProperty(Handle<StandardMaterial>),
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ConsumedNiType {
            #[inline]
            fn clone(&self) -> ConsumedNiType {
                match self {
                    ConsumedNiType::NiTriShapeData(__self_0) => {
                        ConsumedNiType::NiTriShapeData(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                    ConsumedNiType::NiMaterialProperty(__self_0) => {
                        ConsumedNiType::NiMaterialProperty(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ConsumedNiType {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    ConsumedNiType::NiTriShapeData(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "NiTriShapeData",
                            &__self_0,
                        )
                    }
                    ConsumedNiType::NiMaterialProperty(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "NiMaterialProperty",
                            &__self_0,
                        )
                    }
                }
            }
        }
        pub struct NiStream {
            pub objects: DenseSlotMap<NiKey, NiType>,
            pub roots: Vec<NiLink<NiObject>>,
            pub block_assets: HashMap<NiKey, Vec<ConsumedNiType>>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiStream {
            #[inline]
            fn clone(&self) -> NiStream {
                NiStream {
                    objects: ::core::clone::Clone::clone(&self.objects),
                    roots: ::core::clone::Clone::clone(&self.roots),
                    block_assets: ::core::clone::Clone::clone(&self.block_assets),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiStream {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "NiStream",
                    "objects",
                    &self.objects,
                    "roots",
                    &self.roots,
                    "block_assets",
                    &&self.block_assets,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiStream {
            #[inline]
            fn default() -> NiStream {
                NiStream {
                    objects: ::core::default::Default::default(),
                    roots: ::core::default::Default::default(),
                    block_assets: ::core::default::Default::default(),
                }
            }
        }
        impl NiStream {
            pub const HEADER: [u8; 40] = *b"NetImmerse File Format, Version 4.0.0.2\n";
            pub const VERSION: u32 = 0x4000002;
            pub fn new() -> Self {
                default()
            }
            pub fn from_path(
                path: impl AsRef<Path>,
                load_context: &mut LoadContext,
            ) -> io::Result<Self> {
                let mut stream = Self::new();
                stream.load_path(path, load_context)?;
                Ok(stream)
            }
            pub fn from_path_offset(
                path: impl AsRef<Path>,
                offset: u64,
                size: usize,
                load_context: &mut LoadContext,
            ) -> io::Result<Self> {
                let mut file = std::fs::File::open(path)?;
                file.seek(io::SeekFrom::Start(offset))?;
                let mut bytes = ::alloc::vec::from_elem(0, size);
                file.read_exact(&mut bytes)?;
                let mut stream = Self::new();
                stream.load_bytes(&bytes, load_context)?;
                Ok(stream)
            }
            pub fn load_path(
                &mut self,
                path: impl AsRef<Path>,
                load_context: &mut LoadContext,
            ) -> io::Result<()> {
                self.load_bytes(&std::fs::read(path)?, load_context)
            }
            pub fn from_bytes(
                bytes: &[u8],
                load_context: &mut LoadContext,
            ) -> io::Result<Self> {
                let mut stream = Self::new();
                stream.load_bytes(bytes, load_context)?;
                Ok(stream)
            }
            pub fn load_bytes(
                &mut self,
                bytes: &[u8],
                load_context: &mut LoadContext,
            ) -> io::Result<()> {
                let mut stream = Reader::new(bytes);
                let header: [u8; 40] = stream.load()?;
                if header != Self::HEADER {
                    return Reader::error("Invalid NIF Header");
                }
                let version: u32 = stream.load()?;
                if version != Self::VERSION {
                    return Reader::error("Invalid NIF Version");
                }
                let num_objects = stream.load_as::<u32, usize>()?;
                self.objects.reserve(num_objects);
                let mut staging_buffer: Vec<(NiType, Vec<ConsumedNiType>)> = Vec::with_capacity(
                    num_objects,
                );
                for i in 0..num_objects {
                    let ni_type: NiType = stream.load()?;
                    let mut created_assets = Vec::new();
                    let consume_ni_type = match &ni_type {
                        NiType::NiTriShapeData(data) => {
                            if let Some(mesh) = convert_nif_mesh(data) {
                                let handle = load_context
                                    .add_labeled_asset(
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(format_args!("mesh_{0}", i))
                                        }),
                                        mesh,
                                    );
                                created_assets.push(ConsumedNiType::NiTriShapeData(handle));
                            }
                            true
                        }
                        NiType::NiMaterialProperty(mat_prop) => {
                            let mut material = StandardMaterial::default();
                            material.base_color = Color::srgb(
                                mat_prop.diffuse_color[0],
                                mat_prop.diffuse_color[1],
                                mat_prop.diffuse_color[2],
                            );
                            material.emissive = LinearRgba::rgb(
                                mat_prop.emissive_color[0],
                                mat_prop.emissive_color[1],
                                mat_prop.emissive_color[2],
                            );
                            material.metallic = 0.1;
                            material.perceptual_roughness = 1.0
                                - (mat_prop.shine / 100.0).clamp(0.0, 1.0);
                            material.alpha_mode = if mat_prop.alpha < 0.99 {
                                AlphaMode::Blend
                            } else {
                                AlphaMode::Opaque
                            };
                            let handle = load_context
                                .add_labeled_asset(
                                    ::alloc::__export::must_use({
                                        ::alloc::fmt::format(format_args!("mat_{0}", i))
                                    }),
                                    material,
                                );
                            created_assets
                                .push(ConsumedNiType::NiMaterialProperty(handle));
                            true
                        }
                        _ => true,
                    };
                    if consume_ni_type {
                        ni_type = NiType::Empty;
                    }
                    staging_buffer.push((ni_type, created_assets));
                }
                for (ni_type, assets) in staging_buffer.into_iter() {
                    let key: NiKey = self.objects.insert(ni_type);
                    if !assets.is_empty() {
                        self.block_assets.insert(key, assets);
                    }
                }
                let num_roots = stream.load_as::<u32, usize>()?;
                self.roots.reserve(num_roots);
                for _ in 0..num_roots {
                    self.roots.push(stream.load()?);
                }
                Ok(())
            }
            pub fn save_path(&mut self, path: impl AsRef<Path>) -> io::Result<()> {
                let mut file = std::fs::File::create(path)?;
                file.write_all(self.save_bytes()?.as_slice())?;
                Ok(())
            }
            pub fn save_bytes(&mut self) -> io::Result<Vec<u8>> {
                let mut stream = Writer::new(::alloc::vec::Vec::new());
                stream.save(&Self::HEADER)?;
                stream.save(&Self::VERSION)?;
                let objects: Vec<_> = self.objects().collect();
                stream.save_as::<u32>(objects.len())?;
                for (key, _) in &objects {
                    stream
                        .context
                        .insert(key.data().as_ffi(), stream.context.len() as u64);
                }
                for (_, object) in objects {
                    stream.save(object)?;
                }
                stream.save(&self.roots)?;
                Ok(stream.cursor.into_inner())
            }
            fn objects(&self) -> impl Iterator<Item = (NiKey, &NiType)> {
                let mut seen = HashSet::new();
                let mut keys = Vec::new();
                self.roots.visitor(&mut |key| keys.push(key));
                std::iter::from_fn(move || {
                    while let Some(key) = keys.pop() {
                        if !key.is_null() && seen.insert(key) {
                            if let Some(object) = self.objects.get(key) {
                                object.visitor(&mut |key| keys.push(key));
                                return Some((key, object));
                            }
                        }
                    }
                    None
                })
            }
            pub fn retain_reachable(&mut self) {
                let mut seen = HashSet::new();
                let mut keys = Vec::new();
                self.roots.visitor(&mut |key| keys.push(key));
                while let Some(key) = keys.pop() {
                    if !key.is_null() && seen.insert(key) {
                        if let Some(object) = self.objects.get(key) {
                            object.visitor(&mut |key| keys.push(key));
                        }
                    }
                }
                self.objects.retain(|key, _| seen.contains(&key));
            }
            /// Insert an object into the stream.
            ///
            /// # Examples
            ///
            /// ```
            /// use nif::*;
            ///
            /// let mut stream = NiStream::new();
            ///
            /// let link1 = stream.insert(NiTriShape::default());
            /// let link2 = stream.insert(NiTriShapeData::default());
            ///
            /// let object1 = stream.get(link1).unwrap();
            /// let object2 = stream.get(link2).unwrap();
            ///
            /// assert_eq!(object1.type_name(), b"NiTriShape");
            /// assert_eq!(object2.type_name(), b"NiTriShapeData");
            /// ```
            #[inline]
            pub fn insert<T>(&mut self, object: T) -> NiLink<T>
            where
                T: Into<NiType>,
            {
                NiLink::new(self.objects.insert(object.into()))
            }
            #[inline]
            pub fn remove<T>(&mut self, link: NiLink<T>) -> Option<T>
            where
                T: TryFrom<NiType>,
            {
                self.objects.remove(link.key)?.try_into().ok()
            }
            /// Retrieve an object from the stream.
            ///
            /// # Examples
            ///
            /// ```
            /// use nif::*;
            ///
            /// let mut stream = NiStream::new();
            ///
            /// let link = stream.insert(NiNode::default());
            ///
            /// let object = stream.get(link).unwrap();
            ///
            /// assert_eq!(object.type_name(), b"NiNode")
            /// ```
            #[inline]
            pub fn get<'a, T>(&'a self, link: NiLink<T>) -> Option<&'a T>
            where
                &'a T: TryFrom<&'a NiType>,
            {
                self.get_as(link)
            }
            /// Retrieve an object of the specified type from the stream.
            #[inline]
            pub fn get_as<'a, T, U>(&'a self, link: NiLink<T>) -> Option<&'a U>
            where
                &'a U: TryFrom<&'a NiType>,
            {
                self.objects.get(link.key).and_then(|object| object.try_into().ok())
            }
            #[inline]
            pub fn get_mut<'a, T>(&'a mut self, link: NiLink<T>) -> Option<&'a mut T>
            where
                &'a mut T: TryFrom<&'a mut NiType>,
            {
                self.get_as_mut(link)
            }
            /// Retrieve an object of the specified type from the stream.
            #[inline]
            pub fn get_as_mut<'a, T, U>(
                &'a mut self,
                link: NiLink<T>,
            ) -> Option<&'a mut U>
            where
                &'a mut U: TryFrom<&'a mut NiType>,
            {
                self.objects.get_mut(link.key).and_then(|object| object.try_into().ok())
            }
            /// Retrieve multiple objects from the stream.
            #[inline]
            pub fn get_all<'a, T>(
                &'a self,
                links: &'a [NiLink<T>],
            ) -> impl Iterator<Item = &'a T>
            where
                &'a T: TryFrom<&'a NiType>,
            {
                self.get_all_as(links)
            }
            /// Retrieve multiple objects of the specified type from the stream.
            #[inline]
            pub fn get_all_as<'a, T, U>(
                &'a self,
                links: &'a [NiLink<T>],
            ) -> impl Iterator<Item = &'a U>
            where
                &'a U: 'a + TryFrom<&'a NiType>,
            {
                links.iter().filter_map(move |link| self.get_as(*link))
            }
            /// Create an iterator over objects of the specified type.
            ///
            /// # Examples
            ///
            /// ```
            /// use nif::*;
            ///
            /// let mut stream = NiStream::new();
            ///
            /// stream.insert(NiNode::default());
            /// stream.insert(NiTriShape::default());
            ///
            /// for object in stream.objects_of_type::<NiTriShape>() {
            ///     assert_eq!(object.type_name(), b"NiTriShape");
            /// }
            /// ```
            #[inline]
            pub fn objects_of_type<'a, T>(&'a self) -> impl Iterator<Item = &'a T>
            where
                &'a T: 'a + TryFrom<&'a NiType>,
            {
                self.objects.values().filter_map(|object| object.try_into().ok())
            }
            #[inline]
            pub fn objects_of_type_mut<'a, T>(
                &'a mut self,
            ) -> impl Iterator<Item = &'a mut T>
            where
                &'a mut T: 'a + TryFrom<&'a mut NiType>,
            {
                self.objects.values_mut().filter_map(|object| object.try_into().ok())
            }
            #[inline]
            pub fn objects_of_type_with_link<'a, T>(
                &'a self,
            ) -> impl Iterator<Item = (NiLink<T>, &'a T)>
            where
                &'a T: 'a + TryFrom<&'a NiType>,
            {
                self.objects
                    .iter()
                    .filter_map(|(key, object)| Some((
                        NiLink::new(key),
                        object.try_into().ok()?,
                    )))
            }
            #[inline]
            pub fn objects_of_type_mut_with_link<'a, T>(
                &'a mut self,
            ) -> impl Iterator<Item = (NiLink<T>, &'a mut T)>
            where
                &'a mut T: 'a + TryFrom<&'a mut NiType>,
            {
                self.objects
                    .iter_mut()
                    .filter_map(|(key, object)| Some((
                        NiLink::new(key),
                        object.try_into().ok()?,
                    )))
            }
            #[inline]
            pub fn links_of_type<'a, T>(&'a self) -> impl Iterator<Item = NiLink<T>> + 'a
            where
                &'a T: 'a + TryFrom<&'a NiType>,
            {
                self.objects_of_type_with_link().map(|(link, _)| link)
            }
            /// Create an iterator over roots of the specified type.
            #[inline]
            pub fn roots_of_type<'a, T>(&'a self) -> impl Iterator<Item = &'a T>
            where
                &'a T: 'a + TryFrom<&'a NiType>,
            {
                self.get_all_as(self.roots.as_slice())
            }
            #[inline]
            pub fn objects_with_name<'a, T>(
                &'a self,
                name: &'a str,
            ) -> impl Iterator<Item = &'a T>
            where
                &'a T: 'a + TryFrom<&'a NiType> + AsRef<NiObjectNET>,
            {
                self.objects_of_type::<T>()
                    .filter(move |object| {
                        object.as_ref().name.eq_ignore_ascii_case(name)
                    })
            }
            #[inline]
            pub fn objects_with_name_mut<'a, T>(
                &'a mut self,
                name: &'a str,
            ) -> impl Iterator<Item = &'a mut T>
            where
                &'a mut T: 'a + TryFrom<&'a mut NiType> + AsRef<NiObjectNET>,
            {
                self.objects_of_type_mut::<T>()
                    .filter(move |object| {
                        object.as_ref().name.eq_ignore_ascii_case(name)
                    })
            }
            /// Yields all geometries and their world transforms.
            ///
            pub fn geometries<'a, T>(&'a self) -> impl Iterator<Item = (&'a T, Affine3A)>
            where
                &'a T: 'a + TryFrom<&'a NiType> + AsRef<NiGeometry>,
            {
                let mut queue = VecDeque::new();
                for root in &self.roots {
                    queue.push_back((root.key, Affine3A::IDENTITY));
                }
                std::iter::from_fn(move || {
                    while let Some((key, transform)) = queue.pop_front() {
                        let Some(object) = self.objects.get(key) else {
                            continue;
                        };
                        if let Ok(node) = <&NiNode>::try_from(object) {
                            if !node.children.is_empty() {
                                let transform = transform * node.transform();
                                queue.reserve(node.children.len());
                                for child in &node.children {
                                    queue.push_back((child.key, transform));
                                }
                            }
                            continue;
                        }
                        if let Ok(geometry) = <&T>::try_from(object) {
                            let transform = transform * geometry.as_ref().transform();
                            return Some((geometry, transform));
                        }
                    }
                    None
                })
            }
            /// Bounding sphere encompassing all geometries in the stream.
            ///
            pub fn bounding_sphere(&self) -> Option<NiBound> {
                NiBound::from_geometries(
                    self
                        .geometries::<NiGeometry>()
                        .filter_map(|(geom, transform)| Some((
                            self.get(geom.geometry_data)?,
                            transform,
                        ))),
                )
            }
            /// Axis-aligned bounding box encompassing all geometries in the stream.
            ///
            pub fn bounding_box(&self) -> Option<(Vec3, Vec3)> {
                NiBound::aabb_from_geometries(
                    self
                        .geometries::<NiGeometry>()
                        .filter_map(|(geom, transform)| Some((
                            self.get(geom.geometry_data)?,
                            transform,
                        ))),
                )
            }
            /// Convenience function for case-insensitive prefix searches.
            ///
            pub fn root_has_string_data_starting_with(&self, prefix: &str) -> bool {
                for root in self.roots_of_type::<NiObjectNET>() {
                    for data in root.extra_datas_of_type::<NiStringExtraData>(self) {
                        if data.starts_with_ignore_ascii_case(prefix) {
                            return true;
                        }
                    }
                }
                false
            }
            /// Get a link to the given object, or null if it is not in this stream.
            ///
            pub fn get_link(&self, object: impl AsRef<NiObject>) -> NiLink<NiObject> {
                let object = object.as_ref();
                self.objects_of_type_with_link::<NiObject>()
                    .find_map(|(link, other)| {
                        std::ptr::eq(object, other).then_some(link)
                    })
                    .unwrap_or_default()
            }
            pub fn clear_root_transforms(&mut self) {
                for root in &self.roots {
                    let _ = self
                        .objects
                        .get_mut(root.key)
                        .and_then(|object| object.try_into().ok())
                        .map(NiAVObject::clear_transform);
                }
            }
        }
        pub fn convert_nif_mesh(data: &NiTriShapeData) -> Option<Mesh> {
            let vertices = data.base.vertices.clone();
            let normals = data.base.normals.clone();
            let uvs = data.base.uv_sets.clone();
            let indices = data.triangles.clone();
            let mut mesh = Mesh::new(
                    PrimitiveTopology::TriangleList,
                    RenderAssetUsages::default(),
                )
                .with_inserted_attribute(Mesh::ATTRIBUTE_POSITION, vertices);
            let final_mesh_opt: Option<Mesh>;
            if !normals.is_empty() {
                mesh.insert_attribute(Mesh::ATTRIBUTE_NORMAL, normals);
                if !uvs.is_empty() {
                    mesh.insert_attribute(Mesh::ATTRIBUTE_UV_0, uvs);
                }
                mesh.insert_indices(Indices::U16(indices));
                final_mesh_opt = Some(mesh);
            } else {
                final_mesh_opt = create_mesh_with_flat_normals(
                    &data.vertices,
                    &data.triangles,
                    if uvs.is_empty() { None } else { Some(&uvs) },
                );
            }
            if let Some(mesh) = final_mesh_opt { Some(mesh) } else { None }
        }
        fn create_mesh_with_flat_normals(
            original_vertices_nif: &Vec<[f32; 3]>,
            original_indices: &[u16],
            original_uvs: Option<&Vec<[f32; 2]>>,
        ) -> Option<Mesh> {
            let vertex_count = original_vertices_nif.len();
            if vertex_count == 0 {
                {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "event libs/nif/src/types/nistream.rs:564",
                                "nif::types::nistream",
                                ::tracing::Level::WARN,
                                ::tracing_core::__macro_support::Option::Some(
                                    "libs/nif/src/types/nistream.rs",
                                ),
                                ::tracing_core::__macro_support::Option::Some(564u32),
                                ::tracing_core::__macro_support::Option::Some(
                                    "nif::types::nistream",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["message"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::EVENT,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let enabled = ::tracing::Level::WARN
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && ::tracing::Level::WARN
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            let interest = __CALLSITE.interest();
                            !interest.is_never()
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                        };
                    if enabled {
                        (|value_set: ::tracing::field::ValueSet| {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Event::dispatch(meta, &value_set);
                        })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = __CALLSITE.metadata().fields().iter();
                            __CALLSITE
                                .metadata()
                                .fields()
                                .value_set(
                                    &[
                                        (
                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::tracing::__macro_support::Option::Some(
                                                &format_args!(
                                                    "Cannot compute flat normals: No vertices provided.",
                                                ) as &dyn Value,
                                            ),
                                        ),
                                    ],
                                )
                        });
                    } else {
                    }
                };
                return None;
            }
            if original_indices.is_empty() {
                {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "event libs/nif/src/types/nistream.rs:568",
                                "nif::types::nistream",
                                ::tracing::Level::WARN,
                                ::tracing_core::__macro_support::Option::Some(
                                    "libs/nif/src/types/nistream.rs",
                                ),
                                ::tracing_core::__macro_support::Option::Some(568u32),
                                ::tracing_core::__macro_support::Option::Some(
                                    "nif::types::nistream",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["message"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::EVENT,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let enabled = ::tracing::Level::WARN
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && ::tracing::Level::WARN
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            let interest = __CALLSITE.interest();
                            !interest.is_never()
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                        };
                    if enabled {
                        (|value_set: ::tracing::field::ValueSet| {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Event::dispatch(meta, &value_set);
                        })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = __CALLSITE.metadata().fields().iter();
                            __CALLSITE
                                .metadata()
                                .fields()
                                .value_set(
                                    &[
                                        (
                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::tracing::__macro_support::Option::Some(
                                                &format_args!(
                                                    "Cannot compute flat normals: No indices provided.",
                                                ) as &dyn Value,
                                            ),
                                        ),
                                    ],
                                )
                        });
                    } else {
                    }
                };
                return None;
            }
            if original_indices.len() % 3 != 0 {
                {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "event libs/nif/src/types/nistream.rs:572",
                                "nif::types::nistream",
                                ::tracing::Level::WARN,
                                ::tracing_core::__macro_support::Option::Some(
                                    "libs/nif/src/types/nistream.rs",
                                ),
                                ::tracing_core::__macro_support::Option::Some(572u32),
                                ::tracing_core::__macro_support::Option::Some(
                                    "nif::types::nistream",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["message"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::EVENT,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let enabled = ::tracing::Level::WARN
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && ::tracing::Level::WARN
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            let interest = __CALLSITE.interest();
                            !interest.is_never()
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                        };
                    if enabled {
                        (|value_set: ::tracing::field::ValueSet| {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Event::dispatch(meta, &value_set);
                        })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = __CALLSITE.metadata().fields().iter();
                            __CALLSITE
                                .metadata()
                                .fields()
                                .value_set(
                                    &[
                                        (
                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::tracing::__macro_support::Option::Some(
                                                &format_args!(
                                                    "Cannot compute flat normals: Index count ({0}) is not a multiple of 3.",
                                                    original_indices.len(),
                                                ) as &dyn Value,
                                            ),
                                        ),
                                    ],
                                )
                        });
                    } else {
                    }
                };
                return None;
            }
            let num_triangles = original_indices.len() / 3;
            let new_vertex_count = num_triangles * 3;
            let mut final_vertices: Vec<[f32; 3]> = Vec::with_capacity(new_vertex_count);
            let mut final_normals: Vec<[f32; 3]> = Vec::with_capacity(new_vertex_count);
            let mut final_indices: Vec<u16> = Vec::with_capacity(new_vertex_count);
            let mut final_uvs: Option<Vec<[f32; 2]>> = original_uvs
                .map(|_| Vec::with_capacity(new_vertex_count));
            for i in 0..num_triangles {
                let idx0_u16 = original_indices[i * 3];
                let idx1_u16 = original_indices[i * 3 + 1];
                let idx2_u16 = original_indices[i * 3 + 2];
                let idx0 = idx0_u16 as usize;
                let idx1 = idx1_u16 as usize;
                let idx2 = idx2_u16 as usize;
                if idx0 >= vertex_count || idx1 >= vertex_count || idx2 >= vertex_count {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event libs/nif/src/types/nistream.rs:601",
                                    "nif::types::nistream",
                                    ::tracing::Level::WARN,
                                    ::tracing_core::__macro_support::Option::Some(
                                        "libs/nif/src/types/nistream.rs",
                                    ),
                                    ::tracing_core::__macro_support::Option::Some(601u32),
                                    ::tracing_core::__macro_support::Option::Some(
                                        "nif::types::nistream",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::WARN
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::WARN
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::tracing::__macro_support::Option::Some(
                                                    &format_args!(
                                                        "Skipping triangle {0} due to out-of-bounds index (Indices: {1}, {2}, {3}; Vertex Count: {4}).",
                                                        i,
                                                        idx0_u16,
                                                        idx1_u16,
                                                        idx2_u16,
                                                        vertex_count,
                                                    ) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    continue;
                }
                let v0 = Vec3::from_array(original_vertices_nif[idx0]);
                let v1 = Vec3::from_array(original_vertices_nif[idx1]);
                let v2 = Vec3::from_array(original_vertices_nif[idx2]);
                let edge1 = v1 - v0;
                let edge2 = v2 - v0;
                let face_normal = edge1.cross(edge2);
                let normalized_normal_array = face_normal
                    .try_normalize()
                    .unwrap_or(Vec3::Y)
                    .to_array();
                final_vertices.push(v0.to_array());
                final_vertices.push(v1.to_array());
                final_vertices.push(v2.to_array());
                final_normals.push(normalized_normal_array);
                final_normals.push(normalized_normal_array);
                final_normals.push(normalized_normal_array);
                let base_index = (i * 3) as u16;
                final_indices.push(base_index);
                final_indices.push(base_index + 1);
                final_indices.push(base_index + 2);
                if let Some(ref mut uvs_out) = final_uvs {
                    if let Some(uvs_in) = original_uvs {
                        if idx0 < uvs_in.len() && idx1 < uvs_in.len()
                            && idx2 < uvs_in.len()
                        {
                            uvs_out.push(uvs_in[idx0]);
                            uvs_out.push(uvs_in[idx1]);
                            uvs_out.push(uvs_in[idx2]);
                        } else {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event libs/nif/src/types/nistream.rs:650",
                                            "nif::types::nistream",
                                            ::tracing::Level::WARN,
                                            ::tracing_core::__macro_support::Option::Some(
                                                "libs/nif/src/types/nistream.rs",
                                            ),
                                            ::tracing_core::__macro_support::Option::Some(650u32),
                                            ::tracing_core::__macro_support::Option::Some(
                                                "nif::types::nistream",
                                            ),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::WARN
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::WARN
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::tracing::__macro_support::Option::Some(
                                                            &format_args!(
                                                                "Missing UV data for original indices in triangle {0}, using default [0,0].",
                                                                i,
                                                            ) as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                            uvs_out.push([0.0, 0.0]);
                            uvs_out.push([0.0, 0.0]);
                            uvs_out.push([0.0, 0.0]);
                        }
                    }
                }
            }
            if final_vertices.len() != final_normals.len() {
                {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "event libs/nif/src/types/nistream.rs:661",
                                "nif::types::nistream",
                                ::tracing::Level::ERROR,
                                ::tracing_core::__macro_support::Option::Some(
                                    "libs/nif/src/types/nistream.rs",
                                ),
                                ::tracing_core::__macro_support::Option::Some(661u32),
                                ::tracing_core::__macro_support::Option::Some(
                                    "nif::types::nistream",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["message"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::EVENT,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let enabled = ::tracing::Level::ERROR
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && ::tracing::Level::ERROR
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            let interest = __CALLSITE.interest();
                            !interest.is_never()
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                        };
                    if enabled {
                        (|value_set: ::tracing::field::ValueSet| {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Event::dispatch(meta, &value_set);
                        })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = __CALLSITE.metadata().fields().iter();
                            __CALLSITE
                                .metadata()
                                .fields()
                                .value_set(
                                    &[
                                        (
                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::tracing::__macro_support::Option::Some(
                                                &format_args!(
                                                    "Manual flat normal calculation resulted in mismatch! Verts: {0}, Norms: {1}",
                                                    final_vertices.len(),
                                                    final_normals.len(),
                                                ) as &dyn Value,
                                            ),
                                        ),
                                    ],
                                )
                        });
                    } else {
                    }
                };
                return None;
            }
            if let Some(ref uvs) = final_uvs {
                if final_vertices.len() != uvs.len() {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event libs/nif/src/types/nistream.rs:671",
                                    "nif::types::nistream",
                                    ::tracing::Level::ERROR,
                                    ::tracing_core::__macro_support::Option::Some(
                                        "libs/nif/src/types/nistream.rs",
                                    ),
                                    ::tracing_core::__macro_support::Option::Some(671u32),
                                    ::tracing_core::__macro_support::Option::Some(
                                        "nif::types::nistream",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::ERROR
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::ERROR
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::tracing::__macro_support::Option::Some(
                                                    &format_args!(
                                                        "Manual flat normal calculation resulted in UV mismatch! Verts: {0}, UVs: {1}",
                                                        final_vertices.len(),
                                                        uvs.len(),
                                                    ) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                }
            }
            let mut mesh = Mesh::new(
                    PrimitiveTopology::TriangleList,
                    RenderAssetUsages::default(),
                )
                .with_inserted_attribute(Mesh::ATTRIBUTE_POSITION, final_vertices)
                .with_inserted_attribute(Mesh::ATTRIBUTE_NORMAL, final_normals);
            if let Some(final_uvs_vec) = final_uvs {
                mesh.insert_attribute(Mesh::ATTRIBUTE_UV_0, final_uvs_vec);
            }
            mesh.insert_indices(Indices::U16(final_indices));
            {
                use ::tracing::__macro_support::Callsite as _;
                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "event libs/nif/src/types/nistream.rs:691",
                            "nif::types::nistream",
                            ::tracing::Level::INFO,
                            ::tracing_core::__macro_support::Option::Some(
                                "libs/nif/src/types/nistream.rs",
                            ),
                            ::tracing_core::__macro_support::Option::Some(691u32),
                            ::tracing_core::__macro_support::Option::Some(
                                "nif::types::nistream",
                            ),
                            ::tracing_core::field::FieldSet::new(
                                &["message"],
                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                            ),
                            ::tracing::metadata::Kind::EVENT,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let enabled = ::tracing::Level::INFO
                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && ::tracing::Level::INFO
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        let interest = __CALLSITE.interest();
                        !interest.is_never()
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                    };
                if enabled {
                    (|value_set: ::tracing::field::ValueSet| {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Event::dispatch(meta, &value_set);
                    })({
                        #[allow(unused_imports)]
                        use ::tracing::field::{debug, display, Value};
                        let mut iter = __CALLSITE.metadata().fields().iter();
                        __CALLSITE
                            .metadata()
                            .fields()
                            .value_set(
                                &[
                                    (
                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                            .expect("FieldSet corrupted (this is a bug)"),
                                        ::tracing::__macro_support::Option::Some(
                                            &format_args!(
                                                "Successfully computed flat normals. Final vertex count: {0}",
                                                mesh.count_vertices(),
                                            ) as &dyn Value,
                                        ),
                                    ),
                                ],
                            )
                    });
                } else {
                }
            };
            Some(mesh)
        }
    }
    mod nistringextradata {
        use crate::prelude::*;
        pub struct NiStringExtraData {
            pub base: NiExtraData,
            pub value: String,
        }
        impl NiStringExtraData {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiStringExtraData"
            }
        }
        impl Visitor for NiStringExtraData {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.value).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiStringExtraData {
            type Target = NiExtraData;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiStringExtraData {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiStringExtraData {
            #[inline]
            fn clone(&self) -> NiStringExtraData {
                NiStringExtraData {
                    base: ::core::clone::Clone::clone(&self.base),
                    value: ::core::clone::Clone::clone(&self.value),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiStringExtraData {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "NiStringExtraData",
                    "base",
                    &self.base,
                    "value",
                    &&self.value,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiStringExtraData {
            #[inline]
            fn default() -> NiStringExtraData {
                NiStringExtraData {
                    base: ::core::default::Default::default(),
                    value: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiStringExtraData {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiStringExtraData {
            #[inline]
            fn eq(&self, other: &NiStringExtraData) -> bool {
                self.base == other.base && self.value == other.value
            }
        }
        impl Load for NiStringExtraData {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let value = stream.load()?;
                Ok(Self { base, value })
            }
        }
        impl Save for NiStringExtraData {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save_string_without_null_terminator(&self.value)?;
                Ok(())
            }
        }
        impl NiStringExtraData {
            pub fn starts_with_ignore_ascii_case(&self, prefix: &str) -> bool {
                self.value
                    .bytes()
                    .zip(prefix.bytes())
                    .all(|(a, b)| a.eq_ignore_ascii_case(&b))
            }
        }
    }
    mod niswitchnode {
        use crate::prelude::*;
        pub struct NiSwitchNode {
            pub base: NiNode,
            pub active_index: usize,
        }
        impl NiSwitchNode {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiSwitchNode"
            }
        }
        impl Visitor for NiSwitchNode {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.active_index).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiSwitchNode {
            type Target = NiNode;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiSwitchNode {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiSwitchNode {
            #[inline]
            fn clone(&self) -> NiSwitchNode {
                NiSwitchNode {
                    base: ::core::clone::Clone::clone(&self.base),
                    active_index: ::core::clone::Clone::clone(&self.active_index),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiSwitchNode {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "NiSwitchNode",
                    "base",
                    &self.base,
                    "active_index",
                    &&self.active_index,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiSwitchNode {
            #[inline]
            fn default() -> NiSwitchNode {
                NiSwitchNode {
                    base: ::core::default::Default::default(),
                    active_index: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiSwitchNode {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiSwitchNode {
            #[inline]
            fn eq(&self, other: &NiSwitchNode) -> bool {
                self.base == other.base && self.active_index == other.active_index
            }
        }
        impl Load for NiSwitchNode {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let active_index = stream.load_as::<u32, usize>()?;
                Ok(Self { base, active_index })
            }
        }
        impl Save for NiSwitchNode {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save_as::<u32>(self.active_index)?;
                Ok(())
            }
        }
        impl NiSwitchNode {
            #[inline]
            pub fn update_only_active(&self) -> bool {
                self.flags & 0x0020 != 0
            }
            #[inline]
            pub fn set_update_only_active(&mut self, value: bool) {
                if value {
                    self.flags |= 0x0020;
                } else {
                    self.flags &= !0x0020;
                }
            }
        }
    }
    mod nitextkeyextradata {
        use crate::prelude::*;
        pub struct NiTextKeyExtraData {
            pub base: NiExtraData,
            pub keys: Vec<NiTextKey>,
        }
        impl NiTextKeyExtraData {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiTextKeyExtraData"
            }
        }
        impl Visitor for NiTextKeyExtraData {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.keys).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiTextKeyExtraData {
            type Target = NiExtraData;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiTextKeyExtraData {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiTextKeyExtraData {
            #[inline]
            fn clone(&self) -> NiTextKeyExtraData {
                NiTextKeyExtraData {
                    base: ::core::clone::Clone::clone(&self.base),
                    keys: ::core::clone::Clone::clone(&self.keys),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiTextKeyExtraData {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "NiTextKeyExtraData",
                    "base",
                    &self.base,
                    "keys",
                    &&self.keys,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiTextKeyExtraData {
            #[inline]
            fn default() -> NiTextKeyExtraData {
                NiTextKeyExtraData {
                    base: ::core::default::Default::default(),
                    keys: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiTextKeyExtraData {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiTextKeyExtraData {
            #[inline]
            fn eq(&self, other: &NiTextKeyExtraData) -> bool {
                self.base == other.base && self.keys == other.keys
            }
        }
        impl Load for NiTextKeyExtraData {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let keys = stream.load()?;
                Ok(Self { base, keys })
            }
        }
        impl Save for NiTextKeyExtraData {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save(&self.keys)?;
                Ok(())
            }
        }
        pub struct NiTextKey {
            pub time: f32,
            pub value: String,
        }
        impl NiTextKey {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiTextKey"
            }
        }
        impl Visitor for NiTextKey {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.value).visitor(f);
                (&self.time).visitor(f);
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiTextKey {
            #[inline]
            fn clone(&self) -> NiTextKey {
                NiTextKey {
                    time: ::core::clone::Clone::clone(&self.time),
                    value: ::core::clone::Clone::clone(&self.value),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiTextKey {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "NiTextKey",
                    "time",
                    &self.time,
                    "value",
                    &&self.value,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiTextKey {
            #[inline]
            fn default() -> NiTextKey {
                NiTextKey {
                    time: ::core::default::Default::default(),
                    value: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiTextKey {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiTextKey {
            #[inline]
            fn eq(&self, other: &NiTextKey) -> bool {
                self.time == other.time && self.value == other.value
            }
        }
        impl Load for NiTextKey {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let time = stream.load()?;
                let value = stream.load()?;
                Ok(Self { time, value })
            }
        }
        impl Save for NiTextKey {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.time)?;
                stream.save_string_without_null_terminator(&self.value)?;
                Ok(())
            }
        }
    }
    mod nitexture {
        use crate::prelude::*;
        pub struct NiTexture {
            pub base: NiObjectNET,
        }
        impl NiTexture {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiTexture"
            }
        }
        impl Visitor for NiTexture {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiTexture {
            type Target = NiObjectNET;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiTexture {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiTexture {
            #[inline]
            fn clone(&self) -> NiTexture {
                NiTexture {
                    base: ::core::clone::Clone::clone(&self.base),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiTexture {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "NiTexture",
                    "base",
                    &&self.base,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiTexture {
            #[inline]
            fn default() -> NiTexture {
                NiTexture {
                    base: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiTexture {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiTexture {
            #[inline]
            fn eq(&self, other: &NiTexture) -> bool {
                self.base == other.base
            }
        }
        impl Load for NiTexture {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                Ok(Self { base })
            }
        }
        impl Save for NiTexture {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                Ok(())
            }
        }
    }
    mod nitextureeffect {
        use crate::prelude::*;
        pub struct NiTextureEffect {
            pub base: NiDynamicEffect,
            #[default(Mat3::IDENTITY)]
            pub projection_matrix: Mat3,
            pub projection_translation: Vec3,
            pub texture_filter: FilterMode,
            pub texture_clamp: ClampMode,
            pub texture_type: TextureType,
            pub coordinate_generation_type: CoordGenType,
            pub source_texture: NiLink<NiSourceTexture>,
            pub clipping_plane_enable: u8,
            pub clipping_plane: [f32; 4],
            pub ps2_l: i16,
            #[default((-75))]
            pub ps2_k: i16,
            pub unknown_byte1: u8,
            pub unknown_byte2: u8,
        }
        impl NiTextureEffect {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiTextureEffect"
            }
        }
        impl Visitor for NiTextureEffect {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.unknown_byte2).visitor(f);
                (&self.unknown_byte1).visitor(f);
                (&self.ps2_k).visitor(f);
                (&self.ps2_l).visitor(f);
                (&self.clipping_plane).visitor(f);
                (&self.clipping_plane_enable).visitor(f);
                (&self.source_texture).visitor(f);
                (&self.coordinate_generation_type).visitor(f);
                (&self.texture_type).visitor(f);
                (&self.texture_clamp).visitor(f);
                (&self.texture_filter).visitor(f);
                (&self.projection_translation).visitor(f);
                (&self.projection_matrix).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiTextureEffect {
            type Target = NiDynamicEffect;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiTextureEffect {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiTextureEffect {
            #[inline]
            fn clone(&self) -> NiTextureEffect {
                NiTextureEffect {
                    base: ::core::clone::Clone::clone(&self.base),
                    projection_matrix: ::core::clone::Clone::clone(
                        &self.projection_matrix,
                    ),
                    projection_translation: ::core::clone::Clone::clone(
                        &self.projection_translation,
                    ),
                    texture_filter: ::core::clone::Clone::clone(&self.texture_filter),
                    texture_clamp: ::core::clone::Clone::clone(&self.texture_clamp),
                    texture_type: ::core::clone::Clone::clone(&self.texture_type),
                    coordinate_generation_type: ::core::clone::Clone::clone(
                        &self.coordinate_generation_type,
                    ),
                    source_texture: ::core::clone::Clone::clone(&self.source_texture),
                    clipping_plane_enable: ::core::clone::Clone::clone(
                        &self.clipping_plane_enable,
                    ),
                    clipping_plane: ::core::clone::Clone::clone(&self.clipping_plane),
                    ps2_l: ::core::clone::Clone::clone(&self.ps2_l),
                    ps2_k: ::core::clone::Clone::clone(&self.ps2_k),
                    unknown_byte1: ::core::clone::Clone::clone(&self.unknown_byte1),
                    unknown_byte2: ::core::clone::Clone::clone(&self.unknown_byte2),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiTextureEffect {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "base",
                    "projection_matrix",
                    "projection_translation",
                    "texture_filter",
                    "texture_clamp",
                    "texture_type",
                    "coordinate_generation_type",
                    "source_texture",
                    "clipping_plane_enable",
                    "clipping_plane",
                    "ps2_l",
                    "ps2_k",
                    "unknown_byte1",
                    "unknown_byte2",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.base,
                    &self.projection_matrix,
                    &self.projection_translation,
                    &self.texture_filter,
                    &self.texture_clamp,
                    &self.texture_type,
                    &self.coordinate_generation_type,
                    &self.source_texture,
                    &self.clipping_plane_enable,
                    &self.clipping_plane,
                    &self.ps2_l,
                    &self.ps2_k,
                    &self.unknown_byte1,
                    &&self.unknown_byte2,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "NiTextureEffect",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiTextureEffect {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiTextureEffect {
            #[inline]
            fn eq(&self, other: &NiTextureEffect) -> bool {
                self.clipping_plane_enable == other.clipping_plane_enable
                    && self.ps2_l == other.ps2_l && self.ps2_k == other.ps2_k
                    && self.unknown_byte1 == other.unknown_byte1
                    && self.unknown_byte2 == other.unknown_byte2
                    && self.base == other.base
                    && self.projection_matrix == other.projection_matrix
                    && self.projection_translation == other.projection_translation
                    && self.texture_filter == other.texture_filter
                    && self.texture_clamp == other.texture_clamp
                    && self.texture_type == other.texture_type
                    && self.coordinate_generation_type
                        == other.coordinate_generation_type
                    && self.source_texture == other.source_texture
                    && self.clipping_plane == other.clipping_plane
            }
        }
        #[automatically_derived]
        impl Default for NiTextureEffect {
            /**Return `NiTextureEffect {
    base: Default::default(),
    projection_matrix: Mat3::IDENTITY,
    projection_translation: Default::default(),
    texture_filter: Default::default(),
    texture_clamp: Default::default(),
    texture_type: Default::default(),
    coordinate_generation_type: Default::default(),
    source_texture: Default::default(),
    clipping_plane_enable: Default::default(),
    clipping_plane: Default::default(),
    ps2_l: Default::default(),
    ps2_k: (-75),
    unknown_byte1: Default::default(),
    unknown_byte2: Default::default()
}`*/
            fn default() -> Self {
                NiTextureEffect {
                    base: Default::default(),
                    projection_matrix: Mat3::IDENTITY,
                    projection_translation: Default::default(),
                    texture_filter: Default::default(),
                    texture_clamp: Default::default(),
                    texture_type: Default::default(),
                    coordinate_generation_type: Default::default(),
                    source_texture: Default::default(),
                    clipping_plane_enable: Default::default(),
                    clipping_plane: Default::default(),
                    ps2_l: Default::default(),
                    ps2_k: (-75),
                    unknown_byte1: Default::default(),
                    unknown_byte2: Default::default(),
                }
            }
        }
        impl Load for NiTextureEffect {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let projection_matrix = stream.load()?;
                let projection_translation = stream.load()?;
                let texture_filter = stream.load()?;
                let texture_clamp = stream.load()?;
                let texture_type = stream.load()?;
                let coordinate_generation_type = stream.load()?;
                let source_texture = stream.load()?;
                let clipping_plane_enable = stream.load()?;
                let clipping_plane = stream.load()?;
                let ps2_l = stream.load()?;
                let ps2_k = stream.load()?;
                let unknown_byte1 = stream.load()?;
                let unknown_byte2 = stream.load()?;
                Ok(Self {
                    base,
                    projection_matrix,
                    projection_translation,
                    texture_filter,
                    texture_clamp,
                    texture_type,
                    coordinate_generation_type,
                    source_texture,
                    clipping_plane_enable,
                    clipping_plane,
                    ps2_l,
                    ps2_k,
                    unknown_byte1,
                    unknown_byte2,
                })
            }
        }
        impl Save for NiTextureEffect {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save(&self.projection_matrix)?;
                stream.save(&self.projection_translation)?;
                stream.save(&self.texture_filter)?;
                stream.save(&self.texture_clamp)?;
                stream.save(&self.texture_type)?;
                stream.save(&self.coordinate_generation_type)?;
                stream.save(&self.source_texture)?;
                stream.save(&self.clipping_plane_enable)?;
                stream.save(&self.clipping_plane)?;
                stream.save(&self.ps2_l)?;
                stream.save(&self.ps2_k)?;
                stream.save(&self.unknown_byte1)?;
                stream.save(&self.unknown_byte2)?;
                Ok(())
            }
        }
    }
    mod nitexturingproperty {
        use crate::prelude::*;
        const BUMP_INDEX: u32 = 5;
        pub struct NiTexturingProperty {
            pub base: NiProperty,
            pub apply_mode: ApplyMode,
            pub texture_maps: Vec<Option<TextureMap>>,
        }
        impl NiTexturingProperty {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiTexturingProperty"
            }
        }
        impl Visitor for NiTexturingProperty {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.texture_maps).visitor(f);
                (&self.apply_mode).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiTexturingProperty {
            type Target = NiProperty;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiTexturingProperty {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiTexturingProperty {
            #[inline]
            fn clone(&self) -> NiTexturingProperty {
                NiTexturingProperty {
                    base: ::core::clone::Clone::clone(&self.base),
                    apply_mode: ::core::clone::Clone::clone(&self.apply_mode),
                    texture_maps: ::core::clone::Clone::clone(&self.texture_maps),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiTexturingProperty {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "NiTexturingProperty",
                    "base",
                    &self.base,
                    "apply_mode",
                    &self.apply_mode,
                    "texture_maps",
                    &&self.texture_maps,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiTexturingProperty {
            #[inline]
            fn default() -> NiTexturingProperty {
                NiTexturingProperty {
                    base: ::core::default::Default::default(),
                    apply_mode: ::core::default::Default::default(),
                    texture_maps: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiTexturingProperty {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiTexturingProperty {
            #[inline]
            fn eq(&self, other: &NiTexturingProperty) -> bool {
                self.base == other.base && self.apply_mode == other.apply_mode
                    && self.texture_maps == other.texture_maps
            }
        }
        impl Load for NiTexturingProperty {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let apply_mode = stream.load()?;
                let num_texture_maps: u32 = stream.load()?;
                let texture_maps = (0..num_texture_maps)
                    .load(|i| {
                        Ok({
                            let has_map = stream.load::<u32>()? != 0;
                            if !has_map {
                                None
                            } else if i == BUMP_INDEX {
                                Some(TextureMap::BumpMap(stream.load()?))
                            } else {
                                Some(TextureMap::Map(stream.load()?))
                            }
                        })
                    })?;
                Ok(Self {
                    base,
                    apply_mode,
                    texture_maps,
                })
            }
        }
        impl Save for NiTexturingProperty {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save(&self.apply_mode)?;
                stream.save_as::<u32>(self.texture_maps.len())?;
                for slot in &self.texture_maps {
                    stream.save_as::<u32>(slot.is_some())?;
                    match &slot {
                        None => continue,
                        Some(TextureMap::Map(map)) => stream.save(map)?,
                        Some(TextureMap::BumpMap(map)) => stream.save(map)?,
                    }
                }
                Ok(())
            }
        }
        pub enum TextureMap {
            #[default]
            Map(Map),
            BumpMap(BumpMap),
        }
        #[automatically_derived]
        impl ::core::clone::Clone for TextureMap {
            #[inline]
            fn clone(&self) -> TextureMap {
                match self {
                    TextureMap::Map(__self_0) => {
                        TextureMap::Map(::core::clone::Clone::clone(__self_0))
                    }
                    TextureMap::BumpMap(__self_0) => {
                        TextureMap::BumpMap(::core::clone::Clone::clone(__self_0))
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for TextureMap {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    TextureMap::Map(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Map",
                            &__self_0,
                        )
                    }
                    TextureMap::BumpMap(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "BumpMap",
                            &__self_0,
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for TextureMap {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for TextureMap {
            #[inline]
            fn eq(&self, other: &TextureMap) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
                    && match (self, other) {
                        (TextureMap::Map(__self_0), TextureMap::Map(__arg1_0)) => {
                            __self_0 == __arg1_0
                        }
                        (
                            TextureMap::BumpMap(__self_0),
                            TextureMap::BumpMap(__arg1_0),
                        ) => __self_0 == __arg1_0,
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
            }
        }
        #[automatically_derived]
        impl Default for TextureMap {
            ///Return `TextureMap::Map(Default::default())`
            fn default() -> Self {
                TextureMap::Map(Default::default())
            }
        }
        pub struct Map {
            pub base: NiObject,
            pub texture: NiLink<NiSourceTexture>,
            pub clamp_mode: ClampMode,
            pub filter_mode: FilterMode,
            pub texture_index: usize,
            pub ps2_l: i16,
            #[default((-75))]
            pub ps2_k: i16,
            pub unknown_flag1: u8,
            pub unknown_flag2: u8,
        }
        impl Map {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"Map"
            }
        }
        impl Visitor for Map {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.unknown_flag2).visitor(f);
                (&self.unknown_flag1).visitor(f);
                (&self.ps2_k).visitor(f);
                (&self.ps2_l).visitor(f);
                (&self.texture_index).visitor(f);
                (&self.filter_mode).visitor(f);
                (&self.clamp_mode).visitor(f);
                (&self.texture).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for Map {
            type Target = NiObject;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for Map {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Map {
            #[inline]
            fn clone(&self) -> Map {
                Map {
                    base: ::core::clone::Clone::clone(&self.base),
                    texture: ::core::clone::Clone::clone(&self.texture),
                    clamp_mode: ::core::clone::Clone::clone(&self.clamp_mode),
                    filter_mode: ::core::clone::Clone::clone(&self.filter_mode),
                    texture_index: ::core::clone::Clone::clone(&self.texture_index),
                    ps2_l: ::core::clone::Clone::clone(&self.ps2_l),
                    ps2_k: ::core::clone::Clone::clone(&self.ps2_k),
                    unknown_flag1: ::core::clone::Clone::clone(&self.unknown_flag1),
                    unknown_flag2: ::core::clone::Clone::clone(&self.unknown_flag2),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Map {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "base",
                    "texture",
                    "clamp_mode",
                    "filter_mode",
                    "texture_index",
                    "ps2_l",
                    "ps2_k",
                    "unknown_flag1",
                    "unknown_flag2",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.base,
                    &self.texture,
                    &self.clamp_mode,
                    &self.filter_mode,
                    &self.texture_index,
                    &self.ps2_l,
                    &self.ps2_k,
                    &self.unknown_flag1,
                    &&self.unknown_flag2,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "Map",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Map {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Map {
            #[inline]
            fn eq(&self, other: &Map) -> bool {
                self.ps2_l == other.ps2_l && self.ps2_k == other.ps2_k
                    && self.unknown_flag1 == other.unknown_flag1
                    && self.unknown_flag2 == other.unknown_flag2
                    && self.base == other.base && self.texture == other.texture
                    && self.clamp_mode == other.clamp_mode
                    && self.filter_mode == other.filter_mode
                    && self.texture_index == other.texture_index
            }
        }
        #[automatically_derived]
        impl Default for Map {
            /**Return `Map {
    base: Default::default(),
    texture: Default::default(),
    clamp_mode: Default::default(),
    filter_mode: Default::default(),
    texture_index: Default::default(),
    ps2_l: Default::default(),
    ps2_k: (-75),
    unknown_flag1: Default::default(),
    unknown_flag2: Default::default()
}`*/
            fn default() -> Self {
                Map {
                    base: Default::default(),
                    texture: Default::default(),
                    clamp_mode: Default::default(),
                    filter_mode: Default::default(),
                    texture_index: Default::default(),
                    ps2_l: Default::default(),
                    ps2_k: (-75),
                    unknown_flag1: Default::default(),
                    unknown_flag2: Default::default(),
                }
            }
        }
        impl Load for Map {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let texture = stream.load()?;
                let clamp_mode = stream.load()?;
                let filter_mode = stream.load()?;
                let texture_index = stream.load_as::<u32, usize>()?;
                let ps2_l = stream.load()?;
                let ps2_k = stream.load()?;
                let unknown_flag1 = stream.load()?;
                let unknown_flag2 = stream.load()?;
                Ok(Self {
                    base,
                    texture,
                    clamp_mode,
                    filter_mode,
                    texture_index,
                    ps2_l,
                    ps2_k,
                    unknown_flag1,
                    unknown_flag2,
                })
            }
        }
        impl Save for Map {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save(&self.texture)?;
                stream.save(&self.clamp_mode)?;
                stream.save(&self.filter_mode)?;
                stream.save_as::<u32>(self.texture_index)?;
                stream.save(&self.ps2_l)?;
                stream.save(&self.ps2_k)?;
                stream.save(&self.unknown_flag1)?;
                stream.save(&self.unknown_flag2)?;
                Ok(())
            }
        }
        pub struct BumpMap {
            pub base: Map,
            pub luma_scale: f32,
            pub luma_offset: f32,
            #[default(Mat2::IDENTITY)]
            pub displacement: Mat2,
        }
        impl BumpMap {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"BumpMap"
            }
        }
        impl Visitor for BumpMap {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.displacement).visitor(f);
                (&self.luma_offset).visitor(f);
                (&self.luma_scale).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for BumpMap {
            type Target = Map;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for BumpMap {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for BumpMap {
            #[inline]
            fn clone(&self) -> BumpMap {
                BumpMap {
                    base: ::core::clone::Clone::clone(&self.base),
                    luma_scale: ::core::clone::Clone::clone(&self.luma_scale),
                    luma_offset: ::core::clone::Clone::clone(&self.luma_offset),
                    displacement: ::core::clone::Clone::clone(&self.displacement),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for BumpMap {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "BumpMap",
                    "base",
                    &self.base,
                    "luma_scale",
                    &self.luma_scale,
                    "luma_offset",
                    &self.luma_offset,
                    "displacement",
                    &&self.displacement,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for BumpMap {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for BumpMap {
            #[inline]
            fn eq(&self, other: &BumpMap) -> bool {
                self.luma_scale == other.luma_scale
                    && self.luma_offset == other.luma_offset && self.base == other.base
                    && self.displacement == other.displacement
            }
        }
        #[automatically_derived]
        impl Default for BumpMap {
            /**Return `BumpMap {
    base: Default::default(),
    luma_scale: Default::default(),
    luma_offset: Default::default(),
    displacement: Mat2::IDENTITY
}`*/
            fn default() -> Self {
                BumpMap {
                    base: Default::default(),
                    luma_scale: Default::default(),
                    luma_offset: Default::default(),
                    displacement: Mat2::IDENTITY,
                }
            }
        }
        impl Load for BumpMap {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let luma_scale = stream.load()?;
                let luma_offset = stream.load()?;
                let displacement = stream.load()?;
                Ok(Self {
                    base,
                    luma_scale,
                    luma_offset,
                    displacement,
                })
            }
        }
        impl Save for BumpMap {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save(&self.luma_scale)?;
                stream.save(&self.luma_offset)?;
                stream.save(&self.displacement)?;
                Ok(())
            }
        }
    }
    mod nitimecontroller {
        use crate::prelude::*;
        pub struct NiTimeController {
            pub base: NiObject,
            pub next: NiLink<NiTimeController>,
            pub flags: u16,
            #[default(1.0)]
            pub frequency: f32,
            pub phase: f32,
            pub start_time: f32,
            pub stop_time: f32,
            pub target: NiLink<NiObjectNET>,
        }
        impl NiTimeController {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiTimeController"
            }
        }
        impl Visitor for NiTimeController {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.target).visitor(f);
                (&self.stop_time).visitor(f);
                (&self.start_time).visitor(f);
                (&self.phase).visitor(f);
                (&self.frequency).visitor(f);
                (&self.flags).visitor(f);
                (&self.next).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiTimeController {
            type Target = NiObject;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiTimeController {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiTimeController {
            #[inline]
            fn clone(&self) -> NiTimeController {
                NiTimeController {
                    base: ::core::clone::Clone::clone(&self.base),
                    next: ::core::clone::Clone::clone(&self.next),
                    flags: ::core::clone::Clone::clone(&self.flags),
                    frequency: ::core::clone::Clone::clone(&self.frequency),
                    phase: ::core::clone::Clone::clone(&self.phase),
                    start_time: ::core::clone::Clone::clone(&self.start_time),
                    stop_time: ::core::clone::Clone::clone(&self.stop_time),
                    target: ::core::clone::Clone::clone(&self.target),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiTimeController {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "base",
                    "next",
                    "flags",
                    "frequency",
                    "phase",
                    "start_time",
                    "stop_time",
                    "target",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.base,
                    &self.next,
                    &self.flags,
                    &self.frequency,
                    &self.phase,
                    &self.start_time,
                    &self.stop_time,
                    &&self.target,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "NiTimeController",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiTimeController {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiTimeController {
            #[inline]
            fn eq(&self, other: &NiTimeController) -> bool {
                self.flags == other.flags && self.frequency == other.frequency
                    && self.phase == other.phase && self.start_time == other.start_time
                    && self.stop_time == other.stop_time && self.base == other.base
                    && self.next == other.next && self.target == other.target
            }
        }
        #[automatically_derived]
        impl Default for NiTimeController {
            /**Return `NiTimeController {
    base: Default::default(),
    next: Default::default(),
    flags: Default::default(),
    frequency: 1.0,
    phase: Default::default(),
    start_time: Default::default(),
    stop_time: Default::default(),
    target: Default::default()
}`*/
            fn default() -> Self {
                NiTimeController {
                    base: Default::default(),
                    next: Default::default(),
                    flags: Default::default(),
                    frequency: 1.0,
                    phase: Default::default(),
                    start_time: Default::default(),
                    stop_time: Default::default(),
                    target: Default::default(),
                }
            }
        }
        impl Load for NiTimeController {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let next = stream.load()?;
                let flags = stream.load()?;
                let frequency = stream.load()?;
                let phase = stream.load()?;
                let start_time = stream.load()?;
                let stop_time = stream.load()?;
                let target = stream.load()?;
                Ok(Self {
                    base,
                    next,
                    flags,
                    frequency,
                    phase,
                    start_time,
                    stop_time,
                    target,
                })
            }
        }
        impl Save for NiTimeController {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save(&self.next)?;
                stream.save(&self.flags)?;
                stream.save(&self.frequency)?;
                stream.save(&self.phase)?;
                stream.save(&self.start_time)?;
                stream.save(&self.stop_time)?;
                stream.save(&self.target)?;
                Ok(())
            }
        }
        impl NiTimeController {
            #[inline]
            pub fn cycle_type(&self) -> CycleType {
                let value = (self.flags & 0x0006) >> 1;
                value.try_into().unwrap_or_default()
            }
            #[inline]
            pub fn set_cycle_type(&mut self, value: CycleType) {
                self.flags = (self.flags & !0x0006) | ((value as u16) << 1);
            }
            #[inline]
            pub fn active(&self) -> bool {
                self.flags & 0x0008 != 0
            }
            #[inline]
            pub fn set_active(&mut self, value: bool) {
                if value {
                    self.flags |= 0x0008;
                } else {
                    self.flags &= !0x0008;
                }
            }
        }
    }
    mod nitribasedgeom {
        use crate::prelude::*;
        pub struct NiTriBasedGeom {
            pub base: NiGeometry,
        }
        impl NiTriBasedGeom {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiTriBasedGeom"
            }
        }
        impl Visitor for NiTriBasedGeom {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiTriBasedGeom {
            type Target = NiGeometry;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiTriBasedGeom {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiTriBasedGeom {
            #[inline]
            fn clone(&self) -> NiTriBasedGeom {
                NiTriBasedGeom {
                    base: ::core::clone::Clone::clone(&self.base),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiTriBasedGeom {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "NiTriBasedGeom",
                    "base",
                    &&self.base,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiTriBasedGeom {
            #[inline]
            fn default() -> NiTriBasedGeom {
                NiTriBasedGeom {
                    base: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiTriBasedGeom {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiTriBasedGeom {
            #[inline]
            fn eq(&self, other: &NiTriBasedGeom) -> bool {
                self.base == other.base
            }
        }
        impl Load for NiTriBasedGeom {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                Ok(Self { base })
            }
        }
        impl Save for NiTriBasedGeom {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                Ok(())
            }
        }
    }
    mod nitribasedgeomdata {
        use crate::prelude::*;
        pub struct NiTriBasedGeomData {
            pub base: NiGeometryData,
        }
        impl NiTriBasedGeomData {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiTriBasedGeomData"
            }
        }
        impl Visitor for NiTriBasedGeomData {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiTriBasedGeomData {
            type Target = NiGeometryData;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiTriBasedGeomData {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiTriBasedGeomData {
            #[inline]
            fn clone(&self) -> NiTriBasedGeomData {
                NiTriBasedGeomData {
                    base: ::core::clone::Clone::clone(&self.base),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiTriBasedGeomData {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "NiTriBasedGeomData",
                    "base",
                    &&self.base,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiTriBasedGeomData {
            #[inline]
            fn default() -> NiTriBasedGeomData {
                NiTriBasedGeomData {
                    base: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiTriBasedGeomData {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiTriBasedGeomData {
            #[inline]
            fn eq(&self, other: &NiTriBasedGeomData) -> bool {
                self.base == other.base
            }
        }
        impl Load for NiTriBasedGeomData {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                Ok(Self { base })
            }
        }
        impl Save for NiTriBasedGeomData {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                Ok(())
            }
        }
    }
    mod nitrishape {
        use crate::prelude::*;
        pub struct NiTriShape {
            pub base: NiTriBasedGeom,
        }
        impl NiTriShape {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiTriShape"
            }
        }
        impl Visitor for NiTriShape {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiTriShape {
            type Target = NiTriBasedGeom;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiTriShape {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiTriShape {
            #[inline]
            fn clone(&self) -> NiTriShape {
                NiTriShape {
                    base: ::core::clone::Clone::clone(&self.base),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiTriShape {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "NiTriShape",
                    "base",
                    &&self.base,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiTriShape {
            #[inline]
            fn default() -> NiTriShape {
                NiTriShape {
                    base: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiTriShape {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiTriShape {
            #[inline]
            fn eq(&self, other: &NiTriShape) -> bool {
                self.base == other.base
            }
        }
        impl Load for NiTriShape {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                Ok(Self { base })
            }
        }
        impl Save for NiTriShape {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                Ok(())
            }
        }
    }
    mod nitrishapedata {
        use crate::prelude::*;
        pub struct NiTriShapeData {
            pub base: NiTriBasedGeomData,
            pub triangles: Vec<u16>,
            pub shared_normals: Vec<Vec<u16>>,
        }
        impl NiTriShapeData {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiTriShapeData"
            }
        }
        impl Visitor for NiTriShapeData {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.shared_normals).visitor(f);
                (&self.triangles).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiTriShapeData {
            type Target = NiTriBasedGeomData;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiTriShapeData {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiTriShapeData {
            #[inline]
            fn clone(&self) -> NiTriShapeData {
                NiTriShapeData {
                    base: ::core::clone::Clone::clone(&self.base),
                    triangles: ::core::clone::Clone::clone(&self.triangles),
                    shared_normals: ::core::clone::Clone::clone(&self.shared_normals),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiTriShapeData {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "NiTriShapeData",
                    "base",
                    &self.base,
                    "triangles",
                    &self.triangles,
                    "shared_normals",
                    &&self.shared_normals,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiTriShapeData {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiTriShapeData {
            #[inline]
            fn eq(&self, other: &NiTriShapeData) -> bool {
                self.base == other.base && self.triangles == other.triangles
                    && self.shared_normals == other.shared_normals
            }
        }
        #[automatically_derived]
        impl Default for NiTriShapeData {
            /**Return `NiTriShapeData {
    base: Default::default(),
    triangles: Default::default(),
    shared_normals: Default::default()
}`*/
            fn default() -> Self {
                NiTriShapeData {
                    base: Default::default(),
                    triangles: Default::default(),
                    shared_normals: Default::default(),
                }
            }
        }
        impl Load for NiTriShapeData {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let _num_triangles: u16 = stream.load()?;
                let num_triangle_points: u32 = stream.load()?;
                let triangles = stream.load_vec(num_triangle_points)?;
                let num_shared_normals: u16 = stream.load()?;
                let shared_normals = (0..num_shared_normals)
                    .load(|_| {
                        Ok({
                            let num_indices: u16 = stream.load()?;
                            stream.load_vec(num_indices)?
                        })
                    })?;
                Ok(Self {
                    base,
                    triangles,
                    shared_normals,
                })
            }
        }
        impl Save for NiTriShapeData {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save_as::<u16>(self.triangles.len() / 3)?;
                stream.save_as::<u32>(self.triangles.len())?;
                stream.save_vec(&self.triangles)?;
                stream.save_as::<u16>(self.shared_normals.len())?;
                for indices in &self.shared_normals {
                    stream.save_as::<u16>(indices.len())?;
                    stream.save_vec(indices)?;
                }
                Ok(())
            }
        }
    }
    mod nitrishapedynamicdata {
        use crate::prelude::*;
        pub struct NiTriShapeDynamicData {
            pub base: NiTriShapeData,
            pub active_vertices: u16,
            pub active_triangles: u16,
        }
        impl NiTriShapeDynamicData {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiTriShapeDynamicData"
            }
        }
        impl Visitor for NiTriShapeDynamicData {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.active_triangles).visitor(f);
                (&self.active_vertices).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiTriShapeDynamicData {
            type Target = NiTriShapeData;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiTriShapeDynamicData {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiTriShapeDynamicData {
            #[inline]
            fn clone(&self) -> NiTriShapeDynamicData {
                NiTriShapeDynamicData {
                    base: ::core::clone::Clone::clone(&self.base),
                    active_vertices: ::core::clone::Clone::clone(&self.active_vertices),
                    active_triangles: ::core::clone::Clone::clone(&self.active_triangles),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiTriShapeDynamicData {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "NiTriShapeDynamicData",
                    "base",
                    &self.base,
                    "active_vertices",
                    &self.active_vertices,
                    "active_triangles",
                    &&self.active_triangles,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiTriShapeDynamicData {
            #[inline]
            fn default() -> NiTriShapeDynamicData {
                NiTriShapeDynamicData {
                    base: ::core::default::Default::default(),
                    active_vertices: ::core::default::Default::default(),
                    active_triangles: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiTriShapeDynamicData {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiTriShapeDynamicData {
            #[inline]
            fn eq(&self, other: &NiTriShapeDynamicData) -> bool {
                self.active_vertices == other.active_vertices
                    && self.active_triangles == other.active_triangles
                    && self.base == other.base
            }
        }
        impl Load for NiTriShapeDynamicData {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let active_vertices = stream.load()?;
                let active_triangles = stream.load()?;
                Ok(Self {
                    base,
                    active_vertices,
                    active_triangles,
                })
            }
        }
        impl Save for NiTriShapeDynamicData {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save(&self.active_vertices)?;
                stream.save(&self.active_triangles)?;
                Ok(())
            }
        }
    }
    mod nitristrips {
        use crate::prelude::*;
        pub struct NiTriStrips {
            pub base: NiTriBasedGeom,
        }
        impl NiTriStrips {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiTriStrips"
            }
        }
        impl Visitor for NiTriStrips {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiTriStrips {
            type Target = NiTriBasedGeom;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiTriStrips {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiTriStrips {
            #[inline]
            fn clone(&self) -> NiTriStrips {
                NiTriStrips {
                    base: ::core::clone::Clone::clone(&self.base),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiTriStrips {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "NiTriStrips",
                    "base",
                    &&self.base,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiTriStrips {
            #[inline]
            fn default() -> NiTriStrips {
                NiTriStrips {
                    base: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiTriStrips {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiTriStrips {
            #[inline]
            fn eq(&self, other: &NiTriStrips) -> bool {
                self.base == other.base
            }
        }
        impl Load for NiTriStrips {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                Ok(Self { base })
            }
        }
        impl Save for NiTriStrips {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                Ok(())
            }
        }
    }
    mod nitristripsdata {
        use crate::prelude::*;
        pub struct NiTriStripsData {
            pub base: NiTriBasedGeomData,
            pub num_triangles: u16,
            pub strip_lengths: Vec<u16>,
            pub strips: Vec<u16>,
        }
        impl NiTriStripsData {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiTriStripsData"
            }
        }
        impl Visitor for NiTriStripsData {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.strips).visitor(f);
                (&self.strip_lengths).visitor(f);
                (&self.num_triangles).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiTriStripsData {
            type Target = NiTriBasedGeomData;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiTriStripsData {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiTriStripsData {
            #[inline]
            fn clone(&self) -> NiTriStripsData {
                NiTriStripsData {
                    base: ::core::clone::Clone::clone(&self.base),
                    num_triangles: ::core::clone::Clone::clone(&self.num_triangles),
                    strip_lengths: ::core::clone::Clone::clone(&self.strip_lengths),
                    strips: ::core::clone::Clone::clone(&self.strips),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiTriStripsData {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "NiTriStripsData",
                    "base",
                    &self.base,
                    "num_triangles",
                    &self.num_triangles,
                    "strip_lengths",
                    &self.strip_lengths,
                    "strips",
                    &&self.strips,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiTriStripsData {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiTriStripsData {
            #[inline]
            fn eq(&self, other: &NiTriStripsData) -> bool {
                self.num_triangles == other.num_triangles && self.base == other.base
                    && self.strip_lengths == other.strip_lengths
                    && self.strips == other.strips
            }
        }
        #[automatically_derived]
        impl Default for NiTriStripsData {
            /**Return `NiTriStripsData {
    base: Default::default(),
    num_triangles: Default::default(),
    strip_lengths: Default::default(),
    strips: Default::default()
}`*/
            fn default() -> Self {
                NiTriStripsData {
                    base: Default::default(),
                    num_triangles: Default::default(),
                    strip_lengths: Default::default(),
                    strips: Default::default(),
                }
            }
        }
        impl Load for NiTriStripsData {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let num_triangles = stream.load()?;
                let num_strip_lengths: u16 = stream.load()?;
                let strip_lengths: Vec<u16> = stream.load_vec(num_strip_lengths)?;
                let strip_lengths_sum: usize = strip_lengths
                    .iter()
                    .map(|n| *n as usize)
                    .sum();
                let strips = stream.load_vec(strip_lengths_sum)?;
                Ok(Self {
                    base,
                    num_triangles,
                    strip_lengths,
                    strips,
                })
            }
        }
        impl Save for NiTriStripsData {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save(&self.num_triangles)?;
                stream.save_as::<u16>(self.strip_lengths.len())?;
                stream.save_vec(&self.strip_lengths)?;
                stream.save_vec(&self.strips)?;
                Ok(())
            }
        }
    }
    mod niunionbv {
        use crate::prelude::*;
        pub struct NiUnionBV {
            pub bounding_volumes: Vec<NiBoundingVolume>,
        }
        impl NiUnionBV {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiUnionBV"
            }
        }
        impl Visitor for NiUnionBV {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.bounding_volumes).visitor(f);
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiUnionBV {
            #[inline]
            fn clone(&self) -> NiUnionBV {
                NiUnionBV {
                    bounding_volumes: ::core::clone::Clone::clone(&self.bounding_volumes),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiUnionBV {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "NiUnionBV",
                    "bounding_volumes",
                    &&self.bounding_volumes,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiUnionBV {
            #[inline]
            fn default() -> NiUnionBV {
                NiUnionBV {
                    bounding_volumes: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiUnionBV {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiUnionBV {
            #[inline]
            fn eq(&self, other: &NiUnionBV) -> bool {
                self.bounding_volumes == other.bounding_volumes
            }
        }
        impl Load for NiUnionBV {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let bounding_volumes = stream.load()?;
                Ok(Self { bounding_volumes })
            }
        }
        impl Save for NiUnionBV {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.bounding_volumes)?;
                Ok(())
            }
        }
    }
    mod niuvcontroller {
        use crate::prelude::*;
        pub struct NiUVController {
            pub base: NiTimeController,
            pub texture_set: u16,
            pub data: NiLink<NiUVData>,
        }
        impl NiUVController {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiUVController"
            }
        }
        impl Visitor for NiUVController {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.data).visitor(f);
                (&self.texture_set).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiUVController {
            type Target = NiTimeController;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiUVController {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiUVController {
            #[inline]
            fn clone(&self) -> NiUVController {
                NiUVController {
                    base: ::core::clone::Clone::clone(&self.base),
                    texture_set: ::core::clone::Clone::clone(&self.texture_set),
                    data: ::core::clone::Clone::clone(&self.data),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiUVController {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "NiUVController",
                    "base",
                    &self.base,
                    "texture_set",
                    &self.texture_set,
                    "data",
                    &&self.data,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiUVController {
            #[inline]
            fn default() -> NiUVController {
                NiUVController {
                    base: ::core::default::Default::default(),
                    texture_set: ::core::default::Default::default(),
                    data: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiUVController {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiUVController {
            #[inline]
            fn eq(&self, other: &NiUVController) -> bool {
                self.texture_set == other.texture_set && self.base == other.base
                    && self.data == other.data
            }
        }
        impl Load for NiUVController {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let texture_set = stream.load()?;
                let data = stream.load()?;
                Ok(Self { base, texture_set, data })
            }
        }
        impl Save for NiUVController {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save(&self.texture_set)?;
                stream.save(&self.data)?;
                Ok(())
            }
        }
    }
    mod niuvdata {
        use crate::prelude::*;
        pub struct NiUVData {
            pub base: NiObject,
            pub u_offset_data: NiFloatData,
            pub v_offset_data: NiFloatData,
            pub u_tiling_data: NiFloatData,
            pub v_tiling_data: NiFloatData,
        }
        impl NiUVData {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiUVData"
            }
        }
        impl Visitor for NiUVData {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.v_tiling_data).visitor(f);
                (&self.u_tiling_data).visitor(f);
                (&self.v_offset_data).visitor(f);
                (&self.u_offset_data).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiUVData {
            type Target = NiObject;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiUVData {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiUVData {
            #[inline]
            fn clone(&self) -> NiUVData {
                NiUVData {
                    base: ::core::clone::Clone::clone(&self.base),
                    u_offset_data: ::core::clone::Clone::clone(&self.u_offset_data),
                    v_offset_data: ::core::clone::Clone::clone(&self.v_offset_data),
                    u_tiling_data: ::core::clone::Clone::clone(&self.u_tiling_data),
                    v_tiling_data: ::core::clone::Clone::clone(&self.v_tiling_data),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiUVData {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field5_finish(
                    f,
                    "NiUVData",
                    "base",
                    &self.base,
                    "u_offset_data",
                    &self.u_offset_data,
                    "v_offset_data",
                    &self.v_offset_data,
                    "u_tiling_data",
                    &self.u_tiling_data,
                    "v_tiling_data",
                    &&self.v_tiling_data,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiUVData {
            #[inline]
            fn default() -> NiUVData {
                NiUVData {
                    base: ::core::default::Default::default(),
                    u_offset_data: ::core::default::Default::default(),
                    v_offset_data: ::core::default::Default::default(),
                    u_tiling_data: ::core::default::Default::default(),
                    v_tiling_data: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiUVData {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiUVData {
            #[inline]
            fn eq(&self, other: &NiUVData) -> bool {
                self.base == other.base && self.u_offset_data == other.u_offset_data
                    && self.v_offset_data == other.v_offset_data
                    && self.u_tiling_data == other.u_tiling_data
                    && self.v_tiling_data == other.v_tiling_data
            }
        }
        impl Load for NiUVData {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let u_offset_data = stream.load()?;
                let v_offset_data = stream.load()?;
                let u_tiling_data = stream.load()?;
                let v_tiling_data = stream.load()?;
                Ok(Self {
                    base,
                    u_offset_data,
                    v_offset_data,
                    u_tiling_data,
                    v_tiling_data,
                })
            }
        }
        impl Save for NiUVData {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save(&self.u_offset_data)?;
                stream.save(&self.v_offset_data)?;
                stream.save(&self.u_tiling_data)?;
                stream.save(&self.v_tiling_data)?;
                Ok(())
            }
        }
    }
    mod nivertexcolorproperty {
        use crate::prelude::*;
        pub struct NiVertexColorProperty {
            pub base: NiProperty,
            pub source_vertex_mode: SourceVertexMode,
            pub lighting_mode: LightingMode,
        }
        impl NiVertexColorProperty {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiVertexColorProperty"
            }
        }
        impl Visitor for NiVertexColorProperty {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.lighting_mode).visitor(f);
                (&self.source_vertex_mode).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiVertexColorProperty {
            type Target = NiProperty;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiVertexColorProperty {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiVertexColorProperty {
            #[inline]
            fn clone(&self) -> NiVertexColorProperty {
                NiVertexColorProperty {
                    base: ::core::clone::Clone::clone(&self.base),
                    source_vertex_mode: ::core::clone::Clone::clone(
                        &self.source_vertex_mode,
                    ),
                    lighting_mode: ::core::clone::Clone::clone(&self.lighting_mode),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiVertexColorProperty {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "NiVertexColorProperty",
                    "base",
                    &self.base,
                    "source_vertex_mode",
                    &self.source_vertex_mode,
                    "lighting_mode",
                    &&self.lighting_mode,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiVertexColorProperty {
            #[inline]
            fn default() -> NiVertexColorProperty {
                NiVertexColorProperty {
                    base: ::core::default::Default::default(),
                    source_vertex_mode: ::core::default::Default::default(),
                    lighting_mode: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiVertexColorProperty {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiVertexColorProperty {
            #[inline]
            fn eq(&self, other: &NiVertexColorProperty) -> bool {
                self.base == other.base
                    && self.source_vertex_mode == other.source_vertex_mode
                    && self.lighting_mode == other.lighting_mode
            }
        }
        impl Load for NiVertexColorProperty {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let source_vertex_mode = stream.load()?;
                let lighting_mode = stream.load()?;
                Ok(Self {
                    base,
                    source_vertex_mode,
                    lighting_mode,
                })
            }
        }
        impl Save for NiVertexColorProperty {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save(&self.source_vertex_mode)?;
                stream.save(&self.lighting_mode)?;
                Ok(())
            }
        }
    }
    mod nivertweightsextradata {
        use crate::prelude::*;
        pub struct NiVertWeightsExtraData {
            pub base: NiExtraData,
            pub weights: Vec<f32>,
        }
        impl NiVertWeightsExtraData {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiVertWeightsExtraData"
            }
        }
        impl Visitor for NiVertWeightsExtraData {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.weights).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiVertWeightsExtraData {
            type Target = NiExtraData;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiVertWeightsExtraData {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiVertWeightsExtraData {
            #[inline]
            fn clone(&self) -> NiVertWeightsExtraData {
                NiVertWeightsExtraData {
                    base: ::core::clone::Clone::clone(&self.base),
                    weights: ::core::clone::Clone::clone(&self.weights),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiVertWeightsExtraData {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "NiVertWeightsExtraData",
                    "base",
                    &self.base,
                    "weights",
                    &&self.weights,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiVertWeightsExtraData {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiVertWeightsExtraData {
            #[inline]
            fn eq(&self, other: &NiVertWeightsExtraData) -> bool {
                self.base == other.base && self.weights == other.weights
            }
        }
        #[automatically_derived]
        impl Default for NiVertWeightsExtraData {
            /**Return `NiVertWeightsExtraData {
    base: Default::default(),
    weights: Default::default()
}`*/
            fn default() -> Self {
                NiVertWeightsExtraData {
                    base: Default::default(),
                    weights: Default::default(),
                }
            }
        }
        impl Load for NiVertWeightsExtraData {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let num_weights: u16 = stream.load()?;
                let weights = stream.load_vec(num_weights)?;
                Ok(Self { base, weights })
            }
        }
        impl Save for NiVertWeightsExtraData {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save_as::<u16>(self.weights.len())?;
                stream.save_vec(&self.weights)?;
                Ok(())
            }
        }
    }
    mod niviscontroller {
        use crate::prelude::*;
        pub struct NiVisController {
            pub base: NiTimeController,
            pub data: NiLink<NiVisData>,
        }
        impl NiVisController {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiVisController"
            }
        }
        impl Visitor for NiVisController {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.data).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiVisController {
            type Target = NiTimeController;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiVisController {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiVisController {
            #[inline]
            fn clone(&self) -> NiVisController {
                NiVisController {
                    base: ::core::clone::Clone::clone(&self.base),
                    data: ::core::clone::Clone::clone(&self.data),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiVisController {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "NiVisController",
                    "base",
                    &self.base,
                    "data",
                    &&self.data,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiVisController {
            #[inline]
            fn default() -> NiVisController {
                NiVisController {
                    base: ::core::default::Default::default(),
                    data: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiVisController {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiVisController {
            #[inline]
            fn eq(&self, other: &NiVisController) -> bool {
                self.base == other.base && self.data == other.data
            }
        }
        impl Load for NiVisController {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let data = stream.load()?;
                Ok(Self { base, data })
            }
        }
        impl Save for NiVisController {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save(&self.data)?;
                Ok(())
            }
        }
    }
    mod nivisdata {
        use crate::prelude::*;
        pub struct NiVisData {
            pub base: NiObject,
            pub keys: Vec<NiVisKey>,
        }
        impl NiVisData {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiVisData"
            }
        }
        impl Visitor for NiVisData {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.keys).visitor(f);
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiVisData {
            type Target = NiObject;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiVisData {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiVisData {
            #[inline]
            fn clone(&self) -> NiVisData {
                NiVisData {
                    base: ::core::clone::Clone::clone(&self.base),
                    keys: ::core::clone::Clone::clone(&self.keys),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiVisData {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "NiVisData",
                    "base",
                    &self.base,
                    "keys",
                    &&self.keys,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiVisData {
            #[inline]
            fn default() -> NiVisData {
                NiVisData {
                    base: ::core::default::Default::default(),
                    keys: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiVisData {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiVisData {
            #[inline]
            fn eq(&self, other: &NiVisData) -> bool {
                self.base == other.base && self.keys == other.keys
            }
        }
        pub struct NiVisKey {
            pub time: f32,
            pub value: u8,
        }
        impl NiVisKey {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiVisKey"
            }
        }
        impl Visitor for NiVisKey {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.value).visitor(f);
                (&self.time).visitor(f);
            }
        }
        const _: () = {
            use crate::prelude::*;
            impl Load for NiVisKey {
                fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                    Ok(Self {
                        time: stream.load()?,
                        value: stream.load()?,
                    })
                }
            }
            impl Save for NiVisKey {
                fn save(&self, stream: &mut Writer) -> io::Result<()> {
                    stream.save(&self.time)?;
                    stream.save(&self.value)?;
                    Ok(())
                }
            }
        };
        #[automatically_derived]
        impl ::core::clone::Clone for NiVisKey {
            #[inline]
            fn clone(&self) -> NiVisKey {
                let _: ::core::clone::AssertParamIsClone<f32>;
                let _: ::core::clone::AssertParamIsClone<u8>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for NiVisKey {}
        #[automatically_derived]
        impl ::core::fmt::Debug for NiVisKey {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "NiVisKey",
                    "time",
                    &self.time,
                    "value",
                    &&self.value,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiVisKey {
            #[inline]
            fn default() -> NiVisKey {
                NiVisKey {
                    time: ::core::default::Default::default(),
                    value: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiVisKey {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiVisKey {
            #[inline]
            fn eq(&self, other: &NiVisKey) -> bool {
                self.time == other.time && self.value == other.value
            }
        }
        const _: fn() = || {
            #[allow(clippy::missing_const_for_fn)]
            #[doc(hidden)]
            fn check() {
                fn assert_impl<T: ::bytemuck::Zeroable>() {}
                assert_impl::<f32>();
            }
        };
        const _: fn() = || {
            #[allow(clippy::missing_const_for_fn)]
            #[doc(hidden)]
            fn check() {
                fn assert_impl<T: ::bytemuck::Zeroable>() {}
                assert_impl::<u8>();
            }
        };
        unsafe impl ::bytemuck::Zeroable for NiVisKey {}
        impl Load for NiVisData {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                let num_keys: u32 = stream.load()?;
                let keys = stream.load_seq(num_keys)?;
                Ok(Self { base, keys })
            }
        }
        impl Save for NiVisData {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                stream.save_as::<u32>(self.keys.len())?;
                stream.save_seq(&self.keys)?;
                Ok(())
            }
        }
    }
    mod niwireframeproperty {
        use crate::prelude::*;
        pub struct NiWireframeProperty {
            pub base: NiProperty,
        }
        impl NiWireframeProperty {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiWireframeProperty"
            }
        }
        impl Visitor for NiWireframeProperty {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiWireframeProperty {
            type Target = NiProperty;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiWireframeProperty {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiWireframeProperty {
            #[inline]
            fn clone(&self) -> NiWireframeProperty {
                NiWireframeProperty {
                    base: ::core::clone::Clone::clone(&self.base),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiWireframeProperty {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "NiWireframeProperty",
                    "base",
                    &&self.base,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiWireframeProperty {
            #[inline]
            fn default() -> NiWireframeProperty {
                NiWireframeProperty {
                    base: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiWireframeProperty {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiWireframeProperty {
            #[inline]
            fn eq(&self, other: &NiWireframeProperty) -> bool {
                self.base == other.base
            }
        }
        impl Load for NiWireframeProperty {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                Ok(Self { base })
            }
        }
        impl Save for NiWireframeProperty {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                Ok(())
            }
        }
        impl NiWireframeProperty {
            #[inline]
            pub fn wireframe(&self) -> bool {
                self.flags & 0x0001 != 0
            }
            #[inline]
            pub fn set_wireframe(&mut self, value: bool) {
                if value {
                    self.flags |= 0x0001;
                } else {
                    self.flags &= !0x0001;
                }
            }
        }
    }
    mod nizbufferproperty {
        use crate::prelude::*;
        pub struct NiZBufferProperty {
            pub base: NiProperty,
        }
        impl NiZBufferProperty {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"NiZBufferProperty"
            }
        }
        impl Visitor for NiZBufferProperty {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for NiZBufferProperty {
            type Target = NiProperty;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for NiZBufferProperty {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NiZBufferProperty {
            #[inline]
            fn clone(&self) -> NiZBufferProperty {
                NiZBufferProperty {
                    base: ::core::clone::Clone::clone(&self.base),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NiZBufferProperty {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "NiZBufferProperty",
                    "base",
                    &&self.base,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NiZBufferProperty {
            #[inline]
            fn default() -> NiZBufferProperty {
                NiZBufferProperty {
                    base: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NiZBufferProperty {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NiZBufferProperty {
            #[inline]
            fn eq(&self, other: &NiZBufferProperty) -> bool {
                self.base == other.base
            }
        }
        impl Load for NiZBufferProperty {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                Ok(Self { base })
            }
        }
        impl Save for NiZBufferProperty {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                Ok(())
            }
        }
        impl NiZBufferProperty {
            #[inline]
            pub fn z_buffer_test(&self) -> bool {
                self.flags & 0x0001 != 0
            }
            #[inline]
            pub fn set_z_buffer_test(&mut self, value: bool) {
                if value {
                    self.flags |= 0x0001;
                } else {
                    self.flags &= !0x0001;
                }
            }
            #[inline]
            pub fn z_buffer_write(&self) -> bool {
                self.flags & 0x0002 != 0
            }
            #[inline]
            pub fn set_z_buffer_write(&mut self, value: bool) {
                if value {
                    self.flags |= 0x0002;
                } else {
                    self.flags &= !0x0002;
                }
            }
            #[inline]
            pub fn test_function(&self) -> ZBufferTestFunction {
                let value = (self.flags & 0x003C) >> 2;
                value.try_into().unwrap_or_default()
            }
            #[inline]
            pub fn set_test_function(&mut self, value: ZBufferTestFunction) {
                self.flags = (self.flags & !0x003C) | ((value as u16) << 2);
            }
        }
    }
    mod rootcollisionnode {
        use crate::prelude::*;
        pub struct RootCollisionNode {
            pub base: NiNode,
        }
        impl RootCollisionNode {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"RootCollisionNode"
            }
        }
        impl Visitor for RootCollisionNode {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for RootCollisionNode {
            type Target = NiNode;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for RootCollisionNode {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for RootCollisionNode {
            #[inline]
            fn clone(&self) -> RootCollisionNode {
                RootCollisionNode {
                    base: ::core::clone::Clone::clone(&self.base),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for RootCollisionNode {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "RootCollisionNode",
                    "base",
                    &&self.base,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for RootCollisionNode {
            #[inline]
            fn default() -> RootCollisionNode {
                RootCollisionNode {
                    base: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for RootCollisionNode {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for RootCollisionNode {
            #[inline]
            fn eq(&self, other: &RootCollisionNode) -> bool {
                self.base == other.base
            }
        }
        impl Load for RootCollisionNode {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                Ok(Self { base })
            }
        }
        impl Save for RootCollisionNode {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                Ok(())
            }
        }
    }
    mod tes3objectextradata {
        use crate::prelude::*;
        pub struct TES3ObjectExtraData {
            pub base: NiExtraData,
        }
        impl TES3ObjectExtraData {
            #[doc(hidden)]
            pub const fn type_name(&self) -> &'static [u8] {
                b"TES3ObjectExtraData"
            }
        }
        impl Visitor for TES3ObjectExtraData {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                (&self.base).visitor(f);
            }
        }
        impl ::std::ops::Deref for TES3ObjectExtraData {
            type Target = NiExtraData;
            fn deref(&self) -> &Self::Target {
                &self.base
            }
        }
        impl ::std::ops::DerefMut for TES3ObjectExtraData {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.base
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for TES3ObjectExtraData {
            #[inline]
            fn clone(&self) -> TES3ObjectExtraData {
                TES3ObjectExtraData {
                    base: ::core::clone::Clone::clone(&self.base),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for TES3ObjectExtraData {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "TES3ObjectExtraData",
                    "base",
                    &&self.base,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for TES3ObjectExtraData {
            #[inline]
            fn default() -> TES3ObjectExtraData {
                TES3ObjectExtraData {
                    base: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for TES3ObjectExtraData {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for TES3ObjectExtraData {
            #[inline]
            fn eq(&self, other: &TES3ObjectExtraData) -> bool {
                self.base == other.base
            }
        }
        impl Load for TES3ObjectExtraData {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let base = stream.load()?;
                Ok(Self { base })
            }
        }
        impl Save for TES3ObjectExtraData {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                stream.save(&self.base)?;
                Ok(())
            }
        }
    }
    pub use avoidnode::*;
    pub use brickniextradata::*;
    pub use bsmirrorednode::*;
    pub use enums::*;
    pub use niaccumulator::*;
    pub use nialphaaccumulator::*;
    pub use nialphacontroller::*;
    pub use nialphaproperty::*;
    pub use niambientlight::*;
    pub use niautonormalparticles::*;
    pub use niautonormalparticlesdata::*;
    pub use niavobject::*;
    pub use nibillboardnode::*;
    pub use nibltsource::*;
    pub use nibound::*;
    pub use niboundingvolume::*;
    pub use niboxbv::*;
    pub use nibsanimationmanager::*;
    pub use nibsanimationnode::*;
    pub use nibsparraycontroller::*;
    pub use nibsparticlenode::*;
    pub use nibspnode::*;
    pub use nicamera::*;
    pub use niclusteraccumulator::*;
    pub use nicollisionswitch::*;
    pub use nicolordata::*;
    pub use nicolorkey::*;
    pub use nidirectionallight::*;
    pub use niditherproperty::*;
    pub use nidx8renderer::*;
    pub use nidynamiceffect::*;
    pub use niemittermodifier::*;
    pub use niextradata::*;
    pub use niflipcontroller::*;
    pub use nifloatcontroller::*;
    pub use nifloatdata::*;
    pub use nifloatkey::*;
    pub use nifltanimationnode::*;
    pub use nifogproperty::*;
    pub use nigeometry::*;
    pub use nigeometrydata::*;
    pub use nigeommorphercontroller::*;
    pub use nigravity::*;
    pub use nikeyframecontroller::*;
    pub use nikeyframedata::*;
    pub use nikeyframemanager::*;
    pub use nilight::*;
    pub use nilightcolorcontroller::*;
    pub use nilines::*;
    pub use nilinesdata::*;
    pub use nilink::*;
    pub use nilodnode::*;
    pub use nilookatcontroller::*;
    pub use nimaterialcolorcontroller::*;
    pub use nimaterialproperty::*;
    pub use nimorphdata::*;
    pub use nimorphercontroller::*;
    pub use ninode::*;
    pub use niobject::*;
    pub use niobjectnet::*;
    pub use nipalette::*;
    pub use niparticlebomb::*;
    pub use niparticlecollider::*;
    pub use niparticlecolormodifier::*;
    pub use niparticlegrowfade::*;
    pub use niparticlemodifier::*;
    pub use niparticlerotation::*;
    pub use niparticles::*;
    pub use niparticlesdata::*;
    pub use niparticlesystemcontroller::*;
    pub use nipathcontroller::*;
    pub use niperparticledata::*;
    pub use nipixeldata::*;
    pub use nipixelformat::*;
    pub use niplanarcollider::*;
    pub use nipointlight::*;
    pub use niposdata::*;
    pub use niposkey::*;
    pub use niproperty::*;
    pub use nirenderedcubemap::*;
    pub use nirenderedtexture::*;
    pub use nirenderer::*;
    pub use nirollcontroller::*;
    pub use nirotatingparticles::*;
    pub use nirotatingparticlesdata::*;
    pub use nirotdata::*;
    pub use nirotkey::*;
    pub use niscreenpolygon::*;
    pub use nisequence::*;
    pub use nisequencestreamhelper::*;
    pub use nishadeproperty::*;
    pub use niskindata::*;
    pub use niskininstance::*;
    pub use niskinpartition::*;
    pub use nisortadjustnode::*;
    pub use nisourcetexture::*;
    pub use nispecularproperty::*;
    pub use nispherebv::*;
    pub use nisphericalcollider::*;
    pub use nispotlight::*;
    pub use nistencilproperty::*;
    pub use nistream::*;
    pub use nistringextradata::*;
    pub use niswitchnode::*;
    pub use nitextkeyextradata::*;
    pub use nitexture::*;
    pub use nitextureeffect::*;
    pub use nitexturingproperty::*;
    pub use nitimecontroller::*;
    pub use nitribasedgeom::*;
    pub use nitribasedgeomdata::*;
    pub use nitrishape::*;
    pub use nitrishapedata::*;
    pub use nitrishapedynamicdata::*;
    pub use nitristrips::*;
    pub use nitristripsdata::*;
    pub use niunionbv::*;
    pub use niuvcontroller::*;
    pub use niuvdata::*;
    pub use nivertexcolorproperty::*;
    pub use nivertweightsextradata::*;
    pub use niviscontroller::*;
    pub use nivisdata::*;
    pub use niwireframeproperty::*;
    pub use nizbufferproperty::*;
    pub use rootcollisionnode::*;
    pub use tes3objectextradata::*;
    pub enum NiType {
        Empty,
        AvoidNode(AvoidNode),
        BrickNiExtraData(BrickNiExtraData),
        BSMirroredNode(BSMirroredNode),
        NiAccumulator(NiAccumulator),
        NiAlphaAccumulator(NiAlphaAccumulator),
        NiAlphaController(NiAlphaController),
        NiAlphaProperty(NiAlphaProperty),
        NiAmbientLight(NiAmbientLight),
        NiAutoNormalParticles(NiAutoNormalParticles),
        NiAutoNormalParticlesData(NiAutoNormalParticlesData),
        NiAVObject(NiAVObject),
        NiBillboardNode(NiBillboardNode),
        NiBltSource(NiBltSource),
        NiBSAnimationManager(NiBSAnimationManager),
        NiBSAnimationNode(NiBSAnimationNode),
        NiBSPArrayController(NiBSPArrayController),
        NiBSParticleNode(NiBSParticleNode),
        NiBSPNode(NiBSPNode),
        NiCamera(NiCamera),
        NiClusterAccumulator(NiClusterAccumulator),
        NiCollisionSwitch(NiCollisionSwitch),
        NiColorData(NiColorData),
        NiDirectionalLight(NiDirectionalLight),
        NiDitherProperty(NiDitherProperty),
        NiDX8Renderer(NiDX8Renderer),
        NiDynamicEffect(NiDynamicEffect),
        NiEmitterModifier(NiEmitterModifier),
        NiExtraData(NiExtraData),
        NiFlipController(NiFlipController),
        NiFloatController(NiFloatController),
        NiFloatData(NiFloatData),
        NiFltAnimationNode(NiFltAnimationNode),
        NiFogProperty(NiFogProperty),
        NiGeometry(NiGeometry),
        NiGeometryData(NiGeometryData),
        NiGeomMorpherController(NiGeomMorpherController),
        NiGravity(NiGravity),
        NiKeyframeController(NiKeyframeController),
        NiKeyframeData(NiKeyframeData),
        NiKeyframeManager(NiKeyframeManager),
        NiLight(NiLight),
        NiLightColorController(NiLightColorController),
        NiLines(NiLines),
        NiLinesData(NiLinesData),
        NiLODNode(NiLODNode),
        NiLookAtController(NiLookAtController),
        NiMaterialColorController(NiMaterialColorController),
        NiMaterialProperty(NiMaterialProperty),
        NiMorphData(NiMorphData),
        NiMorpherController(NiMorpherController),
        NiNode(NiNode),
        NiObject(NiObject),
        NiObjectNET(NiObjectNET),
        NiPalette(NiPalette),
        NiParticleBomb(NiParticleBomb),
        NiParticleCollider(NiParticleCollider),
        NiParticleColorModifier(NiParticleColorModifier),
        NiParticleGrowFade(NiParticleGrowFade),
        NiParticleModifier(NiParticleModifier),
        NiParticleRotation(NiParticleRotation),
        NiParticles(NiParticles),
        NiParticlesData(NiParticlesData),
        NiParticleSystemController(NiParticleSystemController),
        NiPathController(NiPathController),
        NiPixelData(NiPixelData),
        NiPlanarCollider(NiPlanarCollider),
        NiPointLight(NiPointLight),
        NiPosData(NiPosData),
        NiProperty(NiProperty),
        NiRenderedCubeMap(NiRenderedCubeMap),
        NiRenderedTexture(NiRenderedTexture),
        NiRenderer(NiRenderer),
        NiRollController(NiRollController),
        NiRotatingParticles(NiRotatingParticles),
        NiRotatingParticlesData(NiRotatingParticlesData),
        NiRotData(NiRotData),
        NiScreenPolygon(NiScreenPolygon),
        NiSequenceStreamHelper(NiSequenceStreamHelper),
        NiShadeProperty(NiShadeProperty),
        NiSkinData(NiSkinData),
        NiSkinInstance(NiSkinInstance),
        NiSkinPartition(NiSkinPartition),
        NiSortAdjustNode(NiSortAdjustNode),
        NiSourceTexture(NiSourceTexture),
        NiSpecularProperty(NiSpecularProperty),
        NiSphericalCollider(NiSphericalCollider),
        NiSpotLight(NiSpotLight),
        NiStencilProperty(NiStencilProperty),
        NiStringExtraData(NiStringExtraData),
        NiSwitchNode(NiSwitchNode),
        NiTextKeyExtraData(NiTextKeyExtraData),
        NiTexture(NiTexture),
        NiTextureEffect(NiTextureEffect),
        NiTexturingProperty(NiTexturingProperty),
        NiTimeController(NiTimeController),
        NiTriBasedGeom(NiTriBasedGeom),
        NiTriBasedGeomData(NiTriBasedGeomData),
        NiTriShape(NiTriShape),
        NiTriShapeData(NiTriShapeData),
        NiTriShapeDynamicData(NiTriShapeDynamicData),
        NiTriStrips(NiTriStrips),
        NiTriStripsData(NiTriStripsData),
        NiUVController(NiUVController),
        NiUVData(NiUVData),
        NiVertexColorProperty(NiVertexColorProperty),
        NiVertWeightsExtraData(NiVertWeightsExtraData),
        NiVisController(NiVisController),
        NiVisData(NiVisData),
        NiWireframeProperty(NiWireframeProperty),
        NiZBufferProperty(NiZBufferProperty),
        RootCollisionNode(RootCollisionNode),
        TES3ObjectExtraData(TES3ObjectExtraData),
    }
    const _: () = {
        use crate::prelude::*;
        use io::{Read, Write};
        impl Load for NiType {
            fn load(stream: &mut Reader<'_>) -> io::Result<Self> {
                let type_name: ::bstr::BString = stream.load()?;
                match type_name.as_slice() {
                    b"AvoidNode" => Ok(Self::AvoidNode(stream.load()?)),
                    b"BrickNiExtraData" => Ok(Self::BrickNiExtraData(stream.load()?)),
                    b"BSMirroredNode" => Ok(Self::BSMirroredNode(stream.load()?)),
                    b"NiAccumulator" => Ok(Self::NiAccumulator(stream.load()?)),
                    b"NiAlphaAccumulator" => Ok(Self::NiAlphaAccumulator(stream.load()?)),
                    b"NiAlphaController" => Ok(Self::NiAlphaController(stream.load()?)),
                    b"NiAlphaProperty" => Ok(Self::NiAlphaProperty(stream.load()?)),
                    b"NiAmbientLight" => Ok(Self::NiAmbientLight(stream.load()?)),
                    b"NiAutoNormalParticles" => {
                        Ok(Self::NiAutoNormalParticles(stream.load()?))
                    }
                    b"NiAutoNormalParticlesData" => {
                        Ok(Self::NiAutoNormalParticlesData(stream.load()?))
                    }
                    b"NiAVObject" => Ok(Self::NiAVObject(stream.load()?)),
                    b"NiBillboardNode" => Ok(Self::NiBillboardNode(stream.load()?)),
                    b"NiBltSource" => Ok(Self::NiBltSource(stream.load()?)),
                    b"NiBSAnimationManager" => {
                        Ok(Self::NiBSAnimationManager(stream.load()?))
                    }
                    b"NiBSAnimationNode" => Ok(Self::NiBSAnimationNode(stream.load()?)),
                    b"NiBSPArrayController" => {
                        Ok(Self::NiBSPArrayController(stream.load()?))
                    }
                    b"NiBSParticleNode" => Ok(Self::NiBSParticleNode(stream.load()?)),
                    b"NiBSPNode" => Ok(Self::NiBSPNode(stream.load()?)),
                    b"NiCamera" => Ok(Self::NiCamera(stream.load()?)),
                    b"NiClusterAccumulator" => {
                        Ok(Self::NiClusterAccumulator(stream.load()?))
                    }
                    b"NiCollisionSwitch" => Ok(Self::NiCollisionSwitch(stream.load()?)),
                    b"NiColorData" => Ok(Self::NiColorData(stream.load()?)),
                    b"NiDirectionalLight" => Ok(Self::NiDirectionalLight(stream.load()?)),
                    b"NiDitherProperty" => Ok(Self::NiDitherProperty(stream.load()?)),
                    b"NiDX8Renderer" => Ok(Self::NiDX8Renderer(stream.load()?)),
                    b"NiDynamicEffect" => Ok(Self::NiDynamicEffect(stream.load()?)),
                    b"NiEmitterModifier" => Ok(Self::NiEmitterModifier(stream.load()?)),
                    b"NiExtraData" => Ok(Self::NiExtraData(stream.load()?)),
                    b"NiFlipController" => Ok(Self::NiFlipController(stream.load()?)),
                    b"NiFloatController" => Ok(Self::NiFloatController(stream.load()?)),
                    b"NiFloatData" => Ok(Self::NiFloatData(stream.load()?)),
                    b"NiFltAnimationNode" => Ok(Self::NiFltAnimationNode(stream.load()?)),
                    b"NiFogProperty" => Ok(Self::NiFogProperty(stream.load()?)),
                    b"NiGeometry" => Ok(Self::NiGeometry(stream.load()?)),
                    b"NiGeometryData" => Ok(Self::NiGeometryData(stream.load()?)),
                    b"NiGeomMorpherController" => {
                        Ok(Self::NiGeomMorpherController(stream.load()?))
                    }
                    b"NiGravity" => Ok(Self::NiGravity(stream.load()?)),
                    b"NiKeyframeController" => {
                        Ok(Self::NiKeyframeController(stream.load()?))
                    }
                    b"NiKeyframeData" => Ok(Self::NiKeyframeData(stream.load()?)),
                    b"NiKeyframeManager" => Ok(Self::NiKeyframeManager(stream.load()?)),
                    b"NiLight" => Ok(Self::NiLight(stream.load()?)),
                    b"NiLightColorController" => {
                        Ok(Self::NiLightColorController(stream.load()?))
                    }
                    b"NiLines" => Ok(Self::NiLines(stream.load()?)),
                    b"NiLinesData" => Ok(Self::NiLinesData(stream.load()?)),
                    b"NiLODNode" => Ok(Self::NiLODNode(stream.load()?)),
                    b"NiLookAtController" => Ok(Self::NiLookAtController(stream.load()?)),
                    b"NiMaterialColorController" => {
                        Ok(Self::NiMaterialColorController(stream.load()?))
                    }
                    b"NiMaterialProperty" => Ok(Self::NiMaterialProperty(stream.load()?)),
                    b"NiMorphData" => Ok(Self::NiMorphData(stream.load()?)),
                    b"NiMorpherController" => {
                        Ok(Self::NiMorpherController(stream.load()?))
                    }
                    b"NiNode" => Ok(Self::NiNode(stream.load()?)),
                    b"NiObject" => Ok(Self::NiObject(stream.load()?)),
                    b"NiObjectNET" => Ok(Self::NiObjectNET(stream.load()?)),
                    b"NiPalette" => Ok(Self::NiPalette(stream.load()?)),
                    b"NiParticleBomb" => Ok(Self::NiParticleBomb(stream.load()?)),
                    b"NiParticleCollider" => Ok(Self::NiParticleCollider(stream.load()?)),
                    b"NiParticleColorModifier" => {
                        Ok(Self::NiParticleColorModifier(stream.load()?))
                    }
                    b"NiParticleGrowFade" => Ok(Self::NiParticleGrowFade(stream.load()?)),
                    b"NiParticleModifier" => Ok(Self::NiParticleModifier(stream.load()?)),
                    b"NiParticleRotation" => Ok(Self::NiParticleRotation(stream.load()?)),
                    b"NiParticles" => Ok(Self::NiParticles(stream.load()?)),
                    b"NiParticlesData" => Ok(Self::NiParticlesData(stream.load()?)),
                    b"NiParticleSystemController" => {
                        Ok(Self::NiParticleSystemController(stream.load()?))
                    }
                    b"NiPathController" => Ok(Self::NiPathController(stream.load()?)),
                    b"NiPixelData" => Ok(Self::NiPixelData(stream.load()?)),
                    b"NiPlanarCollider" => Ok(Self::NiPlanarCollider(stream.load()?)),
                    b"NiPointLight" => Ok(Self::NiPointLight(stream.load()?)),
                    b"NiPosData" => Ok(Self::NiPosData(stream.load()?)),
                    b"NiProperty" => Ok(Self::NiProperty(stream.load()?)),
                    b"NiRenderedCubeMap" => Ok(Self::NiRenderedCubeMap(stream.load()?)),
                    b"NiRenderedTexture" => Ok(Self::NiRenderedTexture(stream.load()?)),
                    b"NiRenderer" => Ok(Self::NiRenderer(stream.load()?)),
                    b"NiRollController" => Ok(Self::NiRollController(stream.load()?)),
                    b"NiRotatingParticles" => {
                        Ok(Self::NiRotatingParticles(stream.load()?))
                    }
                    b"NiRotatingParticlesData" => {
                        Ok(Self::NiRotatingParticlesData(stream.load()?))
                    }
                    b"NiRotData" => Ok(Self::NiRotData(stream.load()?)),
                    b"NiScreenPolygon" => Ok(Self::NiScreenPolygon(stream.load()?)),
                    b"NiSequenceStreamHelper" => {
                        Ok(Self::NiSequenceStreamHelper(stream.load()?))
                    }
                    b"NiShadeProperty" => Ok(Self::NiShadeProperty(stream.load()?)),
                    b"NiSkinData" => Ok(Self::NiSkinData(stream.load()?)),
                    b"NiSkinInstance" => Ok(Self::NiSkinInstance(stream.load()?)),
                    b"NiSkinPartition" => Ok(Self::NiSkinPartition(stream.load()?)),
                    b"NiSortAdjustNode" => Ok(Self::NiSortAdjustNode(stream.load()?)),
                    b"NiSourceTexture" => Ok(Self::NiSourceTexture(stream.load()?)),
                    b"NiSpecularProperty" => Ok(Self::NiSpecularProperty(stream.load()?)),
                    b"NiSphericalCollider" => {
                        Ok(Self::NiSphericalCollider(stream.load()?))
                    }
                    b"NiSpotLight" => Ok(Self::NiSpotLight(stream.load()?)),
                    b"NiStencilProperty" => Ok(Self::NiStencilProperty(stream.load()?)),
                    b"NiStringExtraData" => Ok(Self::NiStringExtraData(stream.load()?)),
                    b"NiSwitchNode" => Ok(Self::NiSwitchNode(stream.load()?)),
                    b"NiTextKeyExtraData" => Ok(Self::NiTextKeyExtraData(stream.load()?)),
                    b"NiTexture" => Ok(Self::NiTexture(stream.load()?)),
                    b"NiTextureEffect" => Ok(Self::NiTextureEffect(stream.load()?)),
                    b"NiTexturingProperty" => {
                        Ok(Self::NiTexturingProperty(stream.load()?))
                    }
                    b"NiTimeController" => Ok(Self::NiTimeController(stream.load()?)),
                    b"NiTriBasedGeom" => Ok(Self::NiTriBasedGeom(stream.load()?)),
                    b"NiTriBasedGeomData" => Ok(Self::NiTriBasedGeomData(stream.load()?)),
                    b"NiTriShape" => Ok(Self::NiTriShape(stream.load()?)),
                    b"NiTriShapeData" => Ok(Self::NiTriShapeData(stream.load()?)),
                    b"NiTriShapeDynamicData" => {
                        Ok(Self::NiTriShapeDynamicData(stream.load()?))
                    }
                    b"NiTriStrips" => Ok(Self::NiTriStrips(stream.load()?)),
                    b"NiTriStripsData" => Ok(Self::NiTriStripsData(stream.load()?)),
                    b"NiUVController" => Ok(Self::NiUVController(stream.load()?)),
                    b"NiUVData" => Ok(Self::NiUVData(stream.load()?)),
                    b"NiVertexColorProperty" => {
                        Ok(Self::NiVertexColorProperty(stream.load()?))
                    }
                    b"NiVertWeightsExtraData" => {
                        Ok(Self::NiVertWeightsExtraData(stream.load()?))
                    }
                    b"NiVisController" => Ok(Self::NiVisController(stream.load()?)),
                    b"NiVisData" => Ok(Self::NiVisData(stream.load()?)),
                    b"NiWireframeProperty" => {
                        Ok(Self::NiWireframeProperty(stream.load()?))
                    }
                    b"NiZBufferProperty" => Ok(Self::NiZBufferProperty(stream.load()?)),
                    b"RootCollisionNode" => Ok(Self::RootCollisionNode(stream.load()?)),
                    b"TES3ObjectExtraData" => {
                        Ok(Self::TES3ObjectExtraData(stream.load()?))
                    }
                    _ => {
                        Reader::error(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("Invalid Type: {0}", type_name),
                                )
                            }),
                        )?
                    }
                }
            }
        }
        impl Save for NiType {
            fn save(&self, stream: &mut Writer) -> io::Result<()> {
                match self {
                    &Self::AvoidNode(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::BrickNiExtraData(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::BSMirroredNode(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiAccumulator(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiAlphaAccumulator(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiAlphaController(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiAlphaProperty(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiAmbientLight(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiAutoNormalParticles(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiAutoNormalParticlesData(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiAVObject(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiBillboardNode(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiBltSource(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiBSAnimationManager(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiBSAnimationNode(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiBSPArrayController(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiBSParticleNode(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiBSPNode(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiCamera(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiClusterAccumulator(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiCollisionSwitch(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiColorData(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiDirectionalLight(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiDitherProperty(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiDX8Renderer(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiDynamicEffect(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiEmitterModifier(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiExtraData(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiFlipController(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiFloatController(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiFloatData(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiFltAnimationNode(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiFogProperty(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiGeometry(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiGeometryData(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiGeomMorpherController(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiGravity(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiKeyframeController(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiKeyframeData(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiKeyframeManager(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiLight(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiLightColorController(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiLines(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiLinesData(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiLODNode(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiLookAtController(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiMaterialColorController(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiMaterialProperty(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiMorphData(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiMorpherController(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiNode(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiObject(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiObjectNET(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiPalette(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiParticleBomb(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiParticleCollider(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiParticleColorModifier(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiParticleGrowFade(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiParticleModifier(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiParticleRotation(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiParticles(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiParticlesData(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiParticleSystemController(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiPathController(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiPixelData(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiPlanarCollider(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiPointLight(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiPosData(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiProperty(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiRenderedCubeMap(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiRenderedTexture(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiRenderer(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiRollController(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiRotatingParticles(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiRotatingParticlesData(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiRotData(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiScreenPolygon(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiSequenceStreamHelper(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiShadeProperty(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiSkinData(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiSkinInstance(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiSkinPartition(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiSortAdjustNode(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiSourceTexture(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiSpecularProperty(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiSphericalCollider(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiSpotLight(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiStencilProperty(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiStringExtraData(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiSwitchNode(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiTextKeyExtraData(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiTexture(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiTextureEffect(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiTexturingProperty(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiTimeController(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiTriBasedGeom(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiTriBasedGeomData(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiTriShape(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiTriShapeData(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiTriShapeDynamicData(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiTriStrips(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiTriStripsData(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiUVController(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiUVData(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiVertexColorProperty(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiVertWeightsExtraData(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiVisController(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiVisData(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiWireframeProperty(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::NiZBufferProperty(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::RootCollisionNode(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::TES3ObjectExtraData(ref inner) => {
                        let type_name = inner.type_name();
                        let len = type_name.len() as u32;
                        stream.save(&len)?;
                        stream.write_all(&type_name)?;
                        stream.save(inner)?;
                    }
                    &Self::Empty => {}
                }
                Ok(())
            }
        }
        impl Visitor for NiType {
            #[inline(always)]
            fn visitor<'a, F>(&self, f: &mut F)
            where
                F: FnMut(NiKey),
            {
                match self {
                    &Self::AvoidNode(ref inner) => inner.visitor(f),
                    &Self::BrickNiExtraData(ref inner) => inner.visitor(f),
                    &Self::BSMirroredNode(ref inner) => inner.visitor(f),
                    &Self::NiAccumulator(ref inner) => inner.visitor(f),
                    &Self::NiAlphaAccumulator(ref inner) => inner.visitor(f),
                    &Self::NiAlphaController(ref inner) => inner.visitor(f),
                    &Self::NiAlphaProperty(ref inner) => inner.visitor(f),
                    &Self::NiAmbientLight(ref inner) => inner.visitor(f),
                    &Self::NiAutoNormalParticles(ref inner) => inner.visitor(f),
                    &Self::NiAutoNormalParticlesData(ref inner) => inner.visitor(f),
                    &Self::NiAVObject(ref inner) => inner.visitor(f),
                    &Self::NiBillboardNode(ref inner) => inner.visitor(f),
                    &Self::NiBltSource(ref inner) => inner.visitor(f),
                    &Self::NiBSAnimationManager(ref inner) => inner.visitor(f),
                    &Self::NiBSAnimationNode(ref inner) => inner.visitor(f),
                    &Self::NiBSPArrayController(ref inner) => inner.visitor(f),
                    &Self::NiBSParticleNode(ref inner) => inner.visitor(f),
                    &Self::NiBSPNode(ref inner) => inner.visitor(f),
                    &Self::NiCamera(ref inner) => inner.visitor(f),
                    &Self::NiClusterAccumulator(ref inner) => inner.visitor(f),
                    &Self::NiCollisionSwitch(ref inner) => inner.visitor(f),
                    &Self::NiColorData(ref inner) => inner.visitor(f),
                    &Self::NiDirectionalLight(ref inner) => inner.visitor(f),
                    &Self::NiDitherProperty(ref inner) => inner.visitor(f),
                    &Self::NiDX8Renderer(ref inner) => inner.visitor(f),
                    &Self::NiDynamicEffect(ref inner) => inner.visitor(f),
                    &Self::NiEmitterModifier(ref inner) => inner.visitor(f),
                    &Self::NiExtraData(ref inner) => inner.visitor(f),
                    &Self::NiFlipController(ref inner) => inner.visitor(f),
                    &Self::NiFloatController(ref inner) => inner.visitor(f),
                    &Self::NiFloatData(ref inner) => inner.visitor(f),
                    &Self::NiFltAnimationNode(ref inner) => inner.visitor(f),
                    &Self::NiFogProperty(ref inner) => inner.visitor(f),
                    &Self::NiGeometry(ref inner) => inner.visitor(f),
                    &Self::NiGeometryData(ref inner) => inner.visitor(f),
                    &Self::NiGeomMorpherController(ref inner) => inner.visitor(f),
                    &Self::NiGravity(ref inner) => inner.visitor(f),
                    &Self::NiKeyframeController(ref inner) => inner.visitor(f),
                    &Self::NiKeyframeData(ref inner) => inner.visitor(f),
                    &Self::NiKeyframeManager(ref inner) => inner.visitor(f),
                    &Self::NiLight(ref inner) => inner.visitor(f),
                    &Self::NiLightColorController(ref inner) => inner.visitor(f),
                    &Self::NiLines(ref inner) => inner.visitor(f),
                    &Self::NiLinesData(ref inner) => inner.visitor(f),
                    &Self::NiLODNode(ref inner) => inner.visitor(f),
                    &Self::NiLookAtController(ref inner) => inner.visitor(f),
                    &Self::NiMaterialColorController(ref inner) => inner.visitor(f),
                    &Self::NiMaterialProperty(ref inner) => inner.visitor(f),
                    &Self::NiMorphData(ref inner) => inner.visitor(f),
                    &Self::NiMorpherController(ref inner) => inner.visitor(f),
                    &Self::NiNode(ref inner) => inner.visitor(f),
                    &Self::NiObject(ref inner) => inner.visitor(f),
                    &Self::NiObjectNET(ref inner) => inner.visitor(f),
                    &Self::NiPalette(ref inner) => inner.visitor(f),
                    &Self::NiParticleBomb(ref inner) => inner.visitor(f),
                    &Self::NiParticleCollider(ref inner) => inner.visitor(f),
                    &Self::NiParticleColorModifier(ref inner) => inner.visitor(f),
                    &Self::NiParticleGrowFade(ref inner) => inner.visitor(f),
                    &Self::NiParticleModifier(ref inner) => inner.visitor(f),
                    &Self::NiParticleRotation(ref inner) => inner.visitor(f),
                    &Self::NiParticles(ref inner) => inner.visitor(f),
                    &Self::NiParticlesData(ref inner) => inner.visitor(f),
                    &Self::NiParticleSystemController(ref inner) => inner.visitor(f),
                    &Self::NiPathController(ref inner) => inner.visitor(f),
                    &Self::NiPixelData(ref inner) => inner.visitor(f),
                    &Self::NiPlanarCollider(ref inner) => inner.visitor(f),
                    &Self::NiPointLight(ref inner) => inner.visitor(f),
                    &Self::NiPosData(ref inner) => inner.visitor(f),
                    &Self::NiProperty(ref inner) => inner.visitor(f),
                    &Self::NiRenderedCubeMap(ref inner) => inner.visitor(f),
                    &Self::NiRenderedTexture(ref inner) => inner.visitor(f),
                    &Self::NiRenderer(ref inner) => inner.visitor(f),
                    &Self::NiRollController(ref inner) => inner.visitor(f),
                    &Self::NiRotatingParticles(ref inner) => inner.visitor(f),
                    &Self::NiRotatingParticlesData(ref inner) => inner.visitor(f),
                    &Self::NiRotData(ref inner) => inner.visitor(f),
                    &Self::NiScreenPolygon(ref inner) => inner.visitor(f),
                    &Self::NiSequenceStreamHelper(ref inner) => inner.visitor(f),
                    &Self::NiShadeProperty(ref inner) => inner.visitor(f),
                    &Self::NiSkinData(ref inner) => inner.visitor(f),
                    &Self::NiSkinInstance(ref inner) => inner.visitor(f),
                    &Self::NiSkinPartition(ref inner) => inner.visitor(f),
                    &Self::NiSortAdjustNode(ref inner) => inner.visitor(f),
                    &Self::NiSourceTexture(ref inner) => inner.visitor(f),
                    &Self::NiSpecularProperty(ref inner) => inner.visitor(f),
                    &Self::NiSphericalCollider(ref inner) => inner.visitor(f),
                    &Self::NiSpotLight(ref inner) => inner.visitor(f),
                    &Self::NiStencilProperty(ref inner) => inner.visitor(f),
                    &Self::NiStringExtraData(ref inner) => inner.visitor(f),
                    &Self::NiSwitchNode(ref inner) => inner.visitor(f),
                    &Self::NiTextKeyExtraData(ref inner) => inner.visitor(f),
                    &Self::NiTexture(ref inner) => inner.visitor(f),
                    &Self::NiTextureEffect(ref inner) => inner.visitor(f),
                    &Self::NiTexturingProperty(ref inner) => inner.visitor(f),
                    &Self::NiTimeController(ref inner) => inner.visitor(f),
                    &Self::NiTriBasedGeom(ref inner) => inner.visitor(f),
                    &Self::NiTriBasedGeomData(ref inner) => inner.visitor(f),
                    &Self::NiTriShape(ref inner) => inner.visitor(f),
                    &Self::NiTriShapeData(ref inner) => inner.visitor(f),
                    &Self::NiTriShapeDynamicData(ref inner) => inner.visitor(f),
                    &Self::NiTriStrips(ref inner) => inner.visitor(f),
                    &Self::NiTriStripsData(ref inner) => inner.visitor(f),
                    &Self::NiUVController(ref inner) => inner.visitor(f),
                    &Self::NiUVData(ref inner) => inner.visitor(f),
                    &Self::NiVertexColorProperty(ref inner) => inner.visitor(f),
                    &Self::NiVertWeightsExtraData(ref inner) => inner.visitor(f),
                    &Self::NiVisController(ref inner) => inner.visitor(f),
                    &Self::NiVisData(ref inner) => inner.visitor(f),
                    &Self::NiWireframeProperty(ref inner) => inner.visitor(f),
                    &Self::NiZBufferProperty(ref inner) => inner.visitor(f),
                    &Self::RootCollisionNode(ref inner) => inner.visitor(f),
                    &Self::TES3ObjectExtraData(ref inner) => inner.visitor(f),
                    &Self::Empty => {}
                }
            }
        }
    };
    impl NiType {
        pub const fn type_name(&self) -> &'static [u8] {
            match self {
                NiType::AvoidNode(inner) => inner.type_name(),
                NiType::BrickNiExtraData(inner) => inner.type_name(),
                NiType::BSMirroredNode(inner) => inner.type_name(),
                NiType::NiAccumulator(inner) => inner.type_name(),
                NiType::NiAlphaAccumulator(inner) => inner.type_name(),
                NiType::NiAlphaController(inner) => inner.type_name(),
                NiType::NiAlphaProperty(inner) => inner.type_name(),
                NiType::NiAmbientLight(inner) => inner.type_name(),
                NiType::NiAutoNormalParticles(inner) => inner.type_name(),
                NiType::NiAutoNormalParticlesData(inner) => inner.type_name(),
                NiType::NiAVObject(inner) => inner.type_name(),
                NiType::NiBillboardNode(inner) => inner.type_name(),
                NiType::NiBltSource(inner) => inner.type_name(),
                NiType::NiBSAnimationManager(inner) => inner.type_name(),
                NiType::NiBSAnimationNode(inner) => inner.type_name(),
                NiType::NiBSPArrayController(inner) => inner.type_name(),
                NiType::NiBSParticleNode(inner) => inner.type_name(),
                NiType::NiBSPNode(inner) => inner.type_name(),
                NiType::NiCamera(inner) => inner.type_name(),
                NiType::NiClusterAccumulator(inner) => inner.type_name(),
                NiType::NiCollisionSwitch(inner) => inner.type_name(),
                NiType::NiColorData(inner) => inner.type_name(),
                NiType::NiDirectionalLight(inner) => inner.type_name(),
                NiType::NiDitherProperty(inner) => inner.type_name(),
                NiType::NiDX8Renderer(inner) => inner.type_name(),
                NiType::NiDynamicEffect(inner) => inner.type_name(),
                NiType::NiEmitterModifier(inner) => inner.type_name(),
                NiType::NiExtraData(inner) => inner.type_name(),
                NiType::NiFlipController(inner) => inner.type_name(),
                NiType::NiFloatController(inner) => inner.type_name(),
                NiType::NiFloatData(inner) => inner.type_name(),
                NiType::NiFltAnimationNode(inner) => inner.type_name(),
                NiType::NiFogProperty(inner) => inner.type_name(),
                NiType::NiGeometry(inner) => inner.type_name(),
                NiType::NiGeometryData(inner) => inner.type_name(),
                NiType::NiGeomMorpherController(inner) => inner.type_name(),
                NiType::NiGravity(inner) => inner.type_name(),
                NiType::NiKeyframeController(inner) => inner.type_name(),
                NiType::NiKeyframeData(inner) => inner.type_name(),
                NiType::NiKeyframeManager(inner) => inner.type_name(),
                NiType::NiLight(inner) => inner.type_name(),
                NiType::NiLightColorController(inner) => inner.type_name(),
                NiType::NiLines(inner) => inner.type_name(),
                NiType::NiLinesData(inner) => inner.type_name(),
                NiType::NiLODNode(inner) => inner.type_name(),
                NiType::NiLookAtController(inner) => inner.type_name(),
                NiType::NiMaterialColorController(inner) => inner.type_name(),
                NiType::NiMaterialProperty(inner) => inner.type_name(),
                NiType::NiMorphData(inner) => inner.type_name(),
                NiType::NiMorpherController(inner) => inner.type_name(),
                NiType::NiNode(inner) => inner.type_name(),
                NiType::NiObject(inner) => inner.type_name(),
                NiType::NiObjectNET(inner) => inner.type_name(),
                NiType::NiPalette(inner) => inner.type_name(),
                NiType::NiParticleBomb(inner) => inner.type_name(),
                NiType::NiParticleCollider(inner) => inner.type_name(),
                NiType::NiParticleColorModifier(inner) => inner.type_name(),
                NiType::NiParticleGrowFade(inner) => inner.type_name(),
                NiType::NiParticleModifier(inner) => inner.type_name(),
                NiType::NiParticleRotation(inner) => inner.type_name(),
                NiType::NiParticles(inner) => inner.type_name(),
                NiType::NiParticlesData(inner) => inner.type_name(),
                NiType::NiParticleSystemController(inner) => inner.type_name(),
                NiType::NiPathController(inner) => inner.type_name(),
                NiType::NiPixelData(inner) => inner.type_name(),
                NiType::NiPlanarCollider(inner) => inner.type_name(),
                NiType::NiPointLight(inner) => inner.type_name(),
                NiType::NiPosData(inner) => inner.type_name(),
                NiType::NiProperty(inner) => inner.type_name(),
                NiType::NiRenderedCubeMap(inner) => inner.type_name(),
                NiType::NiRenderedTexture(inner) => inner.type_name(),
                NiType::NiRenderer(inner) => inner.type_name(),
                NiType::NiRollController(inner) => inner.type_name(),
                NiType::NiRotatingParticles(inner) => inner.type_name(),
                NiType::NiRotatingParticlesData(inner) => inner.type_name(),
                NiType::NiRotData(inner) => inner.type_name(),
                NiType::NiScreenPolygon(inner) => inner.type_name(),
                NiType::NiSequenceStreamHelper(inner) => inner.type_name(),
                NiType::NiShadeProperty(inner) => inner.type_name(),
                NiType::NiSkinData(inner) => inner.type_name(),
                NiType::NiSkinInstance(inner) => inner.type_name(),
                NiType::NiSkinPartition(inner) => inner.type_name(),
                NiType::NiSortAdjustNode(inner) => inner.type_name(),
                NiType::NiSourceTexture(inner) => inner.type_name(),
                NiType::NiSpecularProperty(inner) => inner.type_name(),
                NiType::NiSphericalCollider(inner) => inner.type_name(),
                NiType::NiSpotLight(inner) => inner.type_name(),
                NiType::NiStencilProperty(inner) => inner.type_name(),
                NiType::NiStringExtraData(inner) => inner.type_name(),
                NiType::NiSwitchNode(inner) => inner.type_name(),
                NiType::NiTextKeyExtraData(inner) => inner.type_name(),
                NiType::NiTexture(inner) => inner.type_name(),
                NiType::NiTextureEffect(inner) => inner.type_name(),
                NiType::NiTexturingProperty(inner) => inner.type_name(),
                NiType::NiTimeController(inner) => inner.type_name(),
                NiType::NiTriBasedGeom(inner) => inner.type_name(),
                NiType::NiTriBasedGeomData(inner) => inner.type_name(),
                NiType::NiTriShape(inner) => inner.type_name(),
                NiType::NiTriShapeData(inner) => inner.type_name(),
                NiType::NiTriShapeDynamicData(inner) => inner.type_name(),
                NiType::NiTriStrips(inner) => inner.type_name(),
                NiType::NiTriStripsData(inner) => inner.type_name(),
                NiType::NiUVController(inner) => inner.type_name(),
                NiType::NiUVData(inner) => inner.type_name(),
                NiType::NiVertexColorProperty(inner) => inner.type_name(),
                NiType::NiVertWeightsExtraData(inner) => inner.type_name(),
                NiType::NiVisController(inner) => inner.type_name(),
                NiType::NiVisData(inner) => inner.type_name(),
                NiType::NiWireframeProperty(inner) => inner.type_name(),
                NiType::NiZBufferProperty(inner) => inner.type_name(),
                NiType::RootCollisionNode(inner) => inner.type_name(),
                NiType::TES3ObjectExtraData(inner) => inner.type_name(),
            }
        }
    }
    impl TryFrom<NiType> for AvoidNode {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::AvoidNode(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for BrickNiExtraData {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::BrickNiExtraData(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for BSMirroredNode {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::BSMirroredNode(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiAccumulator {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiAccumulator(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiAlphaAccumulator {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiAlphaAccumulator(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiAlphaController {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiAlphaController(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiAlphaProperty {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiAlphaProperty(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiAmbientLight {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiAmbientLight(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiAutoNormalParticles {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiAutoNormalParticles(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiAutoNormalParticlesData {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiAutoNormalParticlesData(o) = value {
                Ok(o)
            } else {
                Err(())
            }
        }
    }
    impl TryFrom<NiType> for NiAVObject {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiAVObject(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiBillboardNode {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiBillboardNode(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiBltSource {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiBltSource(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiBSAnimationManager {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiBSAnimationManager(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiBSAnimationNode {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiBSAnimationNode(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiBSPArrayController {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiBSPArrayController(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiBSParticleNode {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiBSParticleNode(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiBSPNode {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiBSPNode(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiCamera {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiCamera(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiClusterAccumulator {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiClusterAccumulator(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiCollisionSwitch {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiCollisionSwitch(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiColorData {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiColorData(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiDirectionalLight {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiDirectionalLight(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiDitherProperty {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiDitherProperty(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiDX8Renderer {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiDX8Renderer(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiDynamicEffect {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiDynamicEffect(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiEmitterModifier {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiEmitterModifier(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiExtraData {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiExtraData(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiFlipController {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiFlipController(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiFloatController {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiFloatController(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiFloatData {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiFloatData(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiFltAnimationNode {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiFltAnimationNode(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiFogProperty {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiFogProperty(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiGeometry {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiGeometry(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiGeometryData {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiGeometryData(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiGeomMorpherController {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiGeomMorpherController(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiGravity {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiGravity(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiKeyframeController {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiKeyframeController(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiKeyframeData {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiKeyframeData(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiKeyframeManager {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiKeyframeManager(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiLight {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiLight(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiLightColorController {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiLightColorController(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiLines {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiLines(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiLinesData {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiLinesData(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiLODNode {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiLODNode(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiLookAtController {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiLookAtController(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiMaterialColorController {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiMaterialColorController(o) = value {
                Ok(o)
            } else {
                Err(())
            }
        }
    }
    impl TryFrom<NiType> for NiMaterialProperty {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiMaterialProperty(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiMorphData {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiMorphData(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiMorpherController {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiMorpherController(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiNode {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiNode(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiObject {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiObject(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiObjectNET {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiObjectNET(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiPalette {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiPalette(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiParticleBomb {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiParticleBomb(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiParticleCollider {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiParticleCollider(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiParticleColorModifier {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiParticleColorModifier(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiParticleGrowFade {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiParticleGrowFade(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiParticleModifier {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiParticleModifier(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiParticleRotation {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiParticleRotation(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiParticles {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiParticles(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiParticlesData {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiParticlesData(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiParticleSystemController {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiParticleSystemController(o) = value {
                Ok(o)
            } else {
                Err(())
            }
        }
    }
    impl TryFrom<NiType> for NiPathController {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiPathController(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiPixelData {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiPixelData(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiPlanarCollider {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiPlanarCollider(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiPointLight {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiPointLight(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiPosData {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiPosData(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiProperty {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiProperty(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiRenderedCubeMap {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiRenderedCubeMap(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiRenderedTexture {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiRenderedTexture(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiRenderer {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiRenderer(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiRollController {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiRollController(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiRotatingParticles {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiRotatingParticles(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiRotatingParticlesData {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiRotatingParticlesData(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiRotData {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiRotData(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiScreenPolygon {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiScreenPolygon(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiSequenceStreamHelper {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiSequenceStreamHelper(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiShadeProperty {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiShadeProperty(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiSkinData {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiSkinData(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiSkinInstance {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiSkinInstance(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiSkinPartition {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiSkinPartition(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiSortAdjustNode {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiSortAdjustNode(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiSourceTexture {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiSourceTexture(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiSpecularProperty {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiSpecularProperty(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiSphericalCollider {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiSphericalCollider(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiSpotLight {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiSpotLight(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiStencilProperty {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiStencilProperty(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiStringExtraData {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiStringExtraData(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiSwitchNode {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiSwitchNode(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiTextKeyExtraData {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiTextKeyExtraData(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiTexture {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiTexture(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiTextureEffect {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiTextureEffect(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiTexturingProperty {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiTexturingProperty(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiTimeController {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiTimeController(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiTriBasedGeom {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiTriBasedGeom(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiTriBasedGeomData {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiTriBasedGeomData(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiTriShape {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiTriShape(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiTriShapeData {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiTriShapeData(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiTriShapeDynamicData {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiTriShapeDynamicData(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiTriStrips {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiTriStrips(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiTriStripsData {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiTriStripsData(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiUVController {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiUVController(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiUVData {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiUVData(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiVertexColorProperty {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiVertexColorProperty(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiVertWeightsExtraData {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiVertWeightsExtraData(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiVisController {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiVisController(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiVisData {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiVisData(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiWireframeProperty {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiWireframeProperty(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for NiZBufferProperty {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::NiZBufferProperty(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for RootCollisionNode {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::RootCollisionNode(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl TryFrom<NiType> for TES3ObjectExtraData {
        type Error = ();
        fn try_from(value: NiType) -> Result<Self, Self::Error> {
            if let NiType::TES3ObjectExtraData(o) = value { Ok(o) } else { Err(()) }
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiBSParticleNode {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiBSParticleNode(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiBSParticleNode {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiBSParticleNode(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiBSParticleNode> for NiBSParticleNode {
        fn as_ref(&self) -> &NiBSParticleNode {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiLinesData {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiLinesData(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiLinesData {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiLinesData(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiLinesData> for NiLinesData {
        fn as_ref(&self) -> &NiLinesData {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiFogProperty {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiFogProperty(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiFogProperty {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiFogProperty(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiFogProperty> for NiFogProperty {
        fn as_ref(&self) -> &NiFogProperty {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiLines {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiLines(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiLines {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiLines(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiLines> for NiLines {
        fn as_ref(&self) -> &NiLines {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiRenderedTexture {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiRenderedTexture(inner) => Ok(inner),
                NiType::NiRenderedCubeMap(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiRenderedTexture {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiRenderedTexture(inner) => Ok(inner),
                NiType::NiRenderedCubeMap(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiRenderedTexture> for NiRenderedTexture {
        fn as_ref(&self) -> &NiRenderedTexture {
            &self
        }
    }
    impl AsRef<NiRenderedTexture> for NiRenderedCubeMap {
        fn as_ref(&self) -> &NiRenderedTexture {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiTriBasedGeomData {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiTriBasedGeomData(inner) => Ok(inner),
                NiType::NiTriShapeData(inner) => Ok(inner),
                NiType::NiTriShapeDynamicData(inner) => Ok(inner),
                NiType::NiTriStripsData(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiTriBasedGeomData {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiTriBasedGeomData(inner) => Ok(inner),
                NiType::NiTriShapeData(inner) => Ok(inner),
                NiType::NiTriShapeDynamicData(inner) => Ok(inner),
                NiType::NiTriStripsData(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiTriBasedGeomData> for NiTriBasedGeomData {
        fn as_ref(&self) -> &NiTriBasedGeomData {
            &self
        }
    }
    impl AsRef<NiTriBasedGeomData> for NiTriShapeData {
        fn as_ref(&self) -> &NiTriBasedGeomData {
            &self
        }
    }
    impl AsRef<NiTriBasedGeomData> for NiTriShapeDynamicData {
        fn as_ref(&self) -> &NiTriBasedGeomData {
            &self
        }
    }
    impl AsRef<NiTriBasedGeomData> for NiTriStripsData {
        fn as_ref(&self) -> &NiTriBasedGeomData {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiAutoNormalParticles {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiAutoNormalParticles(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiAutoNormalParticles {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiAutoNormalParticles(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiAutoNormalParticles> for NiAutoNormalParticles {
        fn as_ref(&self) -> &NiAutoNormalParticles {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiExtraData {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiExtraData(inner) => Ok(inner),
                NiType::NiTextKeyExtraData(inner) => Ok(inner),
                NiType::NiStringExtraData(inner) => Ok(inner),
                NiType::NiVertWeightsExtraData(inner) => Ok(inner),
                NiType::TES3ObjectExtraData(inner) => Ok(inner),
                NiType::BrickNiExtraData(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiExtraData {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiExtraData(inner) => Ok(inner),
                NiType::NiTextKeyExtraData(inner) => Ok(inner),
                NiType::NiStringExtraData(inner) => Ok(inner),
                NiType::NiVertWeightsExtraData(inner) => Ok(inner),
                NiType::TES3ObjectExtraData(inner) => Ok(inner),
                NiType::BrickNiExtraData(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiExtraData> for NiExtraData {
        fn as_ref(&self) -> &NiExtraData {
            &self
        }
    }
    impl AsRef<NiExtraData> for NiTextKeyExtraData {
        fn as_ref(&self) -> &NiExtraData {
            &self
        }
    }
    impl AsRef<NiExtraData> for NiStringExtraData {
        fn as_ref(&self) -> &NiExtraData {
            &self
        }
    }
    impl AsRef<NiExtraData> for NiVertWeightsExtraData {
        fn as_ref(&self) -> &NiExtraData {
            &self
        }
    }
    impl AsRef<NiExtraData> for TES3ObjectExtraData {
        fn as_ref(&self) -> &NiExtraData {
            &self
        }
    }
    impl AsRef<NiExtraData> for BrickNiExtraData {
        fn as_ref(&self) -> &NiExtraData {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiAlphaProperty {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiAlphaProperty(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiAlphaProperty {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiAlphaProperty(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiAlphaProperty> for NiAlphaProperty {
        fn as_ref(&self) -> &NiAlphaProperty {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiAccumulator {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiAccumulator(inner) => Ok(inner),
                NiType::NiAlphaAccumulator(inner) => Ok(inner),
                NiType::NiClusterAccumulator(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiAccumulator {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiAccumulator(inner) => Ok(inner),
                NiType::NiAlphaAccumulator(inner) => Ok(inner),
                NiType::NiClusterAccumulator(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiAccumulator> for NiAccumulator {
        fn as_ref(&self) -> &NiAccumulator {
            &self
        }
    }
    impl AsRef<NiAccumulator> for NiAlphaAccumulator {
        fn as_ref(&self) -> &NiAccumulator {
            &self
        }
    }
    impl AsRef<NiAccumulator> for NiClusterAccumulator {
        fn as_ref(&self) -> &NiAccumulator {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiCollisionSwitch {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiCollisionSwitch(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiCollisionSwitch {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiCollisionSwitch(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiCollisionSwitch> for NiCollisionSwitch {
        fn as_ref(&self) -> &NiCollisionSwitch {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiObjectNET {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiBSParticleNode(inner) => Ok(inner),
                NiType::NiFogProperty(inner) => Ok(inner),
                NiType::NiLines(inner) => Ok(inner),
                NiType::NiRenderedTexture(inner) => Ok(inner),
                NiType::NiAutoNormalParticles(inner) => Ok(inner),
                NiType::NiAlphaProperty(inner) => Ok(inner),
                NiType::NiCollisionSwitch(inner) => Ok(inner),
                NiType::NiObjectNET(inner) => Ok(inner),
                NiType::NiBSPNode(inner) => Ok(inner),
                NiType::NiBSAnimationNode(inner) => Ok(inner),
                NiType::AvoidNode(inner) => Ok(inner),
                NiType::NiDitherProperty(inner) => Ok(inner),
                NiType::NiProperty(inner) => Ok(inner),
                NiType::NiSequenceStreamHelper(inner) => Ok(inner),
                NiType::NiSpecularProperty(inner) => Ok(inner),
                NiType::NiShadeProperty(inner) => Ok(inner),
                NiType::NiSpotLight(inner) => Ok(inner),
                NiType::BSMirroredNode(inner) => Ok(inner),
                NiType::NiBillboardNode(inner) => Ok(inner),
                NiType::NiBSAnimationManager(inner) => Ok(inner),
                NiType::NiTextureEffect(inner) => Ok(inner),
                NiType::NiAVObject(inner) => Ok(inner),
                NiType::NiNode(inner) => Ok(inner),
                NiType::NiTexturingProperty(inner) => Ok(inner),
                NiType::NiTriBasedGeom(inner) => Ok(inner),
                NiType::NiVertexColorProperty(inner) => Ok(inner),
                NiType::NiSwitchNode(inner) => Ok(inner),
                NiType::NiSortAdjustNode(inner) => Ok(inner),
                NiType::NiWireframeProperty(inner) => Ok(inner),
                NiType::NiRenderedCubeMap(inner) => Ok(inner),
                NiType::NiZBufferProperty(inner) => Ok(inner),
                NiType::RootCollisionNode(inner) => Ok(inner),
                NiType::NiTexture(inner) => Ok(inner),
                NiType::NiStencilProperty(inner) => Ok(inner),
                NiType::NiAmbientLight(inner) => Ok(inner),
                NiType::NiPointLight(inner) => Ok(inner),
                NiType::NiLODNode(inner) => Ok(inner),
                NiType::NiDirectionalLight(inner) => Ok(inner),
                NiType::NiRotatingParticles(inner) => Ok(inner),
                NiType::NiParticles(inner) => Ok(inner),
                NiType::NiFltAnimationNode(inner) => Ok(inner),
                NiType::NiSourceTexture(inner) => Ok(inner),
                NiType::NiTriStrips(inner) => Ok(inner),
                NiType::NiTriShape(inner) => Ok(inner),
                NiType::NiCamera(inner) => Ok(inner),
                NiType::NiLight(inner) => Ok(inner),
                NiType::NiDynamicEffect(inner) => Ok(inner),
                NiType::NiGeometry(inner) => Ok(inner),
                NiType::NiMaterialProperty(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiObjectNET {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiBSParticleNode(inner) => Ok(inner),
                NiType::NiFogProperty(inner) => Ok(inner),
                NiType::NiLines(inner) => Ok(inner),
                NiType::NiRenderedTexture(inner) => Ok(inner),
                NiType::NiAutoNormalParticles(inner) => Ok(inner),
                NiType::NiAlphaProperty(inner) => Ok(inner),
                NiType::NiCollisionSwitch(inner) => Ok(inner),
                NiType::NiObjectNET(inner) => Ok(inner),
                NiType::NiBSPNode(inner) => Ok(inner),
                NiType::NiBSAnimationNode(inner) => Ok(inner),
                NiType::AvoidNode(inner) => Ok(inner),
                NiType::NiDitherProperty(inner) => Ok(inner),
                NiType::NiProperty(inner) => Ok(inner),
                NiType::NiSequenceStreamHelper(inner) => Ok(inner),
                NiType::NiSpecularProperty(inner) => Ok(inner),
                NiType::NiShadeProperty(inner) => Ok(inner),
                NiType::NiSpotLight(inner) => Ok(inner),
                NiType::BSMirroredNode(inner) => Ok(inner),
                NiType::NiBillboardNode(inner) => Ok(inner),
                NiType::NiBSAnimationManager(inner) => Ok(inner),
                NiType::NiTextureEffect(inner) => Ok(inner),
                NiType::NiAVObject(inner) => Ok(inner),
                NiType::NiNode(inner) => Ok(inner),
                NiType::NiTexturingProperty(inner) => Ok(inner),
                NiType::NiTriBasedGeom(inner) => Ok(inner),
                NiType::NiVertexColorProperty(inner) => Ok(inner),
                NiType::NiSwitchNode(inner) => Ok(inner),
                NiType::NiSortAdjustNode(inner) => Ok(inner),
                NiType::NiWireframeProperty(inner) => Ok(inner),
                NiType::NiRenderedCubeMap(inner) => Ok(inner),
                NiType::NiZBufferProperty(inner) => Ok(inner),
                NiType::RootCollisionNode(inner) => Ok(inner),
                NiType::NiTexture(inner) => Ok(inner),
                NiType::NiStencilProperty(inner) => Ok(inner),
                NiType::NiAmbientLight(inner) => Ok(inner),
                NiType::NiPointLight(inner) => Ok(inner),
                NiType::NiLODNode(inner) => Ok(inner),
                NiType::NiDirectionalLight(inner) => Ok(inner),
                NiType::NiRotatingParticles(inner) => Ok(inner),
                NiType::NiParticles(inner) => Ok(inner),
                NiType::NiFltAnimationNode(inner) => Ok(inner),
                NiType::NiSourceTexture(inner) => Ok(inner),
                NiType::NiTriStrips(inner) => Ok(inner),
                NiType::NiTriShape(inner) => Ok(inner),
                NiType::NiCamera(inner) => Ok(inner),
                NiType::NiLight(inner) => Ok(inner),
                NiType::NiDynamicEffect(inner) => Ok(inner),
                NiType::NiGeometry(inner) => Ok(inner),
                NiType::NiMaterialProperty(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiObjectNET> for NiBSParticleNode {
        fn as_ref(&self) -> &NiObjectNET {
            &self
        }
    }
    impl AsRef<NiObjectNET> for NiFogProperty {
        fn as_ref(&self) -> &NiObjectNET {
            &self
        }
    }
    impl AsRef<NiObjectNET> for NiLines {
        fn as_ref(&self) -> &NiObjectNET {
            &self
        }
    }
    impl AsRef<NiObjectNET> for NiRenderedTexture {
        fn as_ref(&self) -> &NiObjectNET {
            &self
        }
    }
    impl AsRef<NiObjectNET> for NiAutoNormalParticles {
        fn as_ref(&self) -> &NiObjectNET {
            &self
        }
    }
    impl AsRef<NiObjectNET> for NiAlphaProperty {
        fn as_ref(&self) -> &NiObjectNET {
            &self
        }
    }
    impl AsRef<NiObjectNET> for NiCollisionSwitch {
        fn as_ref(&self) -> &NiObjectNET {
            &self
        }
    }
    impl AsRef<NiObjectNET> for NiObjectNET {
        fn as_ref(&self) -> &NiObjectNET {
            &self
        }
    }
    impl AsRef<NiObjectNET> for NiBSPNode {
        fn as_ref(&self) -> &NiObjectNET {
            &self
        }
    }
    impl AsRef<NiObjectNET> for NiBSAnimationNode {
        fn as_ref(&self) -> &NiObjectNET {
            &self
        }
    }
    impl AsRef<NiObjectNET> for AvoidNode {
        fn as_ref(&self) -> &NiObjectNET {
            &self
        }
    }
    impl AsRef<NiObjectNET> for NiDitherProperty {
        fn as_ref(&self) -> &NiObjectNET {
            &self
        }
    }
    impl AsRef<NiObjectNET> for NiProperty {
        fn as_ref(&self) -> &NiObjectNET {
            &self
        }
    }
    impl AsRef<NiObjectNET> for NiSequenceStreamHelper {
        fn as_ref(&self) -> &NiObjectNET {
            &self
        }
    }
    impl AsRef<NiObjectNET> for NiSpecularProperty {
        fn as_ref(&self) -> &NiObjectNET {
            &self
        }
    }
    impl AsRef<NiObjectNET> for NiShadeProperty {
        fn as_ref(&self) -> &NiObjectNET {
            &self
        }
    }
    impl AsRef<NiObjectNET> for NiSpotLight {
        fn as_ref(&self) -> &NiObjectNET {
            &self
        }
    }
    impl AsRef<NiObjectNET> for BSMirroredNode {
        fn as_ref(&self) -> &NiObjectNET {
            &self
        }
    }
    impl AsRef<NiObjectNET> for NiBillboardNode {
        fn as_ref(&self) -> &NiObjectNET {
            &self
        }
    }
    impl AsRef<NiObjectNET> for NiBSAnimationManager {
        fn as_ref(&self) -> &NiObjectNET {
            &self
        }
    }
    impl AsRef<NiObjectNET> for NiTextureEffect {
        fn as_ref(&self) -> &NiObjectNET {
            &self
        }
    }
    impl AsRef<NiObjectNET> for NiAVObject {
        fn as_ref(&self) -> &NiObjectNET {
            &self
        }
    }
    impl AsRef<NiObjectNET> for NiNode {
        fn as_ref(&self) -> &NiObjectNET {
            &self
        }
    }
    impl AsRef<NiObjectNET> for NiTexturingProperty {
        fn as_ref(&self) -> &NiObjectNET {
            &self
        }
    }
    impl AsRef<NiObjectNET> for NiTriBasedGeom {
        fn as_ref(&self) -> &NiObjectNET {
            &self
        }
    }
    impl AsRef<NiObjectNET> for NiVertexColorProperty {
        fn as_ref(&self) -> &NiObjectNET {
            &self
        }
    }
    impl AsRef<NiObjectNET> for NiSwitchNode {
        fn as_ref(&self) -> &NiObjectNET {
            &self
        }
    }
    impl AsRef<NiObjectNET> for NiSortAdjustNode {
        fn as_ref(&self) -> &NiObjectNET {
            &self
        }
    }
    impl AsRef<NiObjectNET> for NiWireframeProperty {
        fn as_ref(&self) -> &NiObjectNET {
            &self
        }
    }
    impl AsRef<NiObjectNET> for NiRenderedCubeMap {
        fn as_ref(&self) -> &NiObjectNET {
            &self
        }
    }
    impl AsRef<NiObjectNET> for NiZBufferProperty {
        fn as_ref(&self) -> &NiObjectNET {
            &self
        }
    }
    impl AsRef<NiObjectNET> for RootCollisionNode {
        fn as_ref(&self) -> &NiObjectNET {
            &self
        }
    }
    impl AsRef<NiObjectNET> for NiTexture {
        fn as_ref(&self) -> &NiObjectNET {
            &self
        }
    }
    impl AsRef<NiObjectNET> for NiStencilProperty {
        fn as_ref(&self) -> &NiObjectNET {
            &self
        }
    }
    impl AsRef<NiObjectNET> for NiAmbientLight {
        fn as_ref(&self) -> &NiObjectNET {
            &self
        }
    }
    impl AsRef<NiObjectNET> for NiPointLight {
        fn as_ref(&self) -> &NiObjectNET {
            &self
        }
    }
    impl AsRef<NiObjectNET> for NiLODNode {
        fn as_ref(&self) -> &NiObjectNET {
            &self
        }
    }
    impl AsRef<NiObjectNET> for NiDirectionalLight {
        fn as_ref(&self) -> &NiObjectNET {
            &self
        }
    }
    impl AsRef<NiObjectNET> for NiRotatingParticles {
        fn as_ref(&self) -> &NiObjectNET {
            &self
        }
    }
    impl AsRef<NiObjectNET> for NiParticles {
        fn as_ref(&self) -> &NiObjectNET {
            &self
        }
    }
    impl AsRef<NiObjectNET> for NiFltAnimationNode {
        fn as_ref(&self) -> &NiObjectNET {
            &self
        }
    }
    impl AsRef<NiObjectNET> for NiSourceTexture {
        fn as_ref(&self) -> &NiObjectNET {
            &self
        }
    }
    impl AsRef<NiObjectNET> for NiTriStrips {
        fn as_ref(&self) -> &NiObjectNET {
            &self
        }
    }
    impl AsRef<NiObjectNET> for NiTriShape {
        fn as_ref(&self) -> &NiObjectNET {
            &self
        }
    }
    impl AsRef<NiObjectNET> for NiCamera {
        fn as_ref(&self) -> &NiObjectNET {
            &self
        }
    }
    impl AsRef<NiObjectNET> for NiLight {
        fn as_ref(&self) -> &NiObjectNET {
            &self
        }
    }
    impl AsRef<NiObjectNET> for NiDynamicEffect {
        fn as_ref(&self) -> &NiObjectNET {
            &self
        }
    }
    impl AsRef<NiObjectNET> for NiGeometry {
        fn as_ref(&self) -> &NiObjectNET {
            &self
        }
    }
    impl AsRef<NiObjectNET> for NiMaterialProperty {
        fn as_ref(&self) -> &NiObjectNET {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiBSPNode {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiBSPNode(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiBSPNode {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiBSPNode(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiBSPNode> for NiBSPNode {
        fn as_ref(&self) -> &NiBSPNode {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiBSAnimationNode {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiBSAnimationNode(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiBSAnimationNode {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiBSAnimationNode(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiBSAnimationNode> for NiBSAnimationNode {
        fn as_ref(&self) -> &NiBSAnimationNode {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiPalette {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiPalette(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiPalette {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiPalette(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiPalette> for NiPalette {
        fn as_ref(&self) -> &NiPalette {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiGeomMorpherController {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiGeomMorpherController(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiGeomMorpherController {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiGeomMorpherController(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiGeomMorpherController> for NiGeomMorpherController {
        fn as_ref(&self) -> &NiGeomMorpherController {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiPathController {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiPathController(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiPathController {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiPathController(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiPathController> for NiPathController {
        fn as_ref(&self) -> &NiPathController {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a AvoidNode {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::AvoidNode(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut AvoidNode {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::AvoidNode(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<AvoidNode> for AvoidNode {
        fn as_ref(&self) -> &AvoidNode {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiRenderer {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiRenderer(inner) => Ok(inner),
                NiType::NiDX8Renderer(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiRenderer {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiRenderer(inner) => Ok(inner),
                NiType::NiDX8Renderer(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiRenderer> for NiRenderer {
        fn as_ref(&self) -> &NiRenderer {
            &self
        }
    }
    impl AsRef<NiRenderer> for NiDX8Renderer {
        fn as_ref(&self) -> &NiRenderer {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiDitherProperty {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiDitherProperty(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiDitherProperty {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiDitherProperty(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiDitherProperty> for NiDitherProperty {
        fn as_ref(&self) -> &NiDitherProperty {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiParticlesData {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiParticlesData(inner) => Ok(inner),
                NiType::NiRotatingParticlesData(inner) => Ok(inner),
                NiType::NiAutoNormalParticlesData(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiParticlesData {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiParticlesData(inner) => Ok(inner),
                NiType::NiRotatingParticlesData(inner) => Ok(inner),
                NiType::NiAutoNormalParticlesData(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiParticlesData> for NiParticlesData {
        fn as_ref(&self) -> &NiParticlesData {
            &self
        }
    }
    impl AsRef<NiParticlesData> for NiRotatingParticlesData {
        fn as_ref(&self) -> &NiParticlesData {
            &self
        }
    }
    impl AsRef<NiParticlesData> for NiAutoNormalParticlesData {
        fn as_ref(&self) -> &NiParticlesData {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiProperty {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiFogProperty(inner) => Ok(inner),
                NiType::NiAlphaProperty(inner) => Ok(inner),
                NiType::NiDitherProperty(inner) => Ok(inner),
                NiType::NiProperty(inner) => Ok(inner),
                NiType::NiSpecularProperty(inner) => Ok(inner),
                NiType::NiShadeProperty(inner) => Ok(inner),
                NiType::NiTexturingProperty(inner) => Ok(inner),
                NiType::NiVertexColorProperty(inner) => Ok(inner),
                NiType::NiWireframeProperty(inner) => Ok(inner),
                NiType::NiZBufferProperty(inner) => Ok(inner),
                NiType::NiStencilProperty(inner) => Ok(inner),
                NiType::NiMaterialProperty(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiProperty {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiFogProperty(inner) => Ok(inner),
                NiType::NiAlphaProperty(inner) => Ok(inner),
                NiType::NiDitherProperty(inner) => Ok(inner),
                NiType::NiProperty(inner) => Ok(inner),
                NiType::NiSpecularProperty(inner) => Ok(inner),
                NiType::NiShadeProperty(inner) => Ok(inner),
                NiType::NiTexturingProperty(inner) => Ok(inner),
                NiType::NiVertexColorProperty(inner) => Ok(inner),
                NiType::NiWireframeProperty(inner) => Ok(inner),
                NiType::NiZBufferProperty(inner) => Ok(inner),
                NiType::NiStencilProperty(inner) => Ok(inner),
                NiType::NiMaterialProperty(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiProperty> for NiFogProperty {
        fn as_ref(&self) -> &NiProperty {
            &self
        }
    }
    impl AsRef<NiProperty> for NiAlphaProperty {
        fn as_ref(&self) -> &NiProperty {
            &self
        }
    }
    impl AsRef<NiProperty> for NiDitherProperty {
        fn as_ref(&self) -> &NiProperty {
            &self
        }
    }
    impl AsRef<NiProperty> for NiProperty {
        fn as_ref(&self) -> &NiProperty {
            &self
        }
    }
    impl AsRef<NiProperty> for NiSpecularProperty {
        fn as_ref(&self) -> &NiProperty {
            &self
        }
    }
    impl AsRef<NiProperty> for NiShadeProperty {
        fn as_ref(&self) -> &NiProperty {
            &self
        }
    }
    impl AsRef<NiProperty> for NiTexturingProperty {
        fn as_ref(&self) -> &NiProperty {
            &self
        }
    }
    impl AsRef<NiProperty> for NiVertexColorProperty {
        fn as_ref(&self) -> &NiProperty {
            &self
        }
    }
    impl AsRef<NiProperty> for NiWireframeProperty {
        fn as_ref(&self) -> &NiProperty {
            &self
        }
    }
    impl AsRef<NiProperty> for NiZBufferProperty {
        fn as_ref(&self) -> &NiProperty {
            &self
        }
    }
    impl AsRef<NiProperty> for NiStencilProperty {
        fn as_ref(&self) -> &NiProperty {
            &self
        }
    }
    impl AsRef<NiProperty> for NiMaterialProperty {
        fn as_ref(&self) -> &NiProperty {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiSequenceStreamHelper {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiSequenceStreamHelper(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiSequenceStreamHelper {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiSequenceStreamHelper(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiSequenceStreamHelper> for NiSequenceStreamHelper {
        fn as_ref(&self) -> &NiSequenceStreamHelper {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiSkinData {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiSkinData(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiSkinData {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiSkinData(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiSkinData> for NiSkinData {
        fn as_ref(&self) -> &NiSkinData {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiFlipController {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiFlipController(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiFlipController {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiFlipController(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiFlipController> for NiFlipController {
        fn as_ref(&self) -> &NiFlipController {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiSkinInstance {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiSkinInstance(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiSkinInstance {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiSkinInstance(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiSkinInstance> for NiSkinInstance {
        fn as_ref(&self) -> &NiSkinInstance {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiSpecularProperty {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiSpecularProperty(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiSpecularProperty {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiSpecularProperty(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiSpecularProperty> for NiSpecularProperty {
        fn as_ref(&self) -> &NiSpecularProperty {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiShadeProperty {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiShadeProperty(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiShadeProperty {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiShadeProperty(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiShadeProperty> for NiShadeProperty {
        fn as_ref(&self) -> &NiShadeProperty {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiParticleSystemController {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiParticleSystemController(inner) => Ok(inner),
                NiType::NiBSPArrayController(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiParticleSystemController {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiParticleSystemController(inner) => Ok(inner),
                NiType::NiBSPArrayController(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiParticleSystemController> for NiParticleSystemController {
        fn as_ref(&self) -> &NiParticleSystemController {
            &self
        }
    }
    impl AsRef<NiParticleSystemController> for NiBSPArrayController {
        fn as_ref(&self) -> &NiParticleSystemController {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiSpotLight {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiSpotLight(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiSpotLight {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiSpotLight(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiSpotLight> for NiSpotLight {
        fn as_ref(&self) -> &NiSpotLight {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a BSMirroredNode {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::BSMirroredNode(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut BSMirroredNode {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::BSMirroredNode(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<BSMirroredNode> for BSMirroredNode {
        fn as_ref(&self) -> &BSMirroredNode {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiBSPArrayController {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiBSPArrayController(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiBSPArrayController {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiBSPArrayController(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiBSPArrayController> for NiBSPArrayController {
        fn as_ref(&self) -> &NiBSPArrayController {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiBillboardNode {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiBillboardNode(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiBillboardNode {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiBillboardNode(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiBillboardNode> for NiBillboardNode {
        fn as_ref(&self) -> &NiBillboardNode {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiBSAnimationManager {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiBSAnimationManager(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiBSAnimationManager {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiBSAnimationManager(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiBSAnimationManager> for NiBSAnimationManager {
        fn as_ref(&self) -> &NiBSAnimationManager {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiKeyframeData {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiKeyframeData(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiKeyframeData {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiKeyframeData(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiKeyframeData> for NiKeyframeData {
        fn as_ref(&self) -> &NiKeyframeData {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiLookAtController {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiLookAtController(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiLookAtController {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiLookAtController(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiLookAtController> for NiLookAtController {
        fn as_ref(&self) -> &NiLookAtController {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiParticleBomb {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiParticleBomb(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiParticleBomb {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiParticleBomb(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiParticleBomb> for NiParticleBomb {
        fn as_ref(&self) -> &NiParticleBomb {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiScreenPolygon {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiScreenPolygon(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiScreenPolygon {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiScreenPolygon(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiScreenPolygon> for NiScreenPolygon {
        fn as_ref(&self) -> &NiScreenPolygon {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiTextKeyExtraData {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiTextKeyExtraData(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiTextKeyExtraData {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiTextKeyExtraData(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiTextKeyExtraData> for NiTextKeyExtraData {
        fn as_ref(&self) -> &NiTextKeyExtraData {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiSkinPartition {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiSkinPartition(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiSkinPartition {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiSkinPartition(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiSkinPartition> for NiSkinPartition {
        fn as_ref(&self) -> &NiSkinPartition {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiRotatingParticlesData {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiRotatingParticlesData(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiRotatingParticlesData {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiRotatingParticlesData(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiRotatingParticlesData> for NiRotatingParticlesData {
        fn as_ref(&self) -> &NiRotatingParticlesData {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiTextureEffect {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiTextureEffect(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiTextureEffect {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiTextureEffect(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiTextureEffect> for NiTextureEffect {
        fn as_ref(&self) -> &NiTextureEffect {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiKeyframeController {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiKeyframeController(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiKeyframeController {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiKeyframeController(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiKeyframeController> for NiKeyframeController {
        fn as_ref(&self) -> &NiKeyframeController {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiAVObject {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiBSParticleNode(inner) => Ok(inner),
                NiType::NiLines(inner) => Ok(inner),
                NiType::NiAutoNormalParticles(inner) => Ok(inner),
                NiType::NiCollisionSwitch(inner) => Ok(inner),
                NiType::NiBSPNode(inner) => Ok(inner),
                NiType::NiBSAnimationNode(inner) => Ok(inner),
                NiType::AvoidNode(inner) => Ok(inner),
                NiType::NiSpotLight(inner) => Ok(inner),
                NiType::BSMirroredNode(inner) => Ok(inner),
                NiType::NiBillboardNode(inner) => Ok(inner),
                NiType::NiBSAnimationManager(inner) => Ok(inner),
                NiType::NiTextureEffect(inner) => Ok(inner),
                NiType::NiAVObject(inner) => Ok(inner),
                NiType::NiNode(inner) => Ok(inner),
                NiType::NiTriBasedGeom(inner) => Ok(inner),
                NiType::NiSwitchNode(inner) => Ok(inner),
                NiType::NiSortAdjustNode(inner) => Ok(inner),
                NiType::RootCollisionNode(inner) => Ok(inner),
                NiType::NiAmbientLight(inner) => Ok(inner),
                NiType::NiPointLight(inner) => Ok(inner),
                NiType::NiLODNode(inner) => Ok(inner),
                NiType::NiDirectionalLight(inner) => Ok(inner),
                NiType::NiRotatingParticles(inner) => Ok(inner),
                NiType::NiParticles(inner) => Ok(inner),
                NiType::NiFltAnimationNode(inner) => Ok(inner),
                NiType::NiTriStrips(inner) => Ok(inner),
                NiType::NiTriShape(inner) => Ok(inner),
                NiType::NiCamera(inner) => Ok(inner),
                NiType::NiLight(inner) => Ok(inner),
                NiType::NiDynamicEffect(inner) => Ok(inner),
                NiType::NiGeometry(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiAVObject {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiBSParticleNode(inner) => Ok(inner),
                NiType::NiLines(inner) => Ok(inner),
                NiType::NiAutoNormalParticles(inner) => Ok(inner),
                NiType::NiCollisionSwitch(inner) => Ok(inner),
                NiType::NiBSPNode(inner) => Ok(inner),
                NiType::NiBSAnimationNode(inner) => Ok(inner),
                NiType::AvoidNode(inner) => Ok(inner),
                NiType::NiSpotLight(inner) => Ok(inner),
                NiType::BSMirroredNode(inner) => Ok(inner),
                NiType::NiBillboardNode(inner) => Ok(inner),
                NiType::NiBSAnimationManager(inner) => Ok(inner),
                NiType::NiTextureEffect(inner) => Ok(inner),
                NiType::NiAVObject(inner) => Ok(inner),
                NiType::NiNode(inner) => Ok(inner),
                NiType::NiTriBasedGeom(inner) => Ok(inner),
                NiType::NiSwitchNode(inner) => Ok(inner),
                NiType::NiSortAdjustNode(inner) => Ok(inner),
                NiType::RootCollisionNode(inner) => Ok(inner),
                NiType::NiAmbientLight(inner) => Ok(inner),
                NiType::NiPointLight(inner) => Ok(inner),
                NiType::NiLODNode(inner) => Ok(inner),
                NiType::NiDirectionalLight(inner) => Ok(inner),
                NiType::NiRotatingParticles(inner) => Ok(inner),
                NiType::NiParticles(inner) => Ok(inner),
                NiType::NiFltAnimationNode(inner) => Ok(inner),
                NiType::NiTriStrips(inner) => Ok(inner),
                NiType::NiTriShape(inner) => Ok(inner),
                NiType::NiCamera(inner) => Ok(inner),
                NiType::NiLight(inner) => Ok(inner),
                NiType::NiDynamicEffect(inner) => Ok(inner),
                NiType::NiGeometry(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiAVObject> for NiBSParticleNode {
        fn as_ref(&self) -> &NiAVObject {
            &self
        }
    }
    impl AsRef<NiAVObject> for NiLines {
        fn as_ref(&self) -> &NiAVObject {
            &self
        }
    }
    impl AsRef<NiAVObject> for NiAutoNormalParticles {
        fn as_ref(&self) -> &NiAVObject {
            &self
        }
    }
    impl AsRef<NiAVObject> for NiCollisionSwitch {
        fn as_ref(&self) -> &NiAVObject {
            &self
        }
    }
    impl AsRef<NiAVObject> for NiBSPNode {
        fn as_ref(&self) -> &NiAVObject {
            &self
        }
    }
    impl AsRef<NiAVObject> for NiBSAnimationNode {
        fn as_ref(&self) -> &NiAVObject {
            &self
        }
    }
    impl AsRef<NiAVObject> for AvoidNode {
        fn as_ref(&self) -> &NiAVObject {
            &self
        }
    }
    impl AsRef<NiAVObject> for NiSpotLight {
        fn as_ref(&self) -> &NiAVObject {
            &self
        }
    }
    impl AsRef<NiAVObject> for BSMirroredNode {
        fn as_ref(&self) -> &NiAVObject {
            &self
        }
    }
    impl AsRef<NiAVObject> for NiBillboardNode {
        fn as_ref(&self) -> &NiAVObject {
            &self
        }
    }
    impl AsRef<NiAVObject> for NiBSAnimationManager {
        fn as_ref(&self) -> &NiAVObject {
            &self
        }
    }
    impl AsRef<NiAVObject> for NiTextureEffect {
        fn as_ref(&self) -> &NiAVObject {
            &self
        }
    }
    impl AsRef<NiAVObject> for NiAVObject {
        fn as_ref(&self) -> &NiAVObject {
            &self
        }
    }
    impl AsRef<NiAVObject> for NiNode {
        fn as_ref(&self) -> &NiAVObject {
            &self
        }
    }
    impl AsRef<NiAVObject> for NiTriBasedGeom {
        fn as_ref(&self) -> &NiAVObject {
            &self
        }
    }
    impl AsRef<NiAVObject> for NiSwitchNode {
        fn as_ref(&self) -> &NiAVObject {
            &self
        }
    }
    impl AsRef<NiAVObject> for NiSortAdjustNode {
        fn as_ref(&self) -> &NiAVObject {
            &self
        }
    }
    impl AsRef<NiAVObject> for RootCollisionNode {
        fn as_ref(&self) -> &NiAVObject {
            &self
        }
    }
    impl AsRef<NiAVObject> for NiAmbientLight {
        fn as_ref(&self) -> &NiAVObject {
            &self
        }
    }
    impl AsRef<NiAVObject> for NiPointLight {
        fn as_ref(&self) -> &NiAVObject {
            &self
        }
    }
    impl AsRef<NiAVObject> for NiLODNode {
        fn as_ref(&self) -> &NiAVObject {
            &self
        }
    }
    impl AsRef<NiAVObject> for NiDirectionalLight {
        fn as_ref(&self) -> &NiAVObject {
            &self
        }
    }
    impl AsRef<NiAVObject> for NiRotatingParticles {
        fn as_ref(&self) -> &NiAVObject {
            &self
        }
    }
    impl AsRef<NiAVObject> for NiParticles {
        fn as_ref(&self) -> &NiAVObject {
            &self
        }
    }
    impl AsRef<NiAVObject> for NiFltAnimationNode {
        fn as_ref(&self) -> &NiAVObject {
            &self
        }
    }
    impl AsRef<NiAVObject> for NiTriStrips {
        fn as_ref(&self) -> &NiAVObject {
            &self
        }
    }
    impl AsRef<NiAVObject> for NiTriShape {
        fn as_ref(&self) -> &NiAVObject {
            &self
        }
    }
    impl AsRef<NiAVObject> for NiCamera {
        fn as_ref(&self) -> &NiAVObject {
            &self
        }
    }
    impl AsRef<NiAVObject> for NiLight {
        fn as_ref(&self) -> &NiAVObject {
            &self
        }
    }
    impl AsRef<NiAVObject> for NiDynamicEffect {
        fn as_ref(&self) -> &NiAVObject {
            &self
        }
    }
    impl AsRef<NiAVObject> for NiGeometry {
        fn as_ref(&self) -> &NiAVObject {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiColorData {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiColorData(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiColorData {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiColorData(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiColorData> for NiColorData {
        fn as_ref(&self) -> &NiColorData {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiMorpherController {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiGeomMorpherController(inner) => Ok(inner),
                NiType::NiMorpherController(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiMorpherController {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiGeomMorpherController(inner) => Ok(inner),
                NiType::NiMorpherController(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiMorpherController> for NiGeomMorpherController {
        fn as_ref(&self) -> &NiMorpherController {
            &self
        }
    }
    impl AsRef<NiMorpherController> for NiMorpherController {
        fn as_ref(&self) -> &NiMorpherController {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiNode {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiBSParticleNode(inner) => Ok(inner),
                NiType::NiCollisionSwitch(inner) => Ok(inner),
                NiType::NiBSPNode(inner) => Ok(inner),
                NiType::NiBSAnimationNode(inner) => Ok(inner),
                NiType::AvoidNode(inner) => Ok(inner),
                NiType::BSMirroredNode(inner) => Ok(inner),
                NiType::NiBillboardNode(inner) => Ok(inner),
                NiType::NiBSAnimationManager(inner) => Ok(inner),
                NiType::NiNode(inner) => Ok(inner),
                NiType::NiSwitchNode(inner) => Ok(inner),
                NiType::NiSortAdjustNode(inner) => Ok(inner),
                NiType::RootCollisionNode(inner) => Ok(inner),
                NiType::NiLODNode(inner) => Ok(inner),
                NiType::NiFltAnimationNode(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiNode {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiBSParticleNode(inner) => Ok(inner),
                NiType::NiCollisionSwitch(inner) => Ok(inner),
                NiType::NiBSPNode(inner) => Ok(inner),
                NiType::NiBSAnimationNode(inner) => Ok(inner),
                NiType::AvoidNode(inner) => Ok(inner),
                NiType::BSMirroredNode(inner) => Ok(inner),
                NiType::NiBillboardNode(inner) => Ok(inner),
                NiType::NiBSAnimationManager(inner) => Ok(inner),
                NiType::NiNode(inner) => Ok(inner),
                NiType::NiSwitchNode(inner) => Ok(inner),
                NiType::NiSortAdjustNode(inner) => Ok(inner),
                NiType::RootCollisionNode(inner) => Ok(inner),
                NiType::NiLODNode(inner) => Ok(inner),
                NiType::NiFltAnimationNode(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiNode> for NiBSParticleNode {
        fn as_ref(&self) -> &NiNode {
            &self
        }
    }
    impl AsRef<NiNode> for NiCollisionSwitch {
        fn as_ref(&self) -> &NiNode {
            &self
        }
    }
    impl AsRef<NiNode> for NiBSPNode {
        fn as_ref(&self) -> &NiNode {
            &self
        }
    }
    impl AsRef<NiNode> for NiBSAnimationNode {
        fn as_ref(&self) -> &NiNode {
            &self
        }
    }
    impl AsRef<NiNode> for AvoidNode {
        fn as_ref(&self) -> &NiNode {
            &self
        }
    }
    impl AsRef<NiNode> for BSMirroredNode {
        fn as_ref(&self) -> &NiNode {
            &self
        }
    }
    impl AsRef<NiNode> for NiBillboardNode {
        fn as_ref(&self) -> &NiNode {
            &self
        }
    }
    impl AsRef<NiNode> for NiBSAnimationManager {
        fn as_ref(&self) -> &NiNode {
            &self
        }
    }
    impl AsRef<NiNode> for NiNode {
        fn as_ref(&self) -> &NiNode {
            &self
        }
    }
    impl AsRef<NiNode> for NiSwitchNode {
        fn as_ref(&self) -> &NiNode {
            &self
        }
    }
    impl AsRef<NiNode> for NiSortAdjustNode {
        fn as_ref(&self) -> &NiNode {
            &self
        }
    }
    impl AsRef<NiNode> for RootCollisionNode {
        fn as_ref(&self) -> &NiNode {
            &self
        }
    }
    impl AsRef<NiNode> for NiLODNode {
        fn as_ref(&self) -> &NiNode {
            &self
        }
    }
    impl AsRef<NiNode> for NiFltAnimationNode {
        fn as_ref(&self) -> &NiNode {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiLightColorController {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiLightColorController(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiLightColorController {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiLightColorController(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiLightColorController> for NiLightColorController {
        fn as_ref(&self) -> &NiLightColorController {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiGravity {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiGravity(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiGravity {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiGravity(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiGravity> for NiGravity {
        fn as_ref(&self) -> &NiGravity {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiParticleCollider {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiParticleCollider(inner) => Ok(inner),
                NiType::NiSphericalCollider(inner) => Ok(inner),
                NiType::NiPlanarCollider(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiParticleCollider {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiParticleCollider(inner) => Ok(inner),
                NiType::NiSphericalCollider(inner) => Ok(inner),
                NiType::NiPlanarCollider(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiParticleCollider> for NiParticleCollider {
        fn as_ref(&self) -> &NiParticleCollider {
            &self
        }
    }
    impl AsRef<NiParticleCollider> for NiSphericalCollider {
        fn as_ref(&self) -> &NiParticleCollider {
            &self
        }
    }
    impl AsRef<NiParticleCollider> for NiPlanarCollider {
        fn as_ref(&self) -> &NiParticleCollider {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiParticleColorModifier {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiParticleColorModifier(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiParticleColorModifier {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiParticleColorModifier(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiParticleColorModifier> for NiParticleColorModifier {
        fn as_ref(&self) -> &NiParticleColorModifier {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiTexturingProperty {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiTexturingProperty(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiTexturingProperty {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiTexturingProperty(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiTexturingProperty> for NiTexturingProperty {
        fn as_ref(&self) -> &NiTexturingProperty {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiTriBasedGeom {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiTriBasedGeom(inner) => Ok(inner),
                NiType::NiTriStrips(inner) => Ok(inner),
                NiType::NiTriShape(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiTriBasedGeom {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiTriBasedGeom(inner) => Ok(inner),
                NiType::NiTriStrips(inner) => Ok(inner),
                NiType::NiTriShape(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiTriBasedGeom> for NiTriBasedGeom {
        fn as_ref(&self) -> &NiTriBasedGeom {
            &self
        }
    }
    impl AsRef<NiTriBasedGeom> for NiTriStrips {
        fn as_ref(&self) -> &NiTriBasedGeom {
            &self
        }
    }
    impl AsRef<NiTriBasedGeom> for NiTriShape {
        fn as_ref(&self) -> &NiTriBasedGeom {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiAutoNormalParticlesData {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiAutoNormalParticlesData(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiAutoNormalParticlesData {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiAutoNormalParticlesData(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiAutoNormalParticlesData> for NiAutoNormalParticlesData {
        fn as_ref(&self) -> &NiAutoNormalParticlesData {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiSphericalCollider {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiSphericalCollider(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiSphericalCollider {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiSphericalCollider(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiSphericalCollider> for NiSphericalCollider {
        fn as_ref(&self) -> &NiSphericalCollider {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiTriShapeData {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiTriShapeData(inner) => Ok(inner),
                NiType::NiTriShapeDynamicData(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiTriShapeData {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiTriShapeData(inner) => Ok(inner),
                NiType::NiTriShapeDynamicData(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiTriShapeData> for NiTriShapeData {
        fn as_ref(&self) -> &NiTriShapeData {
            &self
        }
    }
    impl AsRef<NiTriShapeData> for NiTriShapeDynamicData {
        fn as_ref(&self) -> &NiTriShapeData {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiBltSource {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiBltSource(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiBltSource {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiBltSource(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiBltSource> for NiBltSource {
        fn as_ref(&self) -> &NiBltSource {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiVertexColorProperty {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiVertexColorProperty(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiVertexColorProperty {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiVertexColorProperty(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiVertexColorProperty> for NiVertexColorProperty {
        fn as_ref(&self) -> &NiVertexColorProperty {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiStringExtraData {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiStringExtraData(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiStringExtraData {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiStringExtraData(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiStringExtraData> for NiStringExtraData {
        fn as_ref(&self) -> &NiStringExtraData {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiVertWeightsExtraData {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiVertWeightsExtraData(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiVertWeightsExtraData {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiVertWeightsExtraData(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiVertWeightsExtraData> for NiVertWeightsExtraData {
        fn as_ref(&self) -> &NiVertWeightsExtraData {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiParticleRotation {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiParticleRotation(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiParticleRotation {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiParticleRotation(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiParticleRotation> for NiParticleRotation {
        fn as_ref(&self) -> &NiParticleRotation {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiVisData {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiVisData(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiVisData {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiVisData(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiVisData> for NiVisData {
        fn as_ref(&self) -> &NiVisData {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiSwitchNode {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiSwitchNode(inner) => Ok(inner),
                NiType::NiLODNode(inner) => Ok(inner),
                NiType::NiFltAnimationNode(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiSwitchNode {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiSwitchNode(inner) => Ok(inner),
                NiType::NiLODNode(inner) => Ok(inner),
                NiType::NiFltAnimationNode(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiSwitchNode> for NiSwitchNode {
        fn as_ref(&self) -> &NiSwitchNode {
            &self
        }
    }
    impl AsRef<NiSwitchNode> for NiLODNode {
        fn as_ref(&self) -> &NiSwitchNode {
            &self
        }
    }
    impl AsRef<NiSwitchNode> for NiFltAnimationNode {
        fn as_ref(&self) -> &NiSwitchNode {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiEmitterModifier {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiEmitterModifier(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiEmitterModifier {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiEmitterModifier(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiEmitterModifier> for NiEmitterModifier {
        fn as_ref(&self) -> &NiEmitterModifier {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiFloatData {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiFloatData(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiFloatData {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiFloatData(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiFloatData> for NiFloatData {
        fn as_ref(&self) -> &NiFloatData {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiSortAdjustNode {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiSortAdjustNode(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiSortAdjustNode {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiSortAdjustNode(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiSortAdjustNode> for NiSortAdjustNode {
        fn as_ref(&self) -> &NiSortAdjustNode {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiTriShapeDynamicData {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiTriShapeDynamicData(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiTriShapeDynamicData {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiTriShapeDynamicData(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiTriShapeDynamicData> for NiTriShapeDynamicData {
        fn as_ref(&self) -> &NiTriShapeDynamicData {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiWireframeProperty {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiWireframeProperty(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiWireframeProperty {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiWireframeProperty(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiWireframeProperty> for NiWireframeProperty {
        fn as_ref(&self) -> &NiWireframeProperty {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiRenderedCubeMap {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiRenderedCubeMap(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiRenderedCubeMap {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiRenderedCubeMap(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiRenderedCubeMap> for NiRenderedCubeMap {
        fn as_ref(&self) -> &NiRenderedCubeMap {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiZBufferProperty {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiZBufferProperty(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiZBufferProperty {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiZBufferProperty(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiZBufferProperty> for NiZBufferProperty {
        fn as_ref(&self) -> &NiZBufferProperty {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a RootCollisionNode {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::RootCollisionNode(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut RootCollisionNode {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::RootCollisionNode(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<RootCollisionNode> for RootCollisionNode {
        fn as_ref(&self) -> &RootCollisionNode {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiTexture {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiRenderedTexture(inner) => Ok(inner),
                NiType::NiRenderedCubeMap(inner) => Ok(inner),
                NiType::NiTexture(inner) => Ok(inner),
                NiType::NiSourceTexture(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiTexture {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiRenderedTexture(inner) => Ok(inner),
                NiType::NiRenderedCubeMap(inner) => Ok(inner),
                NiType::NiTexture(inner) => Ok(inner),
                NiType::NiSourceTexture(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiTexture> for NiRenderedTexture {
        fn as_ref(&self) -> &NiTexture {
            &self
        }
    }
    impl AsRef<NiTexture> for NiRenderedCubeMap {
        fn as_ref(&self) -> &NiTexture {
            &self
        }
    }
    impl AsRef<NiTexture> for NiTexture {
        fn as_ref(&self) -> &NiTexture {
            &self
        }
    }
    impl AsRef<NiTexture> for NiSourceTexture {
        fn as_ref(&self) -> &NiTexture {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiPosData {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiPosData(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiPosData {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiPosData(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiPosData> for NiPosData {
        fn as_ref(&self) -> &NiPosData {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiPixelData {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiPixelData(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiPixelData {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiPixelData(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiPixelData> for NiPixelData {
        fn as_ref(&self) -> &NiPixelData {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiUVController {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiUVController(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiUVController {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiUVController(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiUVController> for NiUVController {
        fn as_ref(&self) -> &NiUVController {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiStencilProperty {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiStencilProperty(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiStencilProperty {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiStencilProperty(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiStencilProperty> for NiStencilProperty {
        fn as_ref(&self) -> &NiStencilProperty {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a TES3ObjectExtraData {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::TES3ObjectExtraData(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut TES3ObjectExtraData {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::TES3ObjectExtraData(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<TES3ObjectExtraData> for TES3ObjectExtraData {
        fn as_ref(&self) -> &TES3ObjectExtraData {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiTriStripsData {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiTriStripsData(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiTriStripsData {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiTriStripsData(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiTriStripsData> for NiTriStripsData {
        fn as_ref(&self) -> &NiTriStripsData {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiAmbientLight {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiAmbientLight(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiAmbientLight {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiAmbientLight(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiAmbientLight> for NiAmbientLight {
        fn as_ref(&self) -> &NiAmbientLight {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiMorphData {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiMorphData(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiMorphData {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiMorphData(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiMorphData> for NiMorphData {
        fn as_ref(&self) -> &NiMorphData {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiUVData {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiUVData(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiUVData {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiUVData(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiUVData> for NiUVData {
        fn as_ref(&self) -> &NiUVData {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiPointLight {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiSpotLight(inner) => Ok(inner),
                NiType::NiPointLight(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiPointLight {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiSpotLight(inner) => Ok(inner),
                NiType::NiPointLight(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiPointLight> for NiSpotLight {
        fn as_ref(&self) -> &NiPointLight {
            &self
        }
    }
    impl AsRef<NiPointLight> for NiPointLight {
        fn as_ref(&self) -> &NiPointLight {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiParticleGrowFade {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiParticleGrowFade(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiParticleGrowFade {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiParticleGrowFade(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiParticleGrowFade> for NiParticleGrowFade {
        fn as_ref(&self) -> &NiParticleGrowFade {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiLODNode {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiLODNode(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiLODNode {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiLODNode(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiLODNode> for NiLODNode {
        fn as_ref(&self) -> &NiLODNode {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiVisController {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiVisController(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiVisController {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiVisController(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiVisController> for NiVisController {
        fn as_ref(&self) -> &NiVisController {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiMaterialColorController {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiMaterialColorController(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiMaterialColorController {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiMaterialColorController(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiMaterialColorController> for NiMaterialColorController {
        fn as_ref(&self) -> &NiMaterialColorController {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiTimeController {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiGeomMorpherController(inner) => Ok(inner),
                NiType::NiPathController(inner) => Ok(inner),
                NiType::NiFlipController(inner) => Ok(inner),
                NiType::NiParticleSystemController(inner) => Ok(inner),
                NiType::NiBSPArrayController(inner) => Ok(inner),
                NiType::NiLookAtController(inner) => Ok(inner),
                NiType::NiKeyframeController(inner) => Ok(inner),
                NiType::NiLightColorController(inner) => Ok(inner),
                NiType::NiMorpherController(inner) => Ok(inner),
                NiType::NiUVController(inner) => Ok(inner),
                NiType::NiVisController(inner) => Ok(inner),
                NiType::NiMaterialColorController(inner) => Ok(inner),
                NiType::NiTimeController(inner) => Ok(inner),
                NiType::NiKeyframeManager(inner) => Ok(inner),
                NiType::NiAlphaController(inner) => Ok(inner),
                NiType::NiRollController(inner) => Ok(inner),
                NiType::NiFloatController(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiTimeController {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiGeomMorpherController(inner) => Ok(inner),
                NiType::NiPathController(inner) => Ok(inner),
                NiType::NiFlipController(inner) => Ok(inner),
                NiType::NiParticleSystemController(inner) => Ok(inner),
                NiType::NiBSPArrayController(inner) => Ok(inner),
                NiType::NiLookAtController(inner) => Ok(inner),
                NiType::NiKeyframeController(inner) => Ok(inner),
                NiType::NiLightColorController(inner) => Ok(inner),
                NiType::NiMorpherController(inner) => Ok(inner),
                NiType::NiUVController(inner) => Ok(inner),
                NiType::NiVisController(inner) => Ok(inner),
                NiType::NiMaterialColorController(inner) => Ok(inner),
                NiType::NiTimeController(inner) => Ok(inner),
                NiType::NiKeyframeManager(inner) => Ok(inner),
                NiType::NiAlphaController(inner) => Ok(inner),
                NiType::NiRollController(inner) => Ok(inner),
                NiType::NiFloatController(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiTimeController> for NiGeomMorpherController {
        fn as_ref(&self) -> &NiTimeController {
            &self
        }
    }
    impl AsRef<NiTimeController> for NiPathController {
        fn as_ref(&self) -> &NiTimeController {
            &self
        }
    }
    impl AsRef<NiTimeController> for NiFlipController {
        fn as_ref(&self) -> &NiTimeController {
            &self
        }
    }
    impl AsRef<NiTimeController> for NiParticleSystemController {
        fn as_ref(&self) -> &NiTimeController {
            &self
        }
    }
    impl AsRef<NiTimeController> for NiBSPArrayController {
        fn as_ref(&self) -> &NiTimeController {
            &self
        }
    }
    impl AsRef<NiTimeController> for NiLookAtController {
        fn as_ref(&self) -> &NiTimeController {
            &self
        }
    }
    impl AsRef<NiTimeController> for NiKeyframeController {
        fn as_ref(&self) -> &NiTimeController {
            &self
        }
    }
    impl AsRef<NiTimeController> for NiLightColorController {
        fn as_ref(&self) -> &NiTimeController {
            &self
        }
    }
    impl AsRef<NiTimeController> for NiMorpherController {
        fn as_ref(&self) -> &NiTimeController {
            &self
        }
    }
    impl AsRef<NiTimeController> for NiUVController {
        fn as_ref(&self) -> &NiTimeController {
            &self
        }
    }
    impl AsRef<NiTimeController> for NiVisController {
        fn as_ref(&self) -> &NiTimeController {
            &self
        }
    }
    impl AsRef<NiTimeController> for NiMaterialColorController {
        fn as_ref(&self) -> &NiTimeController {
            &self
        }
    }
    impl AsRef<NiTimeController> for NiTimeController {
        fn as_ref(&self) -> &NiTimeController {
            &self
        }
    }
    impl AsRef<NiTimeController> for NiKeyframeManager {
        fn as_ref(&self) -> &NiTimeController {
            &self
        }
    }
    impl AsRef<NiTimeController> for NiAlphaController {
        fn as_ref(&self) -> &NiTimeController {
            &self
        }
    }
    impl AsRef<NiTimeController> for NiRollController {
        fn as_ref(&self) -> &NiTimeController {
            &self
        }
    }
    impl AsRef<NiTimeController> for NiFloatController {
        fn as_ref(&self) -> &NiTimeController {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiPlanarCollider {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiPlanarCollider(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiPlanarCollider {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiPlanarCollider(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiPlanarCollider> for NiPlanarCollider {
        fn as_ref(&self) -> &NiPlanarCollider {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiDirectionalLight {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiDirectionalLight(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiDirectionalLight {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiDirectionalLight(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiDirectionalLight> for NiDirectionalLight {
        fn as_ref(&self) -> &NiDirectionalLight {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiRotatingParticles {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiRotatingParticles(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiRotatingParticles {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiRotatingParticles(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiRotatingParticles> for NiRotatingParticles {
        fn as_ref(&self) -> &NiRotatingParticles {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiParticles {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiAutoNormalParticles(inner) => Ok(inner),
                NiType::NiRotatingParticles(inner) => Ok(inner),
                NiType::NiParticles(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiParticles {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiAutoNormalParticles(inner) => Ok(inner),
                NiType::NiRotatingParticles(inner) => Ok(inner),
                NiType::NiParticles(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiParticles> for NiAutoNormalParticles {
        fn as_ref(&self) -> &NiParticles {
            &self
        }
    }
    impl AsRef<NiParticles> for NiRotatingParticles {
        fn as_ref(&self) -> &NiParticles {
            &self
        }
    }
    impl AsRef<NiParticles> for NiParticles {
        fn as_ref(&self) -> &NiParticles {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiParticleModifier {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiParticleBomb(inner) => Ok(inner),
                NiType::NiGravity(inner) => Ok(inner),
                NiType::NiParticleCollider(inner) => Ok(inner),
                NiType::NiParticleColorModifier(inner) => Ok(inner),
                NiType::NiSphericalCollider(inner) => Ok(inner),
                NiType::NiParticleRotation(inner) => Ok(inner),
                NiType::NiParticleGrowFade(inner) => Ok(inner),
                NiType::NiPlanarCollider(inner) => Ok(inner),
                NiType::NiParticleModifier(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiParticleModifier {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiParticleBomb(inner) => Ok(inner),
                NiType::NiGravity(inner) => Ok(inner),
                NiType::NiParticleCollider(inner) => Ok(inner),
                NiType::NiParticleColorModifier(inner) => Ok(inner),
                NiType::NiSphericalCollider(inner) => Ok(inner),
                NiType::NiParticleRotation(inner) => Ok(inner),
                NiType::NiParticleGrowFade(inner) => Ok(inner),
                NiType::NiPlanarCollider(inner) => Ok(inner),
                NiType::NiParticleModifier(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiParticleModifier> for NiParticleBomb {
        fn as_ref(&self) -> &NiParticleModifier {
            &self
        }
    }
    impl AsRef<NiParticleModifier> for NiGravity {
        fn as_ref(&self) -> &NiParticleModifier {
            &self
        }
    }
    impl AsRef<NiParticleModifier> for NiParticleCollider {
        fn as_ref(&self) -> &NiParticleModifier {
            &self
        }
    }
    impl AsRef<NiParticleModifier> for NiParticleColorModifier {
        fn as_ref(&self) -> &NiParticleModifier {
            &self
        }
    }
    impl AsRef<NiParticleModifier> for NiSphericalCollider {
        fn as_ref(&self) -> &NiParticleModifier {
            &self
        }
    }
    impl AsRef<NiParticleModifier> for NiParticleRotation {
        fn as_ref(&self) -> &NiParticleModifier {
            &self
        }
    }
    impl AsRef<NiParticleModifier> for NiParticleGrowFade {
        fn as_ref(&self) -> &NiParticleModifier {
            &self
        }
    }
    impl AsRef<NiParticleModifier> for NiPlanarCollider {
        fn as_ref(&self) -> &NiParticleModifier {
            &self
        }
    }
    impl AsRef<NiParticleModifier> for NiParticleModifier {
        fn as_ref(&self) -> &NiParticleModifier {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiFltAnimationNode {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiFltAnimationNode(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiFltAnimationNode {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiFltAnimationNode(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiFltAnimationNode> for NiFltAnimationNode {
        fn as_ref(&self) -> &NiFltAnimationNode {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiAlphaAccumulator {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiAlphaAccumulator(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiAlphaAccumulator {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiAlphaAccumulator(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiAlphaAccumulator> for NiAlphaAccumulator {
        fn as_ref(&self) -> &NiAlphaAccumulator {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiSourceTexture {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiSourceTexture(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiSourceTexture {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiSourceTexture(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiSourceTexture> for NiSourceTexture {
        fn as_ref(&self) -> &NiSourceTexture {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiTriStrips {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiTriStrips(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiTriStrips {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiTriStrips(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiTriStrips> for NiTriStrips {
        fn as_ref(&self) -> &NiTriStrips {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiTriShape {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiTriShape(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiTriShape {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiTriShape(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiTriShape> for NiTriShape {
        fn as_ref(&self) -> &NiTriShape {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiKeyframeManager {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiKeyframeManager(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiKeyframeManager {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiKeyframeManager(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiKeyframeManager> for NiKeyframeManager {
        fn as_ref(&self) -> &NiKeyframeManager {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiAlphaController {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiAlphaController(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiAlphaController {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiAlphaController(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiAlphaController> for NiAlphaController {
        fn as_ref(&self) -> &NiAlphaController {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiCamera {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiCamera(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiCamera {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiCamera(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiCamera> for NiCamera {
        fn as_ref(&self) -> &NiCamera {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a BrickNiExtraData {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::BrickNiExtraData(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut BrickNiExtraData {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::BrickNiExtraData(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<BrickNiExtraData> for BrickNiExtraData {
        fn as_ref(&self) -> &BrickNiExtraData {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiRollController {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiRollController(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiRollController {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiRollController(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiRollController> for NiRollController {
        fn as_ref(&self) -> &NiRollController {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiLight {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiSpotLight(inner) => Ok(inner),
                NiType::NiAmbientLight(inner) => Ok(inner),
                NiType::NiPointLight(inner) => Ok(inner),
                NiType::NiDirectionalLight(inner) => Ok(inner),
                NiType::NiLight(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiLight {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiSpotLight(inner) => Ok(inner),
                NiType::NiAmbientLight(inner) => Ok(inner),
                NiType::NiPointLight(inner) => Ok(inner),
                NiType::NiDirectionalLight(inner) => Ok(inner),
                NiType::NiLight(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiLight> for NiSpotLight {
        fn as_ref(&self) -> &NiLight {
            &self
        }
    }
    impl AsRef<NiLight> for NiAmbientLight {
        fn as_ref(&self) -> &NiLight {
            &self
        }
    }
    impl AsRef<NiLight> for NiPointLight {
        fn as_ref(&self) -> &NiLight {
            &self
        }
    }
    impl AsRef<NiLight> for NiDirectionalLight {
        fn as_ref(&self) -> &NiLight {
            &self
        }
    }
    impl AsRef<NiLight> for NiLight {
        fn as_ref(&self) -> &NiLight {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiDynamicEffect {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiSpotLight(inner) => Ok(inner),
                NiType::NiTextureEffect(inner) => Ok(inner),
                NiType::NiAmbientLight(inner) => Ok(inner),
                NiType::NiPointLight(inner) => Ok(inner),
                NiType::NiDirectionalLight(inner) => Ok(inner),
                NiType::NiLight(inner) => Ok(inner),
                NiType::NiDynamicEffect(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiDynamicEffect {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiSpotLight(inner) => Ok(inner),
                NiType::NiTextureEffect(inner) => Ok(inner),
                NiType::NiAmbientLight(inner) => Ok(inner),
                NiType::NiPointLight(inner) => Ok(inner),
                NiType::NiDirectionalLight(inner) => Ok(inner),
                NiType::NiLight(inner) => Ok(inner),
                NiType::NiDynamicEffect(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiDynamicEffect> for NiSpotLight {
        fn as_ref(&self) -> &NiDynamicEffect {
            &self
        }
    }
    impl AsRef<NiDynamicEffect> for NiTextureEffect {
        fn as_ref(&self) -> &NiDynamicEffect {
            &self
        }
    }
    impl AsRef<NiDynamicEffect> for NiAmbientLight {
        fn as_ref(&self) -> &NiDynamicEffect {
            &self
        }
    }
    impl AsRef<NiDynamicEffect> for NiPointLight {
        fn as_ref(&self) -> &NiDynamicEffect {
            &self
        }
    }
    impl AsRef<NiDynamicEffect> for NiDirectionalLight {
        fn as_ref(&self) -> &NiDynamicEffect {
            &self
        }
    }
    impl AsRef<NiDynamicEffect> for NiLight {
        fn as_ref(&self) -> &NiDynamicEffect {
            &self
        }
    }
    impl AsRef<NiDynamicEffect> for NiDynamicEffect {
        fn as_ref(&self) -> &NiDynamicEffect {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiGeometry {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiLines(inner) => Ok(inner),
                NiType::NiAutoNormalParticles(inner) => Ok(inner),
                NiType::NiTriBasedGeom(inner) => Ok(inner),
                NiType::NiRotatingParticles(inner) => Ok(inner),
                NiType::NiParticles(inner) => Ok(inner),
                NiType::NiTriStrips(inner) => Ok(inner),
                NiType::NiTriShape(inner) => Ok(inner),
                NiType::NiGeometry(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiGeometry {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiLines(inner) => Ok(inner),
                NiType::NiAutoNormalParticles(inner) => Ok(inner),
                NiType::NiTriBasedGeom(inner) => Ok(inner),
                NiType::NiRotatingParticles(inner) => Ok(inner),
                NiType::NiParticles(inner) => Ok(inner),
                NiType::NiTriStrips(inner) => Ok(inner),
                NiType::NiTriShape(inner) => Ok(inner),
                NiType::NiGeometry(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiGeometry> for NiLines {
        fn as_ref(&self) -> &NiGeometry {
            &self
        }
    }
    impl AsRef<NiGeometry> for NiAutoNormalParticles {
        fn as_ref(&self) -> &NiGeometry {
            &self
        }
    }
    impl AsRef<NiGeometry> for NiTriBasedGeom {
        fn as_ref(&self) -> &NiGeometry {
            &self
        }
    }
    impl AsRef<NiGeometry> for NiRotatingParticles {
        fn as_ref(&self) -> &NiGeometry {
            &self
        }
    }
    impl AsRef<NiGeometry> for NiParticles {
        fn as_ref(&self) -> &NiGeometry {
            &self
        }
    }
    impl AsRef<NiGeometry> for NiTriStrips {
        fn as_ref(&self) -> &NiGeometry {
            &self
        }
    }
    impl AsRef<NiGeometry> for NiTriShape {
        fn as_ref(&self) -> &NiGeometry {
            &self
        }
    }
    impl AsRef<NiGeometry> for NiGeometry {
        fn as_ref(&self) -> &NiGeometry {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiClusterAccumulator {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiAlphaAccumulator(inner) => Ok(inner),
                NiType::NiClusterAccumulator(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiClusterAccumulator {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiAlphaAccumulator(inner) => Ok(inner),
                NiType::NiClusterAccumulator(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiClusterAccumulator> for NiAlphaAccumulator {
        fn as_ref(&self) -> &NiClusterAccumulator {
            &self
        }
    }
    impl AsRef<NiClusterAccumulator> for NiClusterAccumulator {
        fn as_ref(&self) -> &NiClusterAccumulator {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiFloatController {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiAlphaController(inner) => Ok(inner),
                NiType::NiRollController(inner) => Ok(inner),
                NiType::NiFloatController(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiFloatController {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiAlphaController(inner) => Ok(inner),
                NiType::NiRollController(inner) => Ok(inner),
                NiType::NiFloatController(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiFloatController> for NiAlphaController {
        fn as_ref(&self) -> &NiFloatController {
            &self
        }
    }
    impl AsRef<NiFloatController> for NiRollController {
        fn as_ref(&self) -> &NiFloatController {
            &self
        }
    }
    impl AsRef<NiFloatController> for NiFloatController {
        fn as_ref(&self) -> &NiFloatController {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiDX8Renderer {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiDX8Renderer(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiDX8Renderer {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiDX8Renderer(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiDX8Renderer> for NiDX8Renderer {
        fn as_ref(&self) -> &NiDX8Renderer {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiMaterialProperty {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiMaterialProperty(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiMaterialProperty {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiMaterialProperty(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiMaterialProperty> for NiMaterialProperty {
        fn as_ref(&self) -> &NiMaterialProperty {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiObject {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiBSParticleNode(inner) => Ok(inner),
                NiType::NiLinesData(inner) => Ok(inner),
                NiType::NiFogProperty(inner) => Ok(inner),
                NiType::NiLines(inner) => Ok(inner),
                NiType::NiRenderedTexture(inner) => Ok(inner),
                NiType::NiTriBasedGeomData(inner) => Ok(inner),
                NiType::NiAutoNormalParticles(inner) => Ok(inner),
                NiType::NiExtraData(inner) => Ok(inner),
                NiType::NiAlphaProperty(inner) => Ok(inner),
                NiType::NiAccumulator(inner) => Ok(inner),
                NiType::NiCollisionSwitch(inner) => Ok(inner),
                NiType::NiObjectNET(inner) => Ok(inner),
                NiType::NiBSPNode(inner) => Ok(inner),
                NiType::NiBSAnimationNode(inner) => Ok(inner),
                NiType::NiPalette(inner) => Ok(inner),
                NiType::NiGeomMorpherController(inner) => Ok(inner),
                NiType::NiPathController(inner) => Ok(inner),
                NiType::AvoidNode(inner) => Ok(inner),
                NiType::NiRenderer(inner) => Ok(inner),
                NiType::NiDitherProperty(inner) => Ok(inner),
                NiType::NiParticlesData(inner) => Ok(inner),
                NiType::NiProperty(inner) => Ok(inner),
                NiType::NiSequenceStreamHelper(inner) => Ok(inner),
                NiType::NiSkinData(inner) => Ok(inner),
                NiType::NiFlipController(inner) => Ok(inner),
                NiType::NiSkinInstance(inner) => Ok(inner),
                NiType::NiSpecularProperty(inner) => Ok(inner),
                NiType::NiShadeProperty(inner) => Ok(inner),
                NiType::NiParticleSystemController(inner) => Ok(inner),
                NiType::NiSpotLight(inner) => Ok(inner),
                NiType::BSMirroredNode(inner) => Ok(inner),
                NiType::NiBSPArrayController(inner) => Ok(inner),
                NiType::NiBillboardNode(inner) => Ok(inner),
                NiType::NiBSAnimationManager(inner) => Ok(inner),
                NiType::NiKeyframeData(inner) => Ok(inner),
                NiType::NiLookAtController(inner) => Ok(inner),
                NiType::NiParticleBomb(inner) => Ok(inner),
                NiType::NiScreenPolygon(inner) => Ok(inner),
                NiType::NiTextKeyExtraData(inner) => Ok(inner),
                NiType::NiSkinPartition(inner) => Ok(inner),
                NiType::NiRotatingParticlesData(inner) => Ok(inner),
                NiType::NiTextureEffect(inner) => Ok(inner),
                NiType::NiKeyframeController(inner) => Ok(inner),
                NiType::NiAVObject(inner) => Ok(inner),
                NiType::NiColorData(inner) => Ok(inner),
                NiType::NiLightColorController(inner) => Ok(inner),
                NiType::NiMorpherController(inner) => Ok(inner),
                NiType::NiGravity(inner) => Ok(inner),
                NiType::NiNode(inner) => Ok(inner),
                NiType::NiParticleCollider(inner) => Ok(inner),
                NiType::NiParticleColorModifier(inner) => Ok(inner),
                NiType::NiTexturingProperty(inner) => Ok(inner),
                NiType::NiTriBasedGeom(inner) => Ok(inner),
                NiType::NiAutoNormalParticlesData(inner) => Ok(inner),
                NiType::NiSphericalCollider(inner) => Ok(inner),
                NiType::NiTriShapeData(inner) => Ok(inner),
                NiType::NiBltSource(inner) => Ok(inner),
                NiType::NiVertexColorProperty(inner) => Ok(inner),
                NiType::NiStringExtraData(inner) => Ok(inner),
                NiType::NiVertWeightsExtraData(inner) => Ok(inner),
                NiType::NiParticleRotation(inner) => Ok(inner),
                NiType::NiVisData(inner) => Ok(inner),
                NiType::NiSwitchNode(inner) => Ok(inner),
                NiType::NiEmitterModifier(inner) => Ok(inner),
                NiType::NiFloatData(inner) => Ok(inner),
                NiType::NiSortAdjustNode(inner) => Ok(inner),
                NiType::NiTriShapeDynamicData(inner) => Ok(inner),
                NiType::NiWireframeProperty(inner) => Ok(inner),
                NiType::NiRenderedCubeMap(inner) => Ok(inner),
                NiType::NiZBufferProperty(inner) => Ok(inner),
                NiType::RootCollisionNode(inner) => Ok(inner),
                NiType::NiTexture(inner) => Ok(inner),
                NiType::NiPosData(inner) => Ok(inner),
                NiType::NiPixelData(inner) => Ok(inner),
                NiType::NiUVController(inner) => Ok(inner),
                NiType::NiStencilProperty(inner) => Ok(inner),
                NiType::TES3ObjectExtraData(inner) => Ok(inner),
                NiType::NiTriStripsData(inner) => Ok(inner),
                NiType::NiAmbientLight(inner) => Ok(inner),
                NiType::NiMorphData(inner) => Ok(inner),
                NiType::NiUVData(inner) => Ok(inner),
                NiType::NiPointLight(inner) => Ok(inner),
                NiType::NiParticleGrowFade(inner) => Ok(inner),
                NiType::NiLODNode(inner) => Ok(inner),
                NiType::NiVisController(inner) => Ok(inner),
                NiType::NiMaterialColorController(inner) => Ok(inner),
                NiType::NiPlanarCollider(inner) => Ok(inner),
                NiType::NiTimeController(inner) => Ok(inner),
                NiType::NiDirectionalLight(inner) => Ok(inner),
                NiType::NiRotatingParticles(inner) => Ok(inner),
                NiType::NiParticles(inner) => Ok(inner),
                NiType::NiParticleModifier(inner) => Ok(inner),
                NiType::NiFltAnimationNode(inner) => Ok(inner),
                NiType::NiAlphaAccumulator(inner) => Ok(inner),
                NiType::NiSourceTexture(inner) => Ok(inner),
                NiType::NiTriStrips(inner) => Ok(inner),
                NiType::NiTriShape(inner) => Ok(inner),
                NiType::NiKeyframeManager(inner) => Ok(inner),
                NiType::NiAlphaController(inner) => Ok(inner),
                NiType::NiCamera(inner) => Ok(inner),
                NiType::BrickNiExtraData(inner) => Ok(inner),
                NiType::NiRollController(inner) => Ok(inner),
                NiType::NiLight(inner) => Ok(inner),
                NiType::NiDynamicEffect(inner) => Ok(inner),
                NiType::NiFloatController(inner) => Ok(inner),
                NiType::NiClusterAccumulator(inner) => Ok(inner),
                NiType::NiDX8Renderer(inner) => Ok(inner),
                NiType::NiGeometry(inner) => Ok(inner),
                NiType::NiMaterialProperty(inner) => Ok(inner),
                NiType::NiObject(inner) => Ok(inner),
                NiType::NiGeometryData(inner) => Ok(inner),
                NiType::NiRotData(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiObject {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiBSParticleNode(inner) => Ok(inner),
                NiType::NiLinesData(inner) => Ok(inner),
                NiType::NiFogProperty(inner) => Ok(inner),
                NiType::NiLines(inner) => Ok(inner),
                NiType::NiRenderedTexture(inner) => Ok(inner),
                NiType::NiTriBasedGeomData(inner) => Ok(inner),
                NiType::NiAutoNormalParticles(inner) => Ok(inner),
                NiType::NiExtraData(inner) => Ok(inner),
                NiType::NiAlphaProperty(inner) => Ok(inner),
                NiType::NiAccumulator(inner) => Ok(inner),
                NiType::NiCollisionSwitch(inner) => Ok(inner),
                NiType::NiObjectNET(inner) => Ok(inner),
                NiType::NiBSPNode(inner) => Ok(inner),
                NiType::NiBSAnimationNode(inner) => Ok(inner),
                NiType::NiPalette(inner) => Ok(inner),
                NiType::NiGeomMorpherController(inner) => Ok(inner),
                NiType::NiPathController(inner) => Ok(inner),
                NiType::AvoidNode(inner) => Ok(inner),
                NiType::NiRenderer(inner) => Ok(inner),
                NiType::NiDitherProperty(inner) => Ok(inner),
                NiType::NiParticlesData(inner) => Ok(inner),
                NiType::NiProperty(inner) => Ok(inner),
                NiType::NiSequenceStreamHelper(inner) => Ok(inner),
                NiType::NiSkinData(inner) => Ok(inner),
                NiType::NiFlipController(inner) => Ok(inner),
                NiType::NiSkinInstance(inner) => Ok(inner),
                NiType::NiSpecularProperty(inner) => Ok(inner),
                NiType::NiShadeProperty(inner) => Ok(inner),
                NiType::NiParticleSystemController(inner) => Ok(inner),
                NiType::NiSpotLight(inner) => Ok(inner),
                NiType::BSMirroredNode(inner) => Ok(inner),
                NiType::NiBSPArrayController(inner) => Ok(inner),
                NiType::NiBillboardNode(inner) => Ok(inner),
                NiType::NiBSAnimationManager(inner) => Ok(inner),
                NiType::NiKeyframeData(inner) => Ok(inner),
                NiType::NiLookAtController(inner) => Ok(inner),
                NiType::NiParticleBomb(inner) => Ok(inner),
                NiType::NiScreenPolygon(inner) => Ok(inner),
                NiType::NiTextKeyExtraData(inner) => Ok(inner),
                NiType::NiSkinPartition(inner) => Ok(inner),
                NiType::NiRotatingParticlesData(inner) => Ok(inner),
                NiType::NiTextureEffect(inner) => Ok(inner),
                NiType::NiKeyframeController(inner) => Ok(inner),
                NiType::NiAVObject(inner) => Ok(inner),
                NiType::NiColorData(inner) => Ok(inner),
                NiType::NiLightColorController(inner) => Ok(inner),
                NiType::NiMorpherController(inner) => Ok(inner),
                NiType::NiGravity(inner) => Ok(inner),
                NiType::NiNode(inner) => Ok(inner),
                NiType::NiParticleCollider(inner) => Ok(inner),
                NiType::NiParticleColorModifier(inner) => Ok(inner),
                NiType::NiTexturingProperty(inner) => Ok(inner),
                NiType::NiTriBasedGeom(inner) => Ok(inner),
                NiType::NiAutoNormalParticlesData(inner) => Ok(inner),
                NiType::NiSphericalCollider(inner) => Ok(inner),
                NiType::NiTriShapeData(inner) => Ok(inner),
                NiType::NiBltSource(inner) => Ok(inner),
                NiType::NiVertexColorProperty(inner) => Ok(inner),
                NiType::NiStringExtraData(inner) => Ok(inner),
                NiType::NiVertWeightsExtraData(inner) => Ok(inner),
                NiType::NiParticleRotation(inner) => Ok(inner),
                NiType::NiVisData(inner) => Ok(inner),
                NiType::NiSwitchNode(inner) => Ok(inner),
                NiType::NiEmitterModifier(inner) => Ok(inner),
                NiType::NiFloatData(inner) => Ok(inner),
                NiType::NiSortAdjustNode(inner) => Ok(inner),
                NiType::NiTriShapeDynamicData(inner) => Ok(inner),
                NiType::NiWireframeProperty(inner) => Ok(inner),
                NiType::NiRenderedCubeMap(inner) => Ok(inner),
                NiType::NiZBufferProperty(inner) => Ok(inner),
                NiType::RootCollisionNode(inner) => Ok(inner),
                NiType::NiTexture(inner) => Ok(inner),
                NiType::NiPosData(inner) => Ok(inner),
                NiType::NiPixelData(inner) => Ok(inner),
                NiType::NiUVController(inner) => Ok(inner),
                NiType::NiStencilProperty(inner) => Ok(inner),
                NiType::TES3ObjectExtraData(inner) => Ok(inner),
                NiType::NiTriStripsData(inner) => Ok(inner),
                NiType::NiAmbientLight(inner) => Ok(inner),
                NiType::NiMorphData(inner) => Ok(inner),
                NiType::NiUVData(inner) => Ok(inner),
                NiType::NiPointLight(inner) => Ok(inner),
                NiType::NiParticleGrowFade(inner) => Ok(inner),
                NiType::NiLODNode(inner) => Ok(inner),
                NiType::NiVisController(inner) => Ok(inner),
                NiType::NiMaterialColorController(inner) => Ok(inner),
                NiType::NiPlanarCollider(inner) => Ok(inner),
                NiType::NiTimeController(inner) => Ok(inner),
                NiType::NiDirectionalLight(inner) => Ok(inner),
                NiType::NiRotatingParticles(inner) => Ok(inner),
                NiType::NiParticles(inner) => Ok(inner),
                NiType::NiParticleModifier(inner) => Ok(inner),
                NiType::NiFltAnimationNode(inner) => Ok(inner),
                NiType::NiAlphaAccumulator(inner) => Ok(inner),
                NiType::NiSourceTexture(inner) => Ok(inner),
                NiType::NiTriStrips(inner) => Ok(inner),
                NiType::NiTriShape(inner) => Ok(inner),
                NiType::NiKeyframeManager(inner) => Ok(inner),
                NiType::NiAlphaController(inner) => Ok(inner),
                NiType::NiCamera(inner) => Ok(inner),
                NiType::BrickNiExtraData(inner) => Ok(inner),
                NiType::NiRollController(inner) => Ok(inner),
                NiType::NiLight(inner) => Ok(inner),
                NiType::NiDynamicEffect(inner) => Ok(inner),
                NiType::NiFloatController(inner) => Ok(inner),
                NiType::NiClusterAccumulator(inner) => Ok(inner),
                NiType::NiDX8Renderer(inner) => Ok(inner),
                NiType::NiGeometry(inner) => Ok(inner),
                NiType::NiMaterialProperty(inner) => Ok(inner),
                NiType::NiObject(inner) => Ok(inner),
                NiType::NiGeometryData(inner) => Ok(inner),
                NiType::NiRotData(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiObject> for NiBSParticleNode {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiLinesData {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiFogProperty {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiLines {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiRenderedTexture {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiTriBasedGeomData {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiAutoNormalParticles {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiExtraData {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiAlphaProperty {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiAccumulator {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiCollisionSwitch {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiObjectNET {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiBSPNode {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiBSAnimationNode {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiPalette {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiGeomMorpherController {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiPathController {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for AvoidNode {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiRenderer {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiDitherProperty {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiParticlesData {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiProperty {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiSequenceStreamHelper {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiSkinData {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiFlipController {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiSkinInstance {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiSpecularProperty {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiShadeProperty {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiParticleSystemController {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiSpotLight {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for BSMirroredNode {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiBSPArrayController {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiBillboardNode {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiBSAnimationManager {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiKeyframeData {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiLookAtController {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiParticleBomb {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiScreenPolygon {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiTextKeyExtraData {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiSkinPartition {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiRotatingParticlesData {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiTextureEffect {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiKeyframeController {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiAVObject {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiColorData {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiLightColorController {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiMorpherController {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiGravity {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiNode {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiParticleCollider {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiParticleColorModifier {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiTexturingProperty {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiTriBasedGeom {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiAutoNormalParticlesData {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiSphericalCollider {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiTriShapeData {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiBltSource {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiVertexColorProperty {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiStringExtraData {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiVertWeightsExtraData {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiParticleRotation {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiVisData {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiSwitchNode {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiEmitterModifier {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiFloatData {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiSortAdjustNode {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiTriShapeDynamicData {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiWireframeProperty {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiRenderedCubeMap {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiZBufferProperty {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for RootCollisionNode {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiTexture {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiPosData {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiPixelData {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiUVController {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiStencilProperty {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for TES3ObjectExtraData {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiTriStripsData {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiAmbientLight {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiMorphData {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiUVData {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiPointLight {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiParticleGrowFade {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiLODNode {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiVisController {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiMaterialColorController {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiPlanarCollider {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiTimeController {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiDirectionalLight {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiRotatingParticles {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiParticles {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiParticleModifier {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiFltAnimationNode {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiAlphaAccumulator {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiSourceTexture {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiTriStrips {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiTriShape {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiKeyframeManager {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiAlphaController {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiCamera {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for BrickNiExtraData {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiRollController {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiLight {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiDynamicEffect {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiFloatController {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiClusterAccumulator {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiDX8Renderer {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiGeometry {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiMaterialProperty {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiObject {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiGeometryData {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl AsRef<NiObject> for NiRotData {
        fn as_ref(&self) -> &NiObject {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiGeometryData {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiLinesData(inner) => Ok(inner),
                NiType::NiTriBasedGeomData(inner) => Ok(inner),
                NiType::NiParticlesData(inner) => Ok(inner),
                NiType::NiRotatingParticlesData(inner) => Ok(inner),
                NiType::NiAutoNormalParticlesData(inner) => Ok(inner),
                NiType::NiTriShapeData(inner) => Ok(inner),
                NiType::NiTriShapeDynamicData(inner) => Ok(inner),
                NiType::NiTriStripsData(inner) => Ok(inner),
                NiType::NiGeometryData(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiGeometryData {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiLinesData(inner) => Ok(inner),
                NiType::NiTriBasedGeomData(inner) => Ok(inner),
                NiType::NiParticlesData(inner) => Ok(inner),
                NiType::NiRotatingParticlesData(inner) => Ok(inner),
                NiType::NiAutoNormalParticlesData(inner) => Ok(inner),
                NiType::NiTriShapeData(inner) => Ok(inner),
                NiType::NiTriShapeDynamicData(inner) => Ok(inner),
                NiType::NiTriStripsData(inner) => Ok(inner),
                NiType::NiGeometryData(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiGeometryData> for NiLinesData {
        fn as_ref(&self) -> &NiGeometryData {
            &self
        }
    }
    impl AsRef<NiGeometryData> for NiTriBasedGeomData {
        fn as_ref(&self) -> &NiGeometryData {
            &self
        }
    }
    impl AsRef<NiGeometryData> for NiParticlesData {
        fn as_ref(&self) -> &NiGeometryData {
            &self
        }
    }
    impl AsRef<NiGeometryData> for NiRotatingParticlesData {
        fn as_ref(&self) -> &NiGeometryData {
            &self
        }
    }
    impl AsRef<NiGeometryData> for NiAutoNormalParticlesData {
        fn as_ref(&self) -> &NiGeometryData {
            &self
        }
    }
    impl AsRef<NiGeometryData> for NiTriShapeData {
        fn as_ref(&self) -> &NiGeometryData {
            &self
        }
    }
    impl AsRef<NiGeometryData> for NiTriShapeDynamicData {
        fn as_ref(&self) -> &NiGeometryData {
            &self
        }
    }
    impl AsRef<NiGeometryData> for NiTriStripsData {
        fn as_ref(&self) -> &NiGeometryData {
            &self
        }
    }
    impl AsRef<NiGeometryData> for NiGeometryData {
        fn as_ref(&self) -> &NiGeometryData {
            &self
        }
    }
    impl<'a> TryFrom<&'a NiType> for &'a NiRotData {
        type Error = ();
        fn try_from(value: &'a NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiRotData(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl<'a> TryFrom<&'a mut NiType> for &'a mut NiRotData {
        type Error = ();
        fn try_from(value: &'a mut NiType) -> Result<Self, Self::Error> {
            match value {
                NiType::NiRotData(inner) => Ok(inner),
                _ => Err(()),
            }
        }
    }
    impl AsRef<NiRotData> for NiRotData {
        fn as_ref(&self) -> &NiRotData {
            &self
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for NiType {
        #[inline]
        fn clone(&self) -> NiType {
            match self {
                NiType::Empty => NiType::Empty,
                NiType::AvoidNode(__self_0) => {
                    NiType::AvoidNode(::core::clone::Clone::clone(__self_0))
                }
                NiType::BrickNiExtraData(__self_0) => {
                    NiType::BrickNiExtraData(::core::clone::Clone::clone(__self_0))
                }
                NiType::BSMirroredNode(__self_0) => {
                    NiType::BSMirroredNode(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiAccumulator(__self_0) => {
                    NiType::NiAccumulator(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiAlphaAccumulator(__self_0) => {
                    NiType::NiAlphaAccumulator(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiAlphaController(__self_0) => {
                    NiType::NiAlphaController(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiAlphaProperty(__self_0) => {
                    NiType::NiAlphaProperty(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiAmbientLight(__self_0) => {
                    NiType::NiAmbientLight(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiAutoNormalParticles(__self_0) => {
                    NiType::NiAutoNormalParticles(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiAutoNormalParticlesData(__self_0) => {
                    NiType::NiAutoNormalParticlesData(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
                NiType::NiAVObject(__self_0) => {
                    NiType::NiAVObject(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiBillboardNode(__self_0) => {
                    NiType::NiBillboardNode(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiBltSource(__self_0) => {
                    NiType::NiBltSource(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiBSAnimationManager(__self_0) => {
                    NiType::NiBSAnimationManager(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiBSAnimationNode(__self_0) => {
                    NiType::NiBSAnimationNode(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiBSPArrayController(__self_0) => {
                    NiType::NiBSPArrayController(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiBSParticleNode(__self_0) => {
                    NiType::NiBSParticleNode(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiBSPNode(__self_0) => {
                    NiType::NiBSPNode(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiCamera(__self_0) => {
                    NiType::NiCamera(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiClusterAccumulator(__self_0) => {
                    NiType::NiClusterAccumulator(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiCollisionSwitch(__self_0) => {
                    NiType::NiCollisionSwitch(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiColorData(__self_0) => {
                    NiType::NiColorData(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiDirectionalLight(__self_0) => {
                    NiType::NiDirectionalLight(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiDitherProperty(__self_0) => {
                    NiType::NiDitherProperty(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiDX8Renderer(__self_0) => {
                    NiType::NiDX8Renderer(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiDynamicEffect(__self_0) => {
                    NiType::NiDynamicEffect(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiEmitterModifier(__self_0) => {
                    NiType::NiEmitterModifier(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiExtraData(__self_0) => {
                    NiType::NiExtraData(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiFlipController(__self_0) => {
                    NiType::NiFlipController(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiFloatController(__self_0) => {
                    NiType::NiFloatController(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiFloatData(__self_0) => {
                    NiType::NiFloatData(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiFltAnimationNode(__self_0) => {
                    NiType::NiFltAnimationNode(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiFogProperty(__self_0) => {
                    NiType::NiFogProperty(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiGeometry(__self_0) => {
                    NiType::NiGeometry(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiGeometryData(__self_0) => {
                    NiType::NiGeometryData(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiGeomMorpherController(__self_0) => {
                    NiType::NiGeomMorpherController(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
                NiType::NiGravity(__self_0) => {
                    NiType::NiGravity(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiKeyframeController(__self_0) => {
                    NiType::NiKeyframeController(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiKeyframeData(__self_0) => {
                    NiType::NiKeyframeData(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiKeyframeManager(__self_0) => {
                    NiType::NiKeyframeManager(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiLight(__self_0) => {
                    NiType::NiLight(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiLightColorController(__self_0) => {
                    NiType::NiLightColorController(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiLines(__self_0) => {
                    NiType::NiLines(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiLinesData(__self_0) => {
                    NiType::NiLinesData(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiLODNode(__self_0) => {
                    NiType::NiLODNode(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiLookAtController(__self_0) => {
                    NiType::NiLookAtController(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiMaterialColorController(__self_0) => {
                    NiType::NiMaterialColorController(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
                NiType::NiMaterialProperty(__self_0) => {
                    NiType::NiMaterialProperty(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiMorphData(__self_0) => {
                    NiType::NiMorphData(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiMorpherController(__self_0) => {
                    NiType::NiMorpherController(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiNode(__self_0) => {
                    NiType::NiNode(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiObject(__self_0) => {
                    NiType::NiObject(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiObjectNET(__self_0) => {
                    NiType::NiObjectNET(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiPalette(__self_0) => {
                    NiType::NiPalette(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiParticleBomb(__self_0) => {
                    NiType::NiParticleBomb(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiParticleCollider(__self_0) => {
                    NiType::NiParticleCollider(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiParticleColorModifier(__self_0) => {
                    NiType::NiParticleColorModifier(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
                NiType::NiParticleGrowFade(__self_0) => {
                    NiType::NiParticleGrowFade(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiParticleModifier(__self_0) => {
                    NiType::NiParticleModifier(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiParticleRotation(__self_0) => {
                    NiType::NiParticleRotation(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiParticles(__self_0) => {
                    NiType::NiParticles(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiParticlesData(__self_0) => {
                    NiType::NiParticlesData(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiParticleSystemController(__self_0) => {
                    NiType::NiParticleSystemController(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
                NiType::NiPathController(__self_0) => {
                    NiType::NiPathController(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiPixelData(__self_0) => {
                    NiType::NiPixelData(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiPlanarCollider(__self_0) => {
                    NiType::NiPlanarCollider(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiPointLight(__self_0) => {
                    NiType::NiPointLight(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiPosData(__self_0) => {
                    NiType::NiPosData(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiProperty(__self_0) => {
                    NiType::NiProperty(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiRenderedCubeMap(__self_0) => {
                    NiType::NiRenderedCubeMap(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiRenderedTexture(__self_0) => {
                    NiType::NiRenderedTexture(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiRenderer(__self_0) => {
                    NiType::NiRenderer(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiRollController(__self_0) => {
                    NiType::NiRollController(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiRotatingParticles(__self_0) => {
                    NiType::NiRotatingParticles(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiRotatingParticlesData(__self_0) => {
                    NiType::NiRotatingParticlesData(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
                NiType::NiRotData(__self_0) => {
                    NiType::NiRotData(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiScreenPolygon(__self_0) => {
                    NiType::NiScreenPolygon(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiSequenceStreamHelper(__self_0) => {
                    NiType::NiSequenceStreamHelper(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiShadeProperty(__self_0) => {
                    NiType::NiShadeProperty(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiSkinData(__self_0) => {
                    NiType::NiSkinData(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiSkinInstance(__self_0) => {
                    NiType::NiSkinInstance(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiSkinPartition(__self_0) => {
                    NiType::NiSkinPartition(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiSortAdjustNode(__self_0) => {
                    NiType::NiSortAdjustNode(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiSourceTexture(__self_0) => {
                    NiType::NiSourceTexture(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiSpecularProperty(__self_0) => {
                    NiType::NiSpecularProperty(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiSphericalCollider(__self_0) => {
                    NiType::NiSphericalCollider(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiSpotLight(__self_0) => {
                    NiType::NiSpotLight(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiStencilProperty(__self_0) => {
                    NiType::NiStencilProperty(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiStringExtraData(__self_0) => {
                    NiType::NiStringExtraData(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiSwitchNode(__self_0) => {
                    NiType::NiSwitchNode(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiTextKeyExtraData(__self_0) => {
                    NiType::NiTextKeyExtraData(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiTexture(__self_0) => {
                    NiType::NiTexture(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiTextureEffect(__self_0) => {
                    NiType::NiTextureEffect(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiTexturingProperty(__self_0) => {
                    NiType::NiTexturingProperty(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiTimeController(__self_0) => {
                    NiType::NiTimeController(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiTriBasedGeom(__self_0) => {
                    NiType::NiTriBasedGeom(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiTriBasedGeomData(__self_0) => {
                    NiType::NiTriBasedGeomData(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiTriShape(__self_0) => {
                    NiType::NiTriShape(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiTriShapeData(__self_0) => {
                    NiType::NiTriShapeData(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiTriShapeDynamicData(__self_0) => {
                    NiType::NiTriShapeDynamicData(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiTriStrips(__self_0) => {
                    NiType::NiTriStrips(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiTriStripsData(__self_0) => {
                    NiType::NiTriStripsData(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiUVController(__self_0) => {
                    NiType::NiUVController(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiUVData(__self_0) => {
                    NiType::NiUVData(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiVertexColorProperty(__self_0) => {
                    NiType::NiVertexColorProperty(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiVertWeightsExtraData(__self_0) => {
                    NiType::NiVertWeightsExtraData(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiVisController(__self_0) => {
                    NiType::NiVisController(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiVisData(__self_0) => {
                    NiType::NiVisData(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiWireframeProperty(__self_0) => {
                    NiType::NiWireframeProperty(::core::clone::Clone::clone(__self_0))
                }
                NiType::NiZBufferProperty(__self_0) => {
                    NiType::NiZBufferProperty(::core::clone::Clone::clone(__self_0))
                }
                NiType::RootCollisionNode(__self_0) => {
                    NiType::RootCollisionNode(::core::clone::Clone::clone(__self_0))
                }
                NiType::TES3ObjectExtraData(__self_0) => {
                    NiType::TES3ObjectExtraData(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for NiType {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                NiType::Empty => ::core::fmt::Formatter::write_str(f, "Empty"),
                NiType::AvoidNode(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "AvoidNode",
                        &__self_0,
                    )
                }
                NiType::BrickNiExtraData(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "BrickNiExtraData",
                        &__self_0,
                    )
                }
                NiType::BSMirroredNode(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "BSMirroredNode",
                        &__self_0,
                    )
                }
                NiType::NiAccumulator(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiAccumulator",
                        &__self_0,
                    )
                }
                NiType::NiAlphaAccumulator(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiAlphaAccumulator",
                        &__self_0,
                    )
                }
                NiType::NiAlphaController(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiAlphaController",
                        &__self_0,
                    )
                }
                NiType::NiAlphaProperty(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiAlphaProperty",
                        &__self_0,
                    )
                }
                NiType::NiAmbientLight(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiAmbientLight",
                        &__self_0,
                    )
                }
                NiType::NiAutoNormalParticles(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiAutoNormalParticles",
                        &__self_0,
                    )
                }
                NiType::NiAutoNormalParticlesData(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiAutoNormalParticlesData",
                        &__self_0,
                    )
                }
                NiType::NiAVObject(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiAVObject",
                        &__self_0,
                    )
                }
                NiType::NiBillboardNode(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiBillboardNode",
                        &__self_0,
                    )
                }
                NiType::NiBltSource(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiBltSource",
                        &__self_0,
                    )
                }
                NiType::NiBSAnimationManager(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiBSAnimationManager",
                        &__self_0,
                    )
                }
                NiType::NiBSAnimationNode(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiBSAnimationNode",
                        &__self_0,
                    )
                }
                NiType::NiBSPArrayController(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiBSPArrayController",
                        &__self_0,
                    )
                }
                NiType::NiBSParticleNode(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiBSParticleNode",
                        &__self_0,
                    )
                }
                NiType::NiBSPNode(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiBSPNode",
                        &__self_0,
                    )
                }
                NiType::NiCamera(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiCamera",
                        &__self_0,
                    )
                }
                NiType::NiClusterAccumulator(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiClusterAccumulator",
                        &__self_0,
                    )
                }
                NiType::NiCollisionSwitch(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiCollisionSwitch",
                        &__self_0,
                    )
                }
                NiType::NiColorData(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiColorData",
                        &__self_0,
                    )
                }
                NiType::NiDirectionalLight(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiDirectionalLight",
                        &__self_0,
                    )
                }
                NiType::NiDitherProperty(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiDitherProperty",
                        &__self_0,
                    )
                }
                NiType::NiDX8Renderer(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiDX8Renderer",
                        &__self_0,
                    )
                }
                NiType::NiDynamicEffect(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiDynamicEffect",
                        &__self_0,
                    )
                }
                NiType::NiEmitterModifier(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiEmitterModifier",
                        &__self_0,
                    )
                }
                NiType::NiExtraData(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiExtraData",
                        &__self_0,
                    )
                }
                NiType::NiFlipController(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiFlipController",
                        &__self_0,
                    )
                }
                NiType::NiFloatController(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiFloatController",
                        &__self_0,
                    )
                }
                NiType::NiFloatData(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiFloatData",
                        &__self_0,
                    )
                }
                NiType::NiFltAnimationNode(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiFltAnimationNode",
                        &__self_0,
                    )
                }
                NiType::NiFogProperty(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiFogProperty",
                        &__self_0,
                    )
                }
                NiType::NiGeometry(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiGeometry",
                        &__self_0,
                    )
                }
                NiType::NiGeometryData(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiGeometryData",
                        &__self_0,
                    )
                }
                NiType::NiGeomMorpherController(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiGeomMorpherController",
                        &__self_0,
                    )
                }
                NiType::NiGravity(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiGravity",
                        &__self_0,
                    )
                }
                NiType::NiKeyframeController(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiKeyframeController",
                        &__self_0,
                    )
                }
                NiType::NiKeyframeData(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiKeyframeData",
                        &__self_0,
                    )
                }
                NiType::NiKeyframeManager(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiKeyframeManager",
                        &__self_0,
                    )
                }
                NiType::NiLight(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiLight",
                        &__self_0,
                    )
                }
                NiType::NiLightColorController(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiLightColorController",
                        &__self_0,
                    )
                }
                NiType::NiLines(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiLines",
                        &__self_0,
                    )
                }
                NiType::NiLinesData(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiLinesData",
                        &__self_0,
                    )
                }
                NiType::NiLODNode(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiLODNode",
                        &__self_0,
                    )
                }
                NiType::NiLookAtController(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiLookAtController",
                        &__self_0,
                    )
                }
                NiType::NiMaterialColorController(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiMaterialColorController",
                        &__self_0,
                    )
                }
                NiType::NiMaterialProperty(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiMaterialProperty",
                        &__self_0,
                    )
                }
                NiType::NiMorphData(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiMorphData",
                        &__self_0,
                    )
                }
                NiType::NiMorpherController(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiMorpherController",
                        &__self_0,
                    )
                }
                NiType::NiNode(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiNode",
                        &__self_0,
                    )
                }
                NiType::NiObject(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiObject",
                        &__self_0,
                    )
                }
                NiType::NiObjectNET(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiObjectNET",
                        &__self_0,
                    )
                }
                NiType::NiPalette(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiPalette",
                        &__self_0,
                    )
                }
                NiType::NiParticleBomb(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiParticleBomb",
                        &__self_0,
                    )
                }
                NiType::NiParticleCollider(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiParticleCollider",
                        &__self_0,
                    )
                }
                NiType::NiParticleColorModifier(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiParticleColorModifier",
                        &__self_0,
                    )
                }
                NiType::NiParticleGrowFade(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiParticleGrowFade",
                        &__self_0,
                    )
                }
                NiType::NiParticleModifier(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiParticleModifier",
                        &__self_0,
                    )
                }
                NiType::NiParticleRotation(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiParticleRotation",
                        &__self_0,
                    )
                }
                NiType::NiParticles(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiParticles",
                        &__self_0,
                    )
                }
                NiType::NiParticlesData(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiParticlesData",
                        &__self_0,
                    )
                }
                NiType::NiParticleSystemController(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiParticleSystemController",
                        &__self_0,
                    )
                }
                NiType::NiPathController(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiPathController",
                        &__self_0,
                    )
                }
                NiType::NiPixelData(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiPixelData",
                        &__self_0,
                    )
                }
                NiType::NiPlanarCollider(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiPlanarCollider",
                        &__self_0,
                    )
                }
                NiType::NiPointLight(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiPointLight",
                        &__self_0,
                    )
                }
                NiType::NiPosData(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiPosData",
                        &__self_0,
                    )
                }
                NiType::NiProperty(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiProperty",
                        &__self_0,
                    )
                }
                NiType::NiRenderedCubeMap(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiRenderedCubeMap",
                        &__self_0,
                    )
                }
                NiType::NiRenderedTexture(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiRenderedTexture",
                        &__self_0,
                    )
                }
                NiType::NiRenderer(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiRenderer",
                        &__self_0,
                    )
                }
                NiType::NiRollController(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiRollController",
                        &__self_0,
                    )
                }
                NiType::NiRotatingParticles(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiRotatingParticles",
                        &__self_0,
                    )
                }
                NiType::NiRotatingParticlesData(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiRotatingParticlesData",
                        &__self_0,
                    )
                }
                NiType::NiRotData(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiRotData",
                        &__self_0,
                    )
                }
                NiType::NiScreenPolygon(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiScreenPolygon",
                        &__self_0,
                    )
                }
                NiType::NiSequenceStreamHelper(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiSequenceStreamHelper",
                        &__self_0,
                    )
                }
                NiType::NiShadeProperty(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiShadeProperty",
                        &__self_0,
                    )
                }
                NiType::NiSkinData(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiSkinData",
                        &__self_0,
                    )
                }
                NiType::NiSkinInstance(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiSkinInstance",
                        &__self_0,
                    )
                }
                NiType::NiSkinPartition(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiSkinPartition",
                        &__self_0,
                    )
                }
                NiType::NiSortAdjustNode(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiSortAdjustNode",
                        &__self_0,
                    )
                }
                NiType::NiSourceTexture(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiSourceTexture",
                        &__self_0,
                    )
                }
                NiType::NiSpecularProperty(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiSpecularProperty",
                        &__self_0,
                    )
                }
                NiType::NiSphericalCollider(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiSphericalCollider",
                        &__self_0,
                    )
                }
                NiType::NiSpotLight(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiSpotLight",
                        &__self_0,
                    )
                }
                NiType::NiStencilProperty(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiStencilProperty",
                        &__self_0,
                    )
                }
                NiType::NiStringExtraData(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiStringExtraData",
                        &__self_0,
                    )
                }
                NiType::NiSwitchNode(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiSwitchNode",
                        &__self_0,
                    )
                }
                NiType::NiTextKeyExtraData(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiTextKeyExtraData",
                        &__self_0,
                    )
                }
                NiType::NiTexture(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiTexture",
                        &__self_0,
                    )
                }
                NiType::NiTextureEffect(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiTextureEffect",
                        &__self_0,
                    )
                }
                NiType::NiTexturingProperty(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiTexturingProperty",
                        &__self_0,
                    )
                }
                NiType::NiTimeController(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiTimeController",
                        &__self_0,
                    )
                }
                NiType::NiTriBasedGeom(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiTriBasedGeom",
                        &__self_0,
                    )
                }
                NiType::NiTriBasedGeomData(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiTriBasedGeomData",
                        &__self_0,
                    )
                }
                NiType::NiTriShape(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiTriShape",
                        &__self_0,
                    )
                }
                NiType::NiTriShapeData(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiTriShapeData",
                        &__self_0,
                    )
                }
                NiType::NiTriShapeDynamicData(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiTriShapeDynamicData",
                        &__self_0,
                    )
                }
                NiType::NiTriStrips(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiTriStrips",
                        &__self_0,
                    )
                }
                NiType::NiTriStripsData(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiTriStripsData",
                        &__self_0,
                    )
                }
                NiType::NiUVController(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiUVController",
                        &__self_0,
                    )
                }
                NiType::NiUVData(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiUVData",
                        &__self_0,
                    )
                }
                NiType::NiVertexColorProperty(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiVertexColorProperty",
                        &__self_0,
                    )
                }
                NiType::NiVertWeightsExtraData(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiVertWeightsExtraData",
                        &__self_0,
                    )
                }
                NiType::NiVisController(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiVisController",
                        &__self_0,
                    )
                }
                NiType::NiVisData(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiVisData",
                        &__self_0,
                    )
                }
                NiType::NiWireframeProperty(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiWireframeProperty",
                        &__self_0,
                    )
                }
                NiType::NiZBufferProperty(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NiZBufferProperty",
                        &__self_0,
                    )
                }
                NiType::RootCollisionNode(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "RootCollisionNode",
                        &__self_0,
                    )
                }
                NiType::TES3ObjectExtraData(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "TES3ObjectExtraData",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(AvoidNode)> for NiType {
        #[inline]
        fn from(value: (AvoidNode)) -> Self {
            NiType::AvoidNode(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(BrickNiExtraData)> for NiType {
        #[inline]
        fn from(value: (BrickNiExtraData)) -> Self {
            NiType::BrickNiExtraData(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(BSMirroredNode)> for NiType {
        #[inline]
        fn from(value: (BSMirroredNode)) -> Self {
            NiType::BSMirroredNode(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiAccumulator)> for NiType {
        #[inline]
        fn from(value: (NiAccumulator)) -> Self {
            NiType::NiAccumulator(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiAlphaAccumulator)> for NiType {
        #[inline]
        fn from(value: (NiAlphaAccumulator)) -> Self {
            NiType::NiAlphaAccumulator(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiAlphaController)> for NiType {
        #[inline]
        fn from(value: (NiAlphaController)) -> Self {
            NiType::NiAlphaController(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiAlphaProperty)> for NiType {
        #[inline]
        fn from(value: (NiAlphaProperty)) -> Self {
            NiType::NiAlphaProperty(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiAmbientLight)> for NiType {
        #[inline]
        fn from(value: (NiAmbientLight)) -> Self {
            NiType::NiAmbientLight(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiAutoNormalParticles)> for NiType {
        #[inline]
        fn from(value: (NiAutoNormalParticles)) -> Self {
            NiType::NiAutoNormalParticles(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiAutoNormalParticlesData)> for NiType {
        #[inline]
        fn from(value: (NiAutoNormalParticlesData)) -> Self {
            NiType::NiAutoNormalParticlesData(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiAVObject)> for NiType {
        #[inline]
        fn from(value: (NiAVObject)) -> Self {
            NiType::NiAVObject(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiBillboardNode)> for NiType {
        #[inline]
        fn from(value: (NiBillboardNode)) -> Self {
            NiType::NiBillboardNode(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiBltSource)> for NiType {
        #[inline]
        fn from(value: (NiBltSource)) -> Self {
            NiType::NiBltSource(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiBSAnimationManager)> for NiType {
        #[inline]
        fn from(value: (NiBSAnimationManager)) -> Self {
            NiType::NiBSAnimationManager(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiBSAnimationNode)> for NiType {
        #[inline]
        fn from(value: (NiBSAnimationNode)) -> Self {
            NiType::NiBSAnimationNode(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiBSPArrayController)> for NiType {
        #[inline]
        fn from(value: (NiBSPArrayController)) -> Self {
            NiType::NiBSPArrayController(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiBSParticleNode)> for NiType {
        #[inline]
        fn from(value: (NiBSParticleNode)) -> Self {
            NiType::NiBSParticleNode(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiBSPNode)> for NiType {
        #[inline]
        fn from(value: (NiBSPNode)) -> Self {
            NiType::NiBSPNode(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiCamera)> for NiType {
        #[inline]
        fn from(value: (NiCamera)) -> Self {
            NiType::NiCamera(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiClusterAccumulator)> for NiType {
        #[inline]
        fn from(value: (NiClusterAccumulator)) -> Self {
            NiType::NiClusterAccumulator(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiCollisionSwitch)> for NiType {
        #[inline]
        fn from(value: (NiCollisionSwitch)) -> Self {
            NiType::NiCollisionSwitch(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiColorData)> for NiType {
        #[inline]
        fn from(value: (NiColorData)) -> Self {
            NiType::NiColorData(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiDirectionalLight)> for NiType {
        #[inline]
        fn from(value: (NiDirectionalLight)) -> Self {
            NiType::NiDirectionalLight(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiDitherProperty)> for NiType {
        #[inline]
        fn from(value: (NiDitherProperty)) -> Self {
            NiType::NiDitherProperty(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiDX8Renderer)> for NiType {
        #[inline]
        fn from(value: (NiDX8Renderer)) -> Self {
            NiType::NiDX8Renderer(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiDynamicEffect)> for NiType {
        #[inline]
        fn from(value: (NiDynamicEffect)) -> Self {
            NiType::NiDynamicEffect(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiEmitterModifier)> for NiType {
        #[inline]
        fn from(value: (NiEmitterModifier)) -> Self {
            NiType::NiEmitterModifier(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiExtraData)> for NiType {
        #[inline]
        fn from(value: (NiExtraData)) -> Self {
            NiType::NiExtraData(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiFlipController)> for NiType {
        #[inline]
        fn from(value: (NiFlipController)) -> Self {
            NiType::NiFlipController(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiFloatController)> for NiType {
        #[inline]
        fn from(value: (NiFloatController)) -> Self {
            NiType::NiFloatController(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiFloatData)> for NiType {
        #[inline]
        fn from(value: (NiFloatData)) -> Self {
            NiType::NiFloatData(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiFltAnimationNode)> for NiType {
        #[inline]
        fn from(value: (NiFltAnimationNode)) -> Self {
            NiType::NiFltAnimationNode(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiFogProperty)> for NiType {
        #[inline]
        fn from(value: (NiFogProperty)) -> Self {
            NiType::NiFogProperty(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiGeometry)> for NiType {
        #[inline]
        fn from(value: (NiGeometry)) -> Self {
            NiType::NiGeometry(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiGeometryData)> for NiType {
        #[inline]
        fn from(value: (NiGeometryData)) -> Self {
            NiType::NiGeometryData(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiGeomMorpherController)> for NiType {
        #[inline]
        fn from(value: (NiGeomMorpherController)) -> Self {
            NiType::NiGeomMorpherController(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiGravity)> for NiType {
        #[inline]
        fn from(value: (NiGravity)) -> Self {
            NiType::NiGravity(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiKeyframeController)> for NiType {
        #[inline]
        fn from(value: (NiKeyframeController)) -> Self {
            NiType::NiKeyframeController(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiKeyframeData)> for NiType {
        #[inline]
        fn from(value: (NiKeyframeData)) -> Self {
            NiType::NiKeyframeData(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiKeyframeManager)> for NiType {
        #[inline]
        fn from(value: (NiKeyframeManager)) -> Self {
            NiType::NiKeyframeManager(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiLight)> for NiType {
        #[inline]
        fn from(value: (NiLight)) -> Self {
            NiType::NiLight(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiLightColorController)> for NiType {
        #[inline]
        fn from(value: (NiLightColorController)) -> Self {
            NiType::NiLightColorController(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiLines)> for NiType {
        #[inline]
        fn from(value: (NiLines)) -> Self {
            NiType::NiLines(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiLinesData)> for NiType {
        #[inline]
        fn from(value: (NiLinesData)) -> Self {
            NiType::NiLinesData(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiLODNode)> for NiType {
        #[inline]
        fn from(value: (NiLODNode)) -> Self {
            NiType::NiLODNode(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiLookAtController)> for NiType {
        #[inline]
        fn from(value: (NiLookAtController)) -> Self {
            NiType::NiLookAtController(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiMaterialColorController)> for NiType {
        #[inline]
        fn from(value: (NiMaterialColorController)) -> Self {
            NiType::NiMaterialColorController(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiMaterialProperty)> for NiType {
        #[inline]
        fn from(value: (NiMaterialProperty)) -> Self {
            NiType::NiMaterialProperty(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiMorphData)> for NiType {
        #[inline]
        fn from(value: (NiMorphData)) -> Self {
            NiType::NiMorphData(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiMorpherController)> for NiType {
        #[inline]
        fn from(value: (NiMorpherController)) -> Self {
            NiType::NiMorpherController(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiNode)> for NiType {
        #[inline]
        fn from(value: (NiNode)) -> Self {
            NiType::NiNode(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiObject)> for NiType {
        #[inline]
        fn from(value: (NiObject)) -> Self {
            NiType::NiObject(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiObjectNET)> for NiType {
        #[inline]
        fn from(value: (NiObjectNET)) -> Self {
            NiType::NiObjectNET(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiPalette)> for NiType {
        #[inline]
        fn from(value: (NiPalette)) -> Self {
            NiType::NiPalette(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiParticleBomb)> for NiType {
        #[inline]
        fn from(value: (NiParticleBomb)) -> Self {
            NiType::NiParticleBomb(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiParticleCollider)> for NiType {
        #[inline]
        fn from(value: (NiParticleCollider)) -> Self {
            NiType::NiParticleCollider(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiParticleColorModifier)> for NiType {
        #[inline]
        fn from(value: (NiParticleColorModifier)) -> Self {
            NiType::NiParticleColorModifier(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiParticleGrowFade)> for NiType {
        #[inline]
        fn from(value: (NiParticleGrowFade)) -> Self {
            NiType::NiParticleGrowFade(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiParticleModifier)> for NiType {
        #[inline]
        fn from(value: (NiParticleModifier)) -> Self {
            NiType::NiParticleModifier(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiParticleRotation)> for NiType {
        #[inline]
        fn from(value: (NiParticleRotation)) -> Self {
            NiType::NiParticleRotation(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiParticles)> for NiType {
        #[inline]
        fn from(value: (NiParticles)) -> Self {
            NiType::NiParticles(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiParticlesData)> for NiType {
        #[inline]
        fn from(value: (NiParticlesData)) -> Self {
            NiType::NiParticlesData(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiParticleSystemController)> for NiType {
        #[inline]
        fn from(value: (NiParticleSystemController)) -> Self {
            NiType::NiParticleSystemController(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiPathController)> for NiType {
        #[inline]
        fn from(value: (NiPathController)) -> Self {
            NiType::NiPathController(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiPixelData)> for NiType {
        #[inline]
        fn from(value: (NiPixelData)) -> Self {
            NiType::NiPixelData(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiPlanarCollider)> for NiType {
        #[inline]
        fn from(value: (NiPlanarCollider)) -> Self {
            NiType::NiPlanarCollider(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiPointLight)> for NiType {
        #[inline]
        fn from(value: (NiPointLight)) -> Self {
            NiType::NiPointLight(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiPosData)> for NiType {
        #[inline]
        fn from(value: (NiPosData)) -> Self {
            NiType::NiPosData(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiProperty)> for NiType {
        #[inline]
        fn from(value: (NiProperty)) -> Self {
            NiType::NiProperty(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiRenderedCubeMap)> for NiType {
        #[inline]
        fn from(value: (NiRenderedCubeMap)) -> Self {
            NiType::NiRenderedCubeMap(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiRenderedTexture)> for NiType {
        #[inline]
        fn from(value: (NiRenderedTexture)) -> Self {
            NiType::NiRenderedTexture(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiRenderer)> for NiType {
        #[inline]
        fn from(value: (NiRenderer)) -> Self {
            NiType::NiRenderer(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiRollController)> for NiType {
        #[inline]
        fn from(value: (NiRollController)) -> Self {
            NiType::NiRollController(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiRotatingParticles)> for NiType {
        #[inline]
        fn from(value: (NiRotatingParticles)) -> Self {
            NiType::NiRotatingParticles(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiRotatingParticlesData)> for NiType {
        #[inline]
        fn from(value: (NiRotatingParticlesData)) -> Self {
            NiType::NiRotatingParticlesData(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiRotData)> for NiType {
        #[inline]
        fn from(value: (NiRotData)) -> Self {
            NiType::NiRotData(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiScreenPolygon)> for NiType {
        #[inline]
        fn from(value: (NiScreenPolygon)) -> Self {
            NiType::NiScreenPolygon(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiSequenceStreamHelper)> for NiType {
        #[inline]
        fn from(value: (NiSequenceStreamHelper)) -> Self {
            NiType::NiSequenceStreamHelper(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiShadeProperty)> for NiType {
        #[inline]
        fn from(value: (NiShadeProperty)) -> Self {
            NiType::NiShadeProperty(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiSkinData)> for NiType {
        #[inline]
        fn from(value: (NiSkinData)) -> Self {
            NiType::NiSkinData(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiSkinInstance)> for NiType {
        #[inline]
        fn from(value: (NiSkinInstance)) -> Self {
            NiType::NiSkinInstance(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiSkinPartition)> for NiType {
        #[inline]
        fn from(value: (NiSkinPartition)) -> Self {
            NiType::NiSkinPartition(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiSortAdjustNode)> for NiType {
        #[inline]
        fn from(value: (NiSortAdjustNode)) -> Self {
            NiType::NiSortAdjustNode(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiSourceTexture)> for NiType {
        #[inline]
        fn from(value: (NiSourceTexture)) -> Self {
            NiType::NiSourceTexture(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiSpecularProperty)> for NiType {
        #[inline]
        fn from(value: (NiSpecularProperty)) -> Self {
            NiType::NiSpecularProperty(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiSphericalCollider)> for NiType {
        #[inline]
        fn from(value: (NiSphericalCollider)) -> Self {
            NiType::NiSphericalCollider(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiSpotLight)> for NiType {
        #[inline]
        fn from(value: (NiSpotLight)) -> Self {
            NiType::NiSpotLight(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiStencilProperty)> for NiType {
        #[inline]
        fn from(value: (NiStencilProperty)) -> Self {
            NiType::NiStencilProperty(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiStringExtraData)> for NiType {
        #[inline]
        fn from(value: (NiStringExtraData)) -> Self {
            NiType::NiStringExtraData(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiSwitchNode)> for NiType {
        #[inline]
        fn from(value: (NiSwitchNode)) -> Self {
            NiType::NiSwitchNode(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiTextKeyExtraData)> for NiType {
        #[inline]
        fn from(value: (NiTextKeyExtraData)) -> Self {
            NiType::NiTextKeyExtraData(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiTexture)> for NiType {
        #[inline]
        fn from(value: (NiTexture)) -> Self {
            NiType::NiTexture(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiTextureEffect)> for NiType {
        #[inline]
        fn from(value: (NiTextureEffect)) -> Self {
            NiType::NiTextureEffect(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiTexturingProperty)> for NiType {
        #[inline]
        fn from(value: (NiTexturingProperty)) -> Self {
            NiType::NiTexturingProperty(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiTimeController)> for NiType {
        #[inline]
        fn from(value: (NiTimeController)) -> Self {
            NiType::NiTimeController(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiTriBasedGeom)> for NiType {
        #[inline]
        fn from(value: (NiTriBasedGeom)) -> Self {
            NiType::NiTriBasedGeom(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiTriBasedGeomData)> for NiType {
        #[inline]
        fn from(value: (NiTriBasedGeomData)) -> Self {
            NiType::NiTriBasedGeomData(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiTriShape)> for NiType {
        #[inline]
        fn from(value: (NiTriShape)) -> Self {
            NiType::NiTriShape(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiTriShapeData)> for NiType {
        #[inline]
        fn from(value: (NiTriShapeData)) -> Self {
            NiType::NiTriShapeData(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiTriShapeDynamicData)> for NiType {
        #[inline]
        fn from(value: (NiTriShapeDynamicData)) -> Self {
            NiType::NiTriShapeDynamicData(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiTriStrips)> for NiType {
        #[inline]
        fn from(value: (NiTriStrips)) -> Self {
            NiType::NiTriStrips(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiTriStripsData)> for NiType {
        #[inline]
        fn from(value: (NiTriStripsData)) -> Self {
            NiType::NiTriStripsData(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiUVController)> for NiType {
        #[inline]
        fn from(value: (NiUVController)) -> Self {
            NiType::NiUVController(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiUVData)> for NiType {
        #[inline]
        fn from(value: (NiUVData)) -> Self {
            NiType::NiUVData(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiVertexColorProperty)> for NiType {
        #[inline]
        fn from(value: (NiVertexColorProperty)) -> Self {
            NiType::NiVertexColorProperty(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiVertWeightsExtraData)> for NiType {
        #[inline]
        fn from(value: (NiVertWeightsExtraData)) -> Self {
            NiType::NiVertWeightsExtraData(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiVisController)> for NiType {
        #[inline]
        fn from(value: (NiVisController)) -> Self {
            NiType::NiVisController(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiVisData)> for NiType {
        #[inline]
        fn from(value: (NiVisData)) -> Self {
            NiType::NiVisData(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiWireframeProperty)> for NiType {
        #[inline]
        fn from(value: (NiWireframeProperty)) -> Self {
            NiType::NiWireframeProperty(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(NiZBufferProperty)> for NiType {
        #[inline]
        fn from(value: (NiZBufferProperty)) -> Self {
            NiType::NiZBufferProperty(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(RootCollisionNode)> for NiType {
        #[inline]
        fn from(value: (RootCollisionNode)) -> Self {
            NiType::RootCollisionNode(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(TES3ObjectExtraData)> for NiType {
        #[inline]
        fn from(value: (TES3ObjectExtraData)) -> Self {
            NiType::TES3ObjectExtraData(value)
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for NiType {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for NiType {
        #[inline]
        fn eq(&self, other: &NiType) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
                && match (self, other) {
                    (NiType::AvoidNode(__self_0), NiType::AvoidNode(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (
                        NiType::BrickNiExtraData(__self_0),
                        NiType::BrickNiExtraData(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        NiType::BSMirroredNode(__self_0),
                        NiType::BSMirroredNode(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        NiType::NiAccumulator(__self_0),
                        NiType::NiAccumulator(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        NiType::NiAlphaAccumulator(__self_0),
                        NiType::NiAlphaAccumulator(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        NiType::NiAlphaController(__self_0),
                        NiType::NiAlphaController(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        NiType::NiAlphaProperty(__self_0),
                        NiType::NiAlphaProperty(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        NiType::NiAmbientLight(__self_0),
                        NiType::NiAmbientLight(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        NiType::NiAutoNormalParticles(__self_0),
                        NiType::NiAutoNormalParticles(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        NiType::NiAutoNormalParticlesData(__self_0),
                        NiType::NiAutoNormalParticlesData(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (NiType::NiAVObject(__self_0), NiType::NiAVObject(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (
                        NiType::NiBillboardNode(__self_0),
                        NiType::NiBillboardNode(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (NiType::NiBltSource(__self_0), NiType::NiBltSource(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (
                        NiType::NiBSAnimationManager(__self_0),
                        NiType::NiBSAnimationManager(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        NiType::NiBSAnimationNode(__self_0),
                        NiType::NiBSAnimationNode(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        NiType::NiBSPArrayController(__self_0),
                        NiType::NiBSPArrayController(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        NiType::NiBSParticleNode(__self_0),
                        NiType::NiBSParticleNode(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (NiType::NiBSPNode(__self_0), NiType::NiBSPNode(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (NiType::NiCamera(__self_0), NiType::NiCamera(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (
                        NiType::NiClusterAccumulator(__self_0),
                        NiType::NiClusterAccumulator(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        NiType::NiCollisionSwitch(__self_0),
                        NiType::NiCollisionSwitch(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (NiType::NiColorData(__self_0), NiType::NiColorData(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (
                        NiType::NiDirectionalLight(__self_0),
                        NiType::NiDirectionalLight(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        NiType::NiDitherProperty(__self_0),
                        NiType::NiDitherProperty(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        NiType::NiDX8Renderer(__self_0),
                        NiType::NiDX8Renderer(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        NiType::NiDynamicEffect(__self_0),
                        NiType::NiDynamicEffect(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        NiType::NiEmitterModifier(__self_0),
                        NiType::NiEmitterModifier(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (NiType::NiExtraData(__self_0), NiType::NiExtraData(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (
                        NiType::NiFlipController(__self_0),
                        NiType::NiFlipController(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        NiType::NiFloatController(__self_0),
                        NiType::NiFloatController(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (NiType::NiFloatData(__self_0), NiType::NiFloatData(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (
                        NiType::NiFltAnimationNode(__self_0),
                        NiType::NiFltAnimationNode(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        NiType::NiFogProperty(__self_0),
                        NiType::NiFogProperty(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (NiType::NiGeometry(__self_0), NiType::NiGeometry(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (
                        NiType::NiGeometryData(__self_0),
                        NiType::NiGeometryData(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        NiType::NiGeomMorpherController(__self_0),
                        NiType::NiGeomMorpherController(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (NiType::NiGravity(__self_0), NiType::NiGravity(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (
                        NiType::NiKeyframeController(__self_0),
                        NiType::NiKeyframeController(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        NiType::NiKeyframeData(__self_0),
                        NiType::NiKeyframeData(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        NiType::NiKeyframeManager(__self_0),
                        NiType::NiKeyframeManager(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (NiType::NiLight(__self_0), NiType::NiLight(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (
                        NiType::NiLightColorController(__self_0),
                        NiType::NiLightColorController(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (NiType::NiLines(__self_0), NiType::NiLines(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (NiType::NiLinesData(__self_0), NiType::NiLinesData(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (NiType::NiLODNode(__self_0), NiType::NiLODNode(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (
                        NiType::NiLookAtController(__self_0),
                        NiType::NiLookAtController(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        NiType::NiMaterialColorController(__self_0),
                        NiType::NiMaterialColorController(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        NiType::NiMaterialProperty(__self_0),
                        NiType::NiMaterialProperty(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (NiType::NiMorphData(__self_0), NiType::NiMorphData(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (
                        NiType::NiMorpherController(__self_0),
                        NiType::NiMorpherController(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (NiType::NiNode(__self_0), NiType::NiNode(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (NiType::NiObject(__self_0), NiType::NiObject(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (NiType::NiObjectNET(__self_0), NiType::NiObjectNET(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (NiType::NiPalette(__self_0), NiType::NiPalette(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (
                        NiType::NiParticleBomb(__self_0),
                        NiType::NiParticleBomb(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        NiType::NiParticleCollider(__self_0),
                        NiType::NiParticleCollider(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        NiType::NiParticleColorModifier(__self_0),
                        NiType::NiParticleColorModifier(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        NiType::NiParticleGrowFade(__self_0),
                        NiType::NiParticleGrowFade(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        NiType::NiParticleModifier(__self_0),
                        NiType::NiParticleModifier(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        NiType::NiParticleRotation(__self_0),
                        NiType::NiParticleRotation(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (NiType::NiParticles(__self_0), NiType::NiParticles(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (
                        NiType::NiParticlesData(__self_0),
                        NiType::NiParticlesData(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        NiType::NiParticleSystemController(__self_0),
                        NiType::NiParticleSystemController(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        NiType::NiPathController(__self_0),
                        NiType::NiPathController(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (NiType::NiPixelData(__self_0), NiType::NiPixelData(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (
                        NiType::NiPlanarCollider(__self_0),
                        NiType::NiPlanarCollider(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (NiType::NiPointLight(__self_0), NiType::NiPointLight(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (NiType::NiPosData(__self_0), NiType::NiPosData(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (NiType::NiProperty(__self_0), NiType::NiProperty(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (
                        NiType::NiRenderedCubeMap(__self_0),
                        NiType::NiRenderedCubeMap(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        NiType::NiRenderedTexture(__self_0),
                        NiType::NiRenderedTexture(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (NiType::NiRenderer(__self_0), NiType::NiRenderer(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (
                        NiType::NiRollController(__self_0),
                        NiType::NiRollController(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        NiType::NiRotatingParticles(__self_0),
                        NiType::NiRotatingParticles(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        NiType::NiRotatingParticlesData(__self_0),
                        NiType::NiRotatingParticlesData(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (NiType::NiRotData(__self_0), NiType::NiRotData(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (
                        NiType::NiScreenPolygon(__self_0),
                        NiType::NiScreenPolygon(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        NiType::NiSequenceStreamHelper(__self_0),
                        NiType::NiSequenceStreamHelper(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        NiType::NiShadeProperty(__self_0),
                        NiType::NiShadeProperty(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (NiType::NiSkinData(__self_0), NiType::NiSkinData(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (
                        NiType::NiSkinInstance(__self_0),
                        NiType::NiSkinInstance(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        NiType::NiSkinPartition(__self_0),
                        NiType::NiSkinPartition(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        NiType::NiSortAdjustNode(__self_0),
                        NiType::NiSortAdjustNode(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        NiType::NiSourceTexture(__self_0),
                        NiType::NiSourceTexture(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        NiType::NiSpecularProperty(__self_0),
                        NiType::NiSpecularProperty(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        NiType::NiSphericalCollider(__self_0),
                        NiType::NiSphericalCollider(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (NiType::NiSpotLight(__self_0), NiType::NiSpotLight(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (
                        NiType::NiStencilProperty(__self_0),
                        NiType::NiStencilProperty(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        NiType::NiStringExtraData(__self_0),
                        NiType::NiStringExtraData(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (NiType::NiSwitchNode(__self_0), NiType::NiSwitchNode(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (
                        NiType::NiTextKeyExtraData(__self_0),
                        NiType::NiTextKeyExtraData(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (NiType::NiTexture(__self_0), NiType::NiTexture(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (
                        NiType::NiTextureEffect(__self_0),
                        NiType::NiTextureEffect(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        NiType::NiTexturingProperty(__self_0),
                        NiType::NiTexturingProperty(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        NiType::NiTimeController(__self_0),
                        NiType::NiTimeController(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        NiType::NiTriBasedGeom(__self_0),
                        NiType::NiTriBasedGeom(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        NiType::NiTriBasedGeomData(__self_0),
                        NiType::NiTriBasedGeomData(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (NiType::NiTriShape(__self_0), NiType::NiTriShape(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (
                        NiType::NiTriShapeData(__self_0),
                        NiType::NiTriShapeData(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        NiType::NiTriShapeDynamicData(__self_0),
                        NiType::NiTriShapeDynamicData(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (NiType::NiTriStrips(__self_0), NiType::NiTriStrips(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (
                        NiType::NiTriStripsData(__self_0),
                        NiType::NiTriStripsData(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        NiType::NiUVController(__self_0),
                        NiType::NiUVController(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (NiType::NiUVData(__self_0), NiType::NiUVData(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (
                        NiType::NiVertexColorProperty(__self_0),
                        NiType::NiVertexColorProperty(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        NiType::NiVertWeightsExtraData(__self_0),
                        NiType::NiVertWeightsExtraData(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        NiType::NiVisController(__self_0),
                        NiType::NiVisController(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (NiType::NiVisData(__self_0), NiType::NiVisData(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (
                        NiType::NiWireframeProperty(__self_0),
                        NiType::NiWireframeProperty(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        NiType::NiZBufferProperty(__self_0),
                        NiType::NiZBufferProperty(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        NiType::RootCollisionNode(__self_0),
                        NiType::RootCollisionNode(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        NiType::TES3ObjectExtraData(__self_0),
                        NiType::TES3ObjectExtraData(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    _ => true,
                }
        }
    }
    impl NiType {
        #[inline]
        pub fn is_instance_of<T>(&self) -> bool
        where
            for<'a> &'a Self: TryInto<&'a T>,
        {
            self.try_into().is_ok()
        }
    }
}
pub use types::*;
pub(crate) mod macros {
    pub(crate) use flag_props;
}
#[allow(unused_imports)]
pub(crate) mod prelude {
    pub use super::*;
    pub use bytes_io::*;
    pub use macros::*;
    pub use nif_macros::*;
    pub use bstr::{BString, ByteSlice, ByteVec};
    pub use bytemuck::{NoUninit, Pod, Zeroable};
    pub use derive_more::{Deref, DerefMut, From, Into};
    pub use hashbrown::{HashMap, HashSet};
    pub use smart_default::SmartDefault;
    pub use std::io;
    pub fn default<T: Default>() -> T {
        Default::default()
    }
    mod math {
        pub use glam::{Affine3A, Mat2, Mat3, Quat, Vec2, Vec3, Vec4};
        pub type ColorA = Vec4;
    }
    pub use math::*;
}
